// @(#)root/eve:$Id: text_test.C 26717 2008-12-07 22:07:55Z matevz $
// Author: Alja Mrak-Tadel

// Makes some tracks with three different magnetic field types.

#include "TEveTrackPropagator.h"
#include "TEveTrack.h"
#include "TEveManager.h"
#include "TEveViewer.h"
#include "TSystem.h"
#include "TGLViewer.h"
#include "TMath.h"

#include "TEveViewer.h"
#include "TEvePointSet.h"

#include <iostream>

TEveTrackPropagator* g_prop = 0;

class GappedField : public TEveMagField
{
public:
   GappedField():TEveMagField(){}
   ~GappedField(){};
   using   TEveMagField::GetField;

   virtual TEveVector GetField(Float_t /*x*/, Float_t /*y*/, Float_t z) const
   {
      if (TMath::Abs(z) < 300) return TEveVector(0, 0, -4);
      if (TMath::Abs(z) < 600) return TEveVector(0, 0, 0);
      return TEveVector(0, 0, 4);
   }
};

//==============================================================================

class CmsMagField: public TEveMagField
{
   bool m_magnetIsOn;
   bool m_reverse;
   bool m_simpleModel;

public:
   CmsMagField():
      m_magnetIsOn(true),
      m_reverse(false),
      m_simpleModel(true){}

   virtual ~CmsMagField(){}
   virtual Float_t    GetMaxFieldMag() const { return m_magnetIsOn ? 3.8 : 0.0; }
   void               setMagnetState( bool state )
   {
      if (state != m_magnetIsOn)
      {
         if ( state )
            std::cout << "Magnet state is changed to ON" << std::endl;
         else
            std::cout << "Magnet state is changed to OFF" << std::endl;
      }
      m_magnetIsOn = state;
   }

   bool               isMagnetOn() const { return m_magnetIsOn;}
   void               setReverseState( bool state ){ m_reverse = state; }
   bool               isReverse() const { return m_reverse;}
   void               setSimpleModel( bool simpleModel ){ m_simpleModel = simpleModel; }
   bool               isSimpleModel() const { return m_simpleModel;}

   using   TEveMagField::GetField;

   virtual TEveVector GetField(Float_t x, Float_t y, Float_t z) const
   {
      double R = sqrt(x*x+y*y);
      double field = m_reverse?-GetMaxFieldMag():GetMaxFieldMag();
      //barrel
      if ( TMath::Abs(z)<724 )
      {
         //inside solenoid
         if ( R < 300) return TEveVector(0,0,field);
         // outside solinoid
         if ( m_simpleModel ||
              ( R>461.0 && R<490.5 ) ||
              ( R>534.5 && R<597.5 ) ||
              ( R>637.0 && R<700.0 ) )
            return TEveVector(0,0,-field/3.8*1.2);
 
      } else {
         // endcaps
         if (m_simpleModel)
         {
            if ( R < 50 ) return TEveVector(0,0,field);
            if ( z > 0 )
               return TEveVector(x/R*field/3.8*2.0, y/R*field/3.8*2.0, 0);
            else
               return TEveVector(-x/R*field/3.8*2.0, -y/R*field/3.8*2.0, 0);
         }
         // proper model
         if ( ( TMath::Abs(z)>724 && TMath::Abs(z)<786  ) ||
              ( TMath::Abs(z)>850 && TMath::Abs(z)<910  ) ||
              ( TMath::Abs(z)>975 && TMath::Abs(z)<1003 ) )
         {
            if ( z > 0 )
               return TEveVector(x/R*field/3.8*2.0, y/R*field/3.8*2.0, 0);
            else
               return TEveVector(-x/R*field/3.8*2.0, -y/R*field/3.8*2.0, 0);
         }
      }
      return TEveVector(0,0,0);
   }
};


//==============================================================================
//==============================================================================

//______________________________________________________________________________
TEveTrack* make_track(TEveTrackPropagator* prop, Int_t sign)
{
  // Make track with given propagator.
  // Add to math-marks to test fit.

  TEveRecTrack *rc = new TEveRecTrack();
  rc->fV.Set(0.028558, -0.000918, 3.691919);
  rc->fP.Set(0.767095, -2.400006, -0.313103);
  rc->fSign = sign;

  TEveTrack* track = new TEveTrack(rc, prop);
  track->SetName(Form("Charge %d", sign));
  // daughter 0
  TEvePathMark* pm1 = new TEvePathMark(TEvePathMark::kDaughter);
  pm1->fV.Set(1.479084, -4.370661, 3.119761);
  track->AddPathMark(*pm1);
  // daughter 1
  TEvePathMark* pm2 = new TEvePathMark(TEvePathMark::kDaughter);
  pm2->fV.Set(57.72345, -89.77011, -9.783746);
  track->AddPathMark(*pm2);

  return track;
}


void track(Int_t bCase = 4, Bool_t isRungeKutta = kTRUE)
{
#if defined (__CINT__)
   Error("track.C", "Must be run in compiled mode!");
   return;
#endif

   gSystem->IgnoreSignal(kSigSegmentationViolation, true);
   TEveManager::Create();

   TEveTrackList *list = new TEveTrackList();
   TEveTrackPropagator* prop = g_prop = list->GetPropagator();
   prop->SetFitDaughters(kFALSE);
   prop->SetMaxZ(1000);

   if (isRungeKutta)
   {
      prop->SetStepper(TEveTrackPropagator::kRungeKutta);
      list->SetName("RK Propagator");
   }
   else
   {
      list->SetName("Heix Propagator");
   }

   TEveTrack *track = 0;
   switch (bCase)
   {
      case 0:
      {
         // B = 0 no difference btween signed and charge particles
         prop->SetMagField(0.);
         list->SetElementName(Form("%s, zeroB", list->GetElementName()));
         track = make_track(prop, 1);
         break;
      }

      case 1:
      {
         // constant B field, const angle
         prop->SetMagFieldObj(new TEveMagFieldConst(0., 0., -3.8));
         list->SetElementName(Form("%s, constB", list->GetElementName()));
         track = make_track(prop, 1);
         break;
      }

      case 2:
      {
         // variable B field, sign change at  R = 200 cm
         prop->SetMagFieldObj(new TEveMagFieldDuo(200, -4.4, 2));
         list->SetElementName(Form("%s, duoB", list->GetElementName()));
         track = make_track(prop, 1);
         break;
      }

      case 3:
      {
         // gapped field
         prop->SetMagFieldObj(new GappedField());
         list->SetElementName(Form("%s, gappedB", list->GetElementName()));

      
         TEveRecTrack *rc = new TEveRecTrack();
         rc->fV.Set(0.028558, -0.000918, 3.691919);
         rc->fP.Set(0.767095, -0.400006, 2.313103);
         rc->fSign = 1;
         track = new TEveTrack(rc, prop);

         TEvePointSet* marker = new TEvePointSet(2);  
         marker->SetElementName("B field break points");
         marker->SetPoint(0, 0., 0., 300.f);
         marker->SetPoint(1, 0., 0., 600.f);
         marker->SetMarkerColor(3);
         gEve->AddElement(marker);
         break;
      }

      case 4:
      {
         CmsMagField* mf = new CmsMagField;
         mf->setReverseState(true);

         prop->SetMagFieldObj(mf);
         prop->SetMaxR(1000);
         prop->SetMaxZ(1000);
	 prop->SetRnrDaughters(kTRUE);
	 prop->SetRnrDecay(kTRUE);
	 prop->RefPMAtt().SetMarkerStyle(4);
         list->SetElementName(Form("%s, CMS field", list->GetElementName()));

      
         TEveRecTrack *rc = new TEveRecTrack();
         rc->fV.Set(0.027667, 0.007919, 0.895964);
         rc->fP.Set(3.903134, 2.252232, -3.731366);
         rc->fSign = -1;
         track = new TEveTrack(rc, prop);

         track->AddPathMark(TEvePathMark(TEvePathMark::kDaughter, TEveVector(3.576755e+00, 2.080579e+00, -2.507230e+00)));
         track->AddPathMark(TEvePathMark(TEvePathMark::kDaughter, TEveVector(8.440379e+01, 6.548286e+01, -8.788129e+01)));
         track->AddPathMark(TEvePathMark(TEvePathMark::kDaughter, TEveVector(1.841321e+02, 3.915693e+02, -3.843072e+02)));
         track->AddPathMark(TEvePathMark(TEvePathMark::kDaughter, TEveVector(1.946167e+02, 4.793932e+02, -4.615060e+02)));
         track->AddPathMark(TEvePathMark(TEvePathMark::kDecay,    TEveVector(2.249656e+02, 5.835767e+02, -5.565275e+02)));

	 track->SetRnrPoints(kTRUE);
	 track->SetMarkerStyle(4);

         break;
      }
   };
       
   if (isRungeKutta)
      list->SetLineColor(kMagenta);
   else 
      list->SetLineColor(kCyan);

   track->SetLineColor(list->GetLineColor());
 
   gEve->AddElement(track, list);
   gEve->AddElement(list);
   track->MakeTrack();

   TEveViewer* v = gEve->GetDefaultViewer();
   v->GetGLViewer()->SetGuideState(TGLUtil::kAxesOrigin, kTRUE, kFALSE, 0);
   gEve->Redraw3D(1);
}
