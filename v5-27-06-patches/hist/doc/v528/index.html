<br/>
<hr/>
<a name="hist"></a> 
<h3>Histogram package</h3>

<h4>TGraphDelaunay</h4>
<ul>
<li> New version of the method <tt>TGraphDelaunay::Enclose()</tt>. This method
     decides if a point is inside a triangle or not. The way it was implemented
     produced infinite numbers and generated wrong peaks. It was visible on some
     machines only (for instance MacOsX). Now this method uses 
     <tt>TMath::IsInside()</tt>. It is much safer, it runs faster, and the
     code is simpler. The problem could be seen with a simple macro like the
     following one:
     <pre>
     {
        TCanvas *c1 = new TCanvas("c1", "c1",0,0,600,600);
        c1->SetTheta(90.);
        c1->SetPhi(0.0001);
        gStyle->SetPalette(1);
        TGraph2D *graph2d = new TGraph2D();
        graph2d->SetPoint(0, 110, 110, 0.0);
        graph2d->SetPoint(1, -80,  50, 1.0);
        graph2d->SetPoint(2, -70,  40, 2.0);
        graph2d->SetPoint(3,-110, -50, 3.0);
        graph2d->SetNpx(9);
        graph2d->SetNpy(9);
        graph2d->Draw("surf1");
        graph2d->SetLineWidth(2);
        graph2d->Draw(" triw p0 same");
     }
     </pre>
</li>
<li> The X and Y vectors are normalized in order to compute the triangles.
     The scale factor used was the same for the X and Y axis.
     This generated problems (very long triangles instead of the obvious ones)
     in some cases when the X and Y axis had very different ranges. Having two 
     scale factors, one for the X axis and one for the Y axis, cures the problem.</li>
</ul>

<h4>TGraph2D</h4>
<ul>
<li> In case all the points are in the same Z-plane Z0 (zmin = zmax), the graph
     minimum is set to Z0-0.01*Z0 and the maximum to Z0+0.01*Z0. This
     allow to make <tt>TGraph2D</tt> like:
     <pre>
     {
        double *x = new double[2];
        double *y = new double[2];
        double *z = new double[2];
        x[0] = 6215.;
        x[1] = 5542.;
        y[0] = 3853.;
        y[1] = 5270.;
        z[0] = 2723.;
        z[1] = 2723.;
        TGraph2D * g = new TGraph2D(2, x, y, z);
        g->Draw("LINE");   
     }
     </pre>
</li>
</ul>

<h4>TGraph2DPainter</h4>
<ul>
<li> When a <tt>TGraph2D</tt> was painted with the option <tt>TRI1</tt> the 
     color distribution in case of log scale along the Z axis was wrong.</li>
</ul>

<h4>THistPainter</h4>
<ul>
<li> After executing the following macro, zooming the X axis interactively
     generated the error message:
     <br/>
     <tt>Error in &lt;TGraphPainter::PaintGraphHist&gt;: X must have N+1 values with option N </tt>
     <pre>
     {
        int n = 70;
        TH1F h("h","test",n,0.,30.);
        TRandom3 rndm_engine;
        for (int i=0; i&lt;10000; ++i) h->Fill(rndm_engine->Gaus(15.,4.));
        TF1 f("f","gaus");
        h->Fit("f");
        gPad->SetLogx();
     }
     </pre>
</li>
<li> The following macro didn't draw any box. Because of a precision
     problem the filled bin was not drawn.
     <pre>
     {
        double yarr[] = { 1.0, 2.0, 3.0, 4.0 };
        double xarr[] = { 0.01, 0.02, 0.03, 0.04 };
        TH2D *h = new TH2D("h","h",3,xarr,3,yarr);
        h->Fill(0.011,2.5);
        h->Draw("box");           
     }
     </pre>
</li>
<li> The following macro displayed the histogram out of the frame
     (option "bar"):
     <pre>
     {
        gStyle->SetHistMinimumZero();
        TH1F* h = new TH1F("h","h", 44, -0.5, 43.5);
        h->SetBarWidth(0.7);
        h->SetBarOffset(0.2);
        h->SetFillColor(kGreen);
        for (int i=0;i&lt;44; i++ ) h->Fill(i, -i-60);
        h->DrawCopy("bar1");
     } 
     </pre>
</li>
<li> The setting <tt>gStyle->SetHistMinimumZero()</tt> now works for horizontal
     plots produced with the option <tt>HBAR</tt>.
     <center><img src="hbarmin0.gif" alt="HBAR option"/></center>
</li>
<li> In the case of profile histograms it is possible to print the number
     of entries instead of the bin content. It is enough to combine the  
     option "E" (for entries) with the option "TEXT".
     <pre>
     {
        TCanvas *c02 = new TCanvas("c02","c02",700,400);
        c02->Divide(2,1);
        TProfile *profile = new TProfile("profile","profile",10,0,10);
        profile->SetMarkerSize(2.2);
        profile->Fill(0.5,1);
        profile->Fill(1.5,2);
        profile->Fill(2.5,3);
        profile->Fill(3.5,4);
        profile->Fill(4.5,5);
        profile->Fill(5.5,5);
        profile->Fill(6.5,4);
        profile->Fill(7.5,3);
        profile->Fill(8.5,2);
        profile->Fill(9.5,1);
        c02->cd(1); profile->Draw("HIST TEXT0");
        c02->cd(2); profile->Draw("HIST TEXT0E");
     } 
     </pre>
     <center><img src="textoption.gif" alt="TEXT option"/></center>
</li>
<li> The following lines generated an empty stats box:
     <pre>
     gStyle->SetStatFont(43);
     gStyle->SetStatFontSize(12);
     TH2D *h2 = new TH2D("h2","h2",10,0,1,10,0,1);
     h2->Draw();
     </pre>
</li>
<li> PaintAxis does not redraw the axis labels and the axis title in case
     of axis redrawing. Only the tick marks are redrawn. Redrawing the
     labels and title made them appear a bit thicker.
</li>
<li> Fix a precision issue in PaintInit. The problem showed up with
     the following lines:
     <pre>
     TF1 *f = new TF1("f","exp(-x)*exp(x-2.)",0.,2.0);
     f->Draw();
     </pre>
</li>
<li> For 2D histograms plotted with option <tt>TEXT</tt>, it is possible to
     plot empty cells by calling <tt>gStyle->SetHistMinimumZero()</tt>.
</li>
<li> An empty frame is drawn when an empty 1D histogram is painted with log
     scale along the Y axis and when a 2D histogram is painted with log scale
     along the Z axis.
</li>
<li> Log axis for TH3 histograms did not work.
</li>
</ul>

<h4>TGraphPainter</h4>
<ul>
<li> When painted with option "2" (errors represented with boxes) the graph
     with error bars were not clipped if the boxes were outside the frame
     limits. This problem was visible with TGraphErrors, TGraphAsymmErrors and 
     TGraphBentErrors. The following macro showed the problem:
     <pre>
     {
        TCanvas *c1 = new TCanvas("c1","c1",200,10,700,500);

        const Int_t n    = 10;
        Double_t x[n]    = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};
        Double_t y[n]    = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};
        Double_t ex[n]   = {.05,.1,.07,.07,10.04,.05,.06,.07,.08,.05};
        Double_t ey[n]   = {3.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};
        Double_t exd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0}; 
        Double_t eyd[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0}; 

        TGraphErrors *gr1 = new TGraphErrors(n,x,y,ex,ey);
        gr1->SetFillStyle(3004);

        TGraphAsymmErrors *gr2 = new TGraphAsymmErrors(n, x, y, ex, ex, ey, ey);
        gr2->SetFillStyle(3005);

        TGraphBentErrors *gr3 = new TGraphBentErrors(n,x,y,ex,ex,ey,ey,exd,exd,eyd,eyd);        
        gr3->SetFillStyle(3006);

        c1->DrawFrame(-1,0,1,10);

        gr1->Draw("2");
        gr2->Draw("2");
        gr3->Draw("2");  
     }
     </pre>
</li>
<li> In PaintGraphBentErrors the fill style was not set for the boxes.</li>
<li> The following macro displayed the histogram out of the frame
     (option "b"):
     <pre>
     {
        gStyle->SetHistMinimumZero();
        TH1F* h = new TH1F("h","h", 44, -0.5, 43.5);
        h->SetBarWidth(0.7);
        h->SetBarOffset(0.2);
        h->SetFillColor(kGreen);
        for (int i=0;i&lt;44; i++ ) h->Fill(i, -i-60);
        h->DrawCopy("b");
     } 
     </pre>
</li>
<li> It was not possible to interactively move a graph with many points
     close to each other. It was only possible to move the points one by one.</li>
<li> PaintGrapHist: improvements with the option "][".</li>
</ul>

<h4>TGraph</h4>
<ul>
<li>Fix a bug in <tt>TGraph::Eval</tt> when evaluating at the graph point
    values. </li>
<li> With the following macro the axis title was not displayed:
    <pre>
    {
       TGraph *graph = new TGraph ();
       graph->SetPoint(0, 0.00100, 30.00);
       graph->SetPoint(1, 0.00150, 20.00);
       graph->SetPoint(2, 0.01150, 30.00);
       graph->Draw("AL*");
       graph->GetXaxis()->SetTitle("foo") ;
       gPad->SetLogx(1) ;
    }
    </pre>
</li>
</ul>  

<h4>THStack</h4>
<ul>
<li>The color index used to erase the background while drawing a stack of 1D
    histogram was wrong.</li>
</ul>  

<h4>TF1</h4>
<ul>
  <li> Bug fixed in TF1 zooming on Y axis. To reproduce it do:
     <pre>
     root [0] TF1 f1( "f1", "-x", 1,3)
     root [1] f1.Draw()
     </pre>
     now selecting some range on the y-axis with the mouse
     jumped to the range (0, 1) instead of chosen range.
  </li>
  <li> Add in <tt>TF1::GetX</tt> and <tt>TF1::GetMaximum, TF1::GetMinimum</tt> and
  <tt>TF1::GetMaximumX, TF1::GetMinimumX</tt> the tolerance and max number
  of iterations as extra parameters with default values of
  tolerance=10E-10 and max iterations=100
  </li>
</ul>

<h4>TH1</h4>
<ul>
  <li>Implement a faster version of <tt>TH1::FillRandom(TH1*,int)</tt>
  when the passed histogram has the same bins. In this case generate
  the flactuations bin by bins using Multinomial statistics
  </li>
</ul>

<h4>THnSparse</h4>
<ul>
  <li>Shrink THnSparse on disk by 70% in an arbitrary example case;
  also reduce memory usage, especially when not filling.
  <br/>
  <b>IMPORTANT NOTE</b>: while new THnSparse objects can be read and e.g. projected from in old ROOT versions, filling a new THnSparse object in old ROOT versions does NOT WORK!</li>
  <li>
  Add SetBinContent(), AddBinContent(), SetBinError() taking the
  linear bin index. Use it in Projection() for a considerable
  speed-up.</li>
</ul>
  
<h4>TSpectrum2Painter</h4>
<ul>
<li> New parameter bf() in the SPEC option to define the buffer size
  used by TSpectrum2Painter. It is needed in case of very
  large canvases like 8000x5000.</li>
</ul>
