<br> 
<hr> 
<a name="tree"></a> 
<h3>Tree</h3>
<ul>
<li>Add new special functions in TTreeFormula (and hence TTree::Draw and TTree::Scan) to calculate the minimun and maximum with an entry:
    <ul>
    <li><pre lang="cxx">Min$(formula),Max$(formula):</pre>return the minimun/maximum (within one TTree entry) of the value of the
                       elements of the formula given as a parameter.</li>
    <li><pre lang="cxx">MinIf$(formula,condition),MaxIf$(formula,condition):</pre>return the minimum (maximum) (within one TTree entry)
                       of the value of the elements of the formula given as a parameter
                      if they match the condition. If not element match the condition, the result is zero.  To avoid the
                       the result is zero.  To avoid the consequent peak a zero, use the 
                       pattern: 
       <pre lang="cxx">tree->Draw("MinIf$(formula,condition)","condition");</pre>
                       which will avoid calculation MinIf$ for the entries that have no match 
                       for the condition.</li>
    </ul>
</li>
<li>Add support in TTreeFormula (and hence TTree::Draw and TTree::Scan) for the ternary condition operator ( cond ? if_expr : else_expr ).</li>
<li>Significantly (by 2 order of magnitude) improved the performance of TTree::Draw calling C++ functions.</li>
<li>Replace the function <tt>TSelectorDraw::MakeIndex</tt> and <tt>TSelectorDraw::GetNameByIndex</tt> 
     with the function <tt>TSelectorDraw::SplitNames.</tt>  </li>
<li>Add a return value to SetBranchAddress, a return value greater or equal to zero indicate success, a negative
value indicates failure (in both case, the address is still updated).  Example:
<pre lang="cxx">if (tree->SetBranchAddress(mybranch,&myvar) < 0) {
   cerr << "Something went wrong\n";
   return;
}</pre>
The possible return values are:<ul>
<li>kMissingBranch (-5) : Missing branch</li>
<li>kInternalError (-4) : Internal error (could not find the type corresponding to a data type number.</li>
<li>kMissingCompiledCollectionProxy (-3) : Missing compiled collection proxy for a compiled collection.</li>
<li>kMismatch (-2) : Non-Class Pointer type given does not match the type expected by the branch.</li>
<li>kClassMismatch (-1) : Class Pointer type given does not match the type expected by the branch.</li>
<li>kMatch (0) : perfect match.</li>
<li>kMatchConversion (1) : match with (I/O) conversion.</li>
<li>kMatchConversionCollection (2) : match with (I/O) conversion of the content of a collection.</li>
<li>kMakeClass (3) : MakeClass mode so we can not check.</li>
<li>kVoidPtr (4) : void* passed so no check was made.</li>
<li>kNoCheck (5) : Underlying TBranch not yet available so no check was made.</li>
</ul>
</ul>

<h4>New function TTree::OptimizeBaskets</h4>
void TTree::OptimizeBaskets(Int_t maxMemory, Float_t minComp, Option_t *option) 
<p>
This function may be called after having filled some entries in a Tree
using the information in the existing branch buffers, it will reassign
new branch buffer sizes to optimize time and memory.

The function computes the best values for branch buffer sizes such that
the total buffer sizes is less than maxMemory and nearby entries written 
at the same time.
In case the branch compression factor for the data written so far is less 
than compMin, the compression is disabled.
 
if option ="d" an analysis report is printed.

<p>
This function may also be called on an existing Tree to figure out the best values
given the information in the Tree header
<pre>
   TFile f("myfile.root");
   TTree *T = (TTree*)f.Get("mytreename");
   T->Print();  //show the branch buffer sizes before optimization
   T->OptimizeBaskets(10000000,1,"d");
   T->Print();  //show the branch buffer sizes after optimization
</pre>
