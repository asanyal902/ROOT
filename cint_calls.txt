Can be made external; they depend on the C interface:
foam
guibuilder
hist
html
mathcore
minuit
minuit2
roofitcore

That leaves
base cintex io main meta metautils pyroot rint ruby table thread tree utils winnt


base/src/ManualBase4.cxx: (just like any other dictionary)
base/src/TQConnection.cxx:   fFunc = new G__CallFunc;
base/src/TQConnection.cxx:      fClass = new G__ClassInfo();
base/src/TQConnection.cxx:   fFunc = new G__CallFunc;
base/src/TQConnection.cxx:   fClass = new G__ClassInfo();
base/src/TQConnection.cxx:      funcname = G__p2f2funcname(fReceiver);
base/src/TQObject.cxx:      G__MethodInfo meth;
base/src/TQObject.cxx:      G__CallFunc  func;
base/src/TQObject.cxx:   G__load_text(RQ_OBJECT_STRING1);
base/src/TQObject.cxx:   G__load_text(RQ_OBJECT_STRING2);
base/src/TQObject.cxx:   G__load_text(RQ_OBJECT_STRING);
base/src/TStorage.cxx:   Long_t gvp = G__getgvp();
base/src/TStorage.cxx:   if ((Long_t)vp == gvp && gvp != G__PVOID)
base/src/TSystem.cxx:   return G__findsym(entry);
base/src/TSystem.cxx:      G__unloadfile(path);
base/src/TSystem.cxx:      if ( G__unloadfile( (char*) filename ) != 0 ) {
base/src/TSystem.cxx:         if ( G__unloadfile( (char*) library.Data() ) != 0 ) {
base/src/TSystem.cxx:         if ( G__unloadfile( (char*) library.Data() ) != 0 ) {
base/src/TSystem.cxx:      G__Set_RTLD_NOW();
base/src/TSystem.cxx:      G__Set_RTLD_LAZY();
base/src/TVirtualFitter.cxx:   char *funcname = G__p2f2funcname(fcn);
foam/src/TFoam.cxx:   const Char_t *namefcn = G__p2f2funcname(fun); //name of integrand function
guibuilder/src/TGuiBldDragManager.cxx:         G__calc((char *)str.Data());
hist/src/TF1.cxx:   char *funcname = G__p2f2funcname(fcn);
io/src/TGenCollectionProxy.cxx:         G__value gval = G__string2type_body(inside.c_str(),2);
io/src/TGenCollectionProxy.cxx:         G__TypeInfo ti(gval);
io/src/TGenCollectionProxy.cxx:         G__TypeInfo ti(inside.c_str());
main/src/cppmain.cxx:extern void G__setothermain(int othermain);
main/src/cppmain.cxx:extern int G__main(int argc,char **argv);
main/src/cppmain.cxx:   G__setothermain(0);
main/src/cppmain.cxx:   return(G__main(argc,argv));
mathcore/src/FunctorCint.cxx:      char *funcname = G__p2f2funcname((void *) fPtr);
mathcore/src/FunctorCint.cxx:   char *funcname = G__p2f2funcname((void *) p1);
mathcore/src/FunctorCint.cxx:   char *funcname2 = G__p2f2funcname((void *) p2);
mathcore/src/FunctorCint.cxx:      char *funcname = G__p2f2funcname((void *) fPtr);
mathcore/src/FunctorCint.cxx:   char *funcname = G__p2f2funcname((void *) p1);
mathcore/src/FunctorCint.cxx:   char *funcname2 = G__p2f2funcname((void *) p2);
meta/src/TBaseClass.cxx:TBaseClass::TBaseClass(G__BaseClassInfo *info, TClass *cl) : TDictionary()
meta/src/TBaseClass.cxx:   // TBaseClass dtor deletes adopted G__BaseClassInfo object.
meta/src/TCint.cxx:   ULong_t varp = G__getgvp();
meta/src/TCint.cxx:   G__setgvp(G__PVOID);
meta/src/TCint.cxx:   G__setgvp(varp);
meta/src/TCint.cxx:extern "C" void *TCint_FindSpecialObject(char *c, G__ClassInfo *ci, void **p1, void **p2) {
meta/src/TCint.cxx:   G__RegisterScriptCompiler(&ScriptCompiler);
meta/src/TCint.cxx:   G__set_ignoreinclude(&IgnoreInclude);
meta/src/TCint.cxx:   G__InitUpdateClassInfo(&TCint_UpdateClassInfo);
meta/src/TCint.cxx:   G__InitGetSpecialObject(&TCint_FindSpecialObject);
meta/src/TCint.cxx:   G__LockCpp();
meta/src/TCint.cxx:      // G__scratch_all();
meta/src/TCint.cxx:      G__close_inputfiles();
meta/src/TCint.cxx:   // terminated by G__init_cint() and G__dlmod().
meta/src/TCint.cxx:   G__clearfilebusy(0);
meta/src/TCint.cxx:   G__clearstack();
meta/src/TCint.cxx:   // by G__init_cint() and G__dlmod().
meta/src/TCint.cxx:   return G__call_setup_funcs();
meta/src/TCint.cxx:   G__set_class_autoloading_callback(&TCint_AutoLoadCallback);
meta/src/TCint.cxx:   G__SourceFileInfo file(filename);
meta/src/TCint.cxx:      i = G__loadfile(filename);
meta/src/TCint.cxx:      i = G__loadsystemfile(filename);
meta/src/TCint.cxx:   // If the command is executed and the result of G__process_cmd is 0,
meta/src/TCint.cxx:         G__value local_res;
meta/src/TCint.cxx:         G__setnull(&local_res);
meta/src/TCint.cxx:            G__free_tempobject();
meta/src/TCint.cxx:            int prerun = G__getPrerun();
meta/src/TCint.cxx:            G__setPrerun(0);
meta/src/TCint.cxx:            ret = G__process_cmd((char *)line, fPrompt, &fMore, &local_error, &local_res);
meta/src/TCint.cxx:            G__setPrerun(prerun);
meta/src/TCint.cxx:            if (local_error == 0 && G__get_return(&fExitCode) == G__RETURN_EXIT2) {
meta/src/TCint.cxx:         if (ret == 0) ret = G__int_cast(local_res);
meta/src/TCint.cxx:      G__value local_res;
meta/src/TCint.cxx:      G__setnull(&local_res);
meta/src/TCint.cxx:      int prerun = G__getPrerun();
meta/src/TCint.cxx:      G__setPrerun(0);
meta/src/TCint.cxx:      ret = G__process_cmd((char *)line, fPrompt, &fMore, &local_error, &local_res);
meta/src/TCint.cxx:      G__setPrerun(prerun);
meta/src/TCint.cxx:      if (local_error == 0 && G__get_return(&fExitCode) == G__RETURN_EXIT2) {
meta/src/TCint.cxx:      if (ret == 0) ret = G__int_cast(local_res);
meta/src/TCint.cxx:   result = (Long_t) G__int_cast(G__calc((char *)line));
meta/src/TCint.cxx:   if (error) *error = (EErrorCode)G__lasterror();
meta/src/TCint.cxx:   Printf("\nCINT/ROOT C/C++ Interpreter version %s", G__cint_version());
meta/src/TCint.cxx:   G__scratch_upto(&fDictPos);
meta/src/TCint.cxx:   G__init_cint("cint +V");
meta/src/TCint.cxx:   G__init_process_cmd();
meta/src/TCint.cxx:   G__scratch_globals_upto(&fDictPosGlobals);
meta/src/TCint.cxx:   G__rewinddictionary();
meta/src/TCint.cxx:   return G__deleteglobal(obj);
meta/src/TCint.cxx:   G__store_dictposition(&fDictPos);
meta/src/TCint.cxx:   G__store_dictposition(&fDictPosGlobals);
meta/src/TCint.cxx:   G__DataMemberInfo t, *a;
meta/src/TCint.cxx:         a = new G__DataMemberInfo(t);
meta/src/TCint.cxx:   G__MethodInfo t, *a;
meta/src/TCint.cxx:                  needToAdd = !((prop & G__BIT_ISCOMPILED)
meta/src/TCint.cxx:            a = new G__MethodInfo(t);
meta/src/TCint.cxx:   int this_scratch_count = G__scratch_upto(0);
meta/src/TCint.cxx:   G__TypedefInfo t (last_typenum);
meta/src/TCint.cxx:            gROOT->fTypes->Add(new TDataType(new G__TypedefInfo(t)));
meta/src/TCint.cxx:   // Set pointer to CINT's G__ClassInfo in TClass.
meta/src/TCint.cxx:         cl->fClassInfo = new G__ClassInfo(cl->GetName());
meta/src/TCint.cxx:      G__ClassInfo info(classname);
meta/src/TCint.cxx:   Int_t tagnum = G__defined_tagname(classname, 2); // This function might modify the name (to add space between >>).
meta/src/TCint.cxx:   G__TypedefInfo t(name);
meta/src/TCint.cxx:   if (t.IsValid() && !(t.Property()&G__BIT_ISFUNDAMENTAL)) {
meta/src/TCint.cxx:      G__BaseClassInfo t(*cl->GetClassInfo()), *a;
meta/src/TCint.cxx:            a = new G__BaseClassInfo(t);
meta/src/TCint.cxx:      G__DataMemberInfo t(*cl->GetClassInfo()), *a;
meta/src/TCint.cxx:         if (t.IsValid() && t.Name() && strcmp(t.Name(), "G__virtualinfo")) {
meta/src/TCint.cxx:            a = new G__DataMemberInfo(t);
meta/src/TCint.cxx:      G__MethodInfo t(*cl->GetClassInfo()), *a;
meta/src/TCint.cxx:            a = new G__MethodInfo(t);
meta/src/TCint.cxx:      G__MethodArgInfo t(*m->fInfo), *a;
meta/src/TCint.cxx:            a = new G__MethodArgInfo(t);
meta/src/TCint.cxx:   G__CallFunc  func;
meta/src/TCint.cxx:      G__ClassInfo gcl;   // default G__ClassInfo is global environment
meta/src/TCint.cxx:   G__ClassInfo gcl;   // default G__ClassInfo is global environment
meta/src/TCint.cxx:   G__CallFunc  func;
meta/src/TCint.cxx:      G__ClassInfo gcl;   // default G__ClassInfo is global environment
meta/src/TCint.cxx:   G__InterfaceMethod f;
meta/src/TCint.cxx:      G__ClassInfo gcl;   // default G__ClassInfo is global environment
meta/src/TCint.cxx:   G__ClassInfo cl(name);
meta/src/TCint.cxx:   G__CallFunc  func;
meta/src/TCint.cxx:   G__ClassInfo cl;
meta/src/TCint.cxx:   if (error) *error = G__lasterror();
meta/src/TCint.cxx:   G__CallFunc func;
meta/src/TCint.cxx:   if (error) *error = G__lasterror();
meta/src/TCint.cxx:         G__TypeInfo type( arg->GetFullTypeName() );
meta/src/TCint.cxx:   G__SourceFileInfo srcfile(G__get_ifile()->filenum);
meta/src/TCint.cxx:   return G__get_ifile()->name;
meta/src/TCint.cxx:                        G__set_class_autoloading_table((char*)base.Data(), "");
meta/src/TCint.cxx:         G__set_class_autoloading_table((char*)cls.Data(), lib);
meta/src/TCint.cxx:         G__security_recover(stderr); // Ignore any error during this setting.
meta/src/TCint.cxx:                        //G__remove_from_class_autoloading_table((char*)base.Data());
meta/src/TCint.cxx:         G__set_class_autoloading_table((char*)cls.Data(), "");
meta/src/TCint.cxx:         G__security_recover(stderr); // Ignore any error during this setting.
meta/src/TCint.cxx:   Int_t oldvalue = G__set_class_autoloading(0);
meta/src/TCint.cxx:   G__set_class_autoloading(oldvalue);
meta/src/TCint.cxx:void *TCint::FindSpecialObject(const char *item, G__ClassInfo *type,
meta/src/TCint.cxx:   // cases we have to update the tagnum in the G__ClassInfo used by
meta/src/TCint.cxx:   G__SourceFileInfo cursor(0);
meta/src/TCint.cxx:   return !G__const_whatnoerror();
meta/src/TCint.cxx:      G__const_resetnoerror();
meta/src/TCint.cxx:      G__const_setnoerror();
meta/src/TCint.cxx:   return !G__const_whatnoerror();
meta/src/TCint.cxx:   G__add_ipath(incpath);
meta/src/TCint.cxx:   G__IncludePathInfo path;
meta/src/TClass.cxx:extern Long_t G__globalvarpointer;
meta/src/TClass.cxx:   G__ClassInfo *classInfo = cl->GetClassInfo();
meta/src/TClass.cxx:   G__DataMemberInfo m(*classInfo);
meta/src/TClass.cxx:   if ( fInterStreamer ) delete ((G__CallFunc*)fInterStreamer);
meta/src/TClass.cxx:            G__CallFunc func;
meta/src/TClass.cxx:      G__CallFunc* f  = new G__CallFunc;
meta/src/TClass.cxx:      G__CallFunc func;
meta/src/TClass.cxx:         G__BaseClassInfo t(*GetClassInfo());
meta/src/TClass.cxx:   if (faddr == (Long_t)G__exec_bytecode) {
meta/src/TClass.cxx:   G__CallFunc  func;
meta/src/TClass.cxx:   G__MethodInfo *info = new G__MethodInfo(func.GetMethodInfo());
meta/src/TClass.cxx:   int autoload_old = G__set_class_autoloading(0);
meta/src/TClass.cxx:   G__set_class_autoloading(autoload_old);
meta/src/TClass.cxx:         G__CallFunc* func = (G__CallFunc*)fInterStreamer;
meta/src/TClass.cxx:            func  = new G__CallFunc;
meta/src/TDataMember.cxx:TDataMember::TDataMember(G__DataMemberInfo *info, TClass *cl) : TDictionary()
meta/src/TDataMember.cxx:      fInfo=new G__DataMemberInfo(*dm.fInfo);
meta/src/TDataType.cxx:TDataType::TDataType(G__TypedefInfo *info) : TDictionary()
meta/src/TFunction.cxx:TFunction::TFunction(G__MethodInfo *info) : TDictionary()
meta/src/TFunction.cxx:      fInfo = new G__MethodInfo(*orig.fInfo);
meta/src/TFunction.cxx:         fInfo = new G__MethodInfo(*rhs.fInfo);
meta/src/TFunction.cxx:   G__MethodArgInfo arg(*fInfo);
meta/src/TFunction.cxx:   G__InterfaceMethod pfunc = fInfo->InterfaceMethod();
meta/src/TFunction.cxx:      struct G__bytecodefunc *bytecode = fInfo->GetBytecode();
meta/src/TFunction.cxx:      if(bytecode) pfunc = (G__InterfaceMethod)G__exec_bytecode;
meta/src/TFunction.cxx:         pfunc = (G__InterfaceMethod)NULL;
meta/src/TGlobal.cxx:TGlobal::TGlobal(G__DataMemberInfo *info) : TDictionary()
meta/src/TMethodArg.cxx:TMethodArg::TMethodArg(G__MethodArgInfo *info, TFunction *method) : TDictionary()
meta/src/TMethodCall.cxx:   fFunc     = orig.fFunc ? new G__CallFunc(*orig.fFunc) : 0;
meta/src/TMethodCall.cxx:      fFunc     = rhs.fFunc ? new G__CallFunc(*rhs.fFunc) : 0;
meta/src/TMethodCall.cxx:static TClass *R__FindScope(const char *function, UInt_t &pos, G__ClassInfo &cinfo)
meta/src/TMethodCall.cxx:   G__ClassInfo cinfo;
meta/src/TMethodCall.cxx:   G__ClassInfo cinfo;
meta/src/TMethodCall.cxx:      fFunc = new G__CallFunc;
meta/src/TMethodCall.cxx:   G__ClassInfo *scope = 0;
meta/src/TMethodCall.cxx:   G__ClassInfo global;
meta/src/TMethodCall.cxx:   else scope = (G__ClassInfo*)&cinfo;
meta/src/TMethodCall.cxx:   G__ClassInfo cinfo;
meta/src/TMethodCall.cxx:   G__ClassInfo cinfo;
meta/src/TMethodCall.cxx:   G__settemplevel(1);
meta/src/TMethodCall.cxx:      Long_t saveglobalvar = G__getgvp();
meta/src/TMethodCall.cxx:      G__setgvp((Long_t)address);
meta/src/TMethodCall.cxx:      G__setgvp(saveglobalvar);
meta/src/TMethodCall.cxx:   G__settemplevel(-1);
meta/src/TMethodCall.cxx:   G__settemplevel(1);
meta/src/TMethodCall.cxx:   G__settemplevel(-1);
meta/src/TMethodCall.cxx:   G__settemplevel(1);
meta/src/TMethodCall.cxx:   G__settemplevel(-1);
meta/src/TMethodCall.cxx:   G__settemplevel(1);
meta/src/TMethodCall.cxx:   G__settemplevel(-1);
meta/src/TMethodCall.cxx:   G__settemplevel(1);
meta/src/TMethodCall.cxx:   G__settemplevel(-1);
meta/src/TMethodCall.cxx:   G__settemplevel(1);
meta/src/TMethodCall.cxx:   G__settemplevel(-1);
meta/src/TMethodCall.cxx:   G__settemplevel(1);
meta/src/TMethodCall.cxx:   G__settemplevel(-1);
meta/src/TMethodCall.cxx:   G__settemplevel(1);
meta/src/TMethodCall.cxx:   G__settemplevel(-1);
meta/src/TMethodCall.cxx:      G__TypedefInfo type(gInterpreter->TypeName(func->GetReturnTypeName()));
meta/src/TMethodCall.cxx:         G__TypeInfo type(func->GetReturnTypeName());
meta/src/TMethod.cxx:TMethod::TMethod(G__MethodInfo *info, TClass *cl) : TFunction(info)
meta/src/TStreamerElement.cxx:         G__ClassInfo info(sopen);
meta/src/TStreamerElement.cxx:         if (info.IsValid() && info.Property()&G__BIT_ISENUM) {
metautils/src/TClassEdit.cxx:                     G__ClassInfo info(base.c_str());
metautils/src/TClassEdit.cxx:         G__TypedefInfo t;
minuit2/src/TFitterMinuit.cxx:   char *funcname = G__p2f2funcname(fcn);
minuit/src/TMinuit.cxx:   char *funcname = G__p2f2funcname(fcn);
pyroot/src/Adapters.cxx:      G__ClassInfo* clInfo = fClass->GetClassInfo();
pyroot/src/Adapters.cxx:      G__ClassInfo* clInfo = fClass->GetClassInfo();
pyroot/src/Adapters.cxx:   bool b = G__TypeInfo( Name( ROOT::Reflex::Q | ROOT::Reflex::S ).c_str() ).IsValid();
pyroot/src/Adapters.cxx:   return G__TypeInfo( Name( ROOT::Reflex::SCOPED ).c_str() ).IsLoaded();
pyroot/src/ConstructorHolder.cxx:         G__StoreEnv env;
pyroot/src/ConstructorHolder.cxx:         G__stubstoreenv( &env, (void*)address, tagnum );
pyroot/src/ConstructorHolder.cxx:         G__getfunction( temp, &known, G__CALLCONSTRUCTOR );
pyroot/src/ConstructorHolder.cxx:         G__stubrestoreenv( &env );
pyroot/src/Converters.cxx:Bool_t PyROOT::T##name##Converter::SetArg( PyObject* pyobject, TParameter& para, G__CallFunc* func )\
pyroot/src/Converters.cxx:Bool_t PyROOT::TLongConverter::SetArg( PyObject* pyobject, TParameter& para, G__CallFunc* func )
pyroot/src/Converters.cxx:Bool_t PyROOT::TLongRefConverter::SetArg( PyObject* pyobject, TParameter& para, G__CallFunc* func )
pyroot/src/Converters.cxx:Bool_t PyROOT::TIntRefConverter::SetArg( PyObject* pyobject, TParameter& para, G__CallFunc* func )
pyroot/src/Converters.cxx:      G__value v;
pyroot/src/Converters.cxx:Bool_t PyROOT::TBoolConverter::SetArg( PyObject* pyobject, TParameter& para, G__CallFunc* func )
pyroot/src/Converters.cxx:Bool_t PyROOT::TULongConverter::SetArg( PyObject* pyobject, TParameter& para, G__CallFunc* func )
pyroot/src/Converters.cxx:Bool_t PyROOT::TDoubleConverter::SetArg( PyObject* pyobject, TParameter& para, G__CallFunc* func )
pyroot/src/Converters.cxx:Bool_t PyROOT::TDoubleRefConverter::SetArg( PyObject* pyobject, TParameter& para, G__CallFunc* func )
pyroot/src/Converters.cxx:Bool_t PyROOT::TConstDoubleRefConverter::SetArg( PyObject* pyobject, TParameter& para, G__CallFunc* func )
pyroot/src/Converters.cxx:Bool_t PyROOT::TVoidConverter::SetArg( PyObject*, TParameter&, G__CallFunc* )
pyroot/src/Converters.cxx:Bool_t PyROOT::TMacroConverter::SetArg( PyObject*, TParameter&, G__CallFunc* )
pyroot/src/Converters.cxx:   G__DataMemberInfo dmi;
pyroot/src/Converters.cxx:Bool_t PyROOT::TLongLongConverter::SetArg( PyObject* pyobject, TParameter& para, G__CallFunc* func )
pyroot/src/Converters.cxx:Bool_t PyROOT::TULongLongConverter::SetArg( PyObject* pyobject, TParameter& para, G__CallFunc* func )
pyroot/src/Converters.cxx:Bool_t PyROOT::TCStringConverter::SetArg( PyObject* pyobject, TParameter& para, G__CallFunc* func )
pyroot/src/Converters.cxx:      PyObject* pyobject, PyROOT::TParameter& para, G__CallFunc* func, char tc, int size )
pyroot/src/Converters.cxx:Bool_t PyROOT::TVoidArrayConverter::SetArg( PyObject* pyobject, TParameter& para, G__CallFunc* func )
pyroot/src/Converters.cxx:Bool_t PyROOT::T##name##ArrayConverter::SetArg( PyObject* pyobject, TParameter& para, G__CallFunc* func )\
pyroot/src/Converters.cxx:Bool_t PyROOT::TLongLongArrayConverter::SetArg( PyObject* pyobject, TParameter& para, G__CallFunc* func )
pyroot/src/Converters.cxx:Bool_t PyROOT::T##name##Converter::SetArg( PyObject* pyobject, TParameter& para, G__CallFunc* func )\
pyroot/src/Converters.cxx:Bool_t PyROOT::TRootObjectConverter::SetArg( PyObject* pyobject, TParameter& para, G__CallFunc* func )
pyroot/src/Converters.cxx:      G__ClassInfo* clFormalInfo = fClass->GetClassInfo();
pyroot/src/Converters.cxx:      G__ClassInfo* clActualInfo = pyobj->ObjectIsA()->GetClassInfo();
pyroot/src/Converters.cxx:         offset = G__isanybase( clFormalInfo->Tagnum(), clActualInfo->Tagnum(), para.fl );
pyroot/src/Converters.cxx:Bool_t PyROOT::TRootObjectPtrConverter::SetArg( PyObject* pyobject, TParameter& para, G__CallFunc* func )
pyroot/src/Converters.cxx:Bool_t PyROOT::TVoidPtrRefConverter::SetArg( PyObject* pyobject, TParameter& para, G__CallFunc* func )
pyroot/src/Converters.cxx:Bool_t PyROOT::TVoidPtrPtrConverter::SetArg( PyObject* pyobject, TParameter& para, G__CallFunc* func )
pyroot/src/Converters.cxx:Bool_t PyROOT::TPyObjectConverter::SetArg( PyObject* pyobject, TParameter& para, G__CallFunc* func )
pyroot/src/Converters.cxx:   G__TypeInfo ti( fullType.c_str() );
pyroot/src/Converters.cxx:   } else if ( ti.Property() & G__BIT_ISENUM ) {
pyroot/src/Executors.cxx:PyObject* PyROOT::TLongExecutor::Execute( G__CallFunc* func, void* self )
pyroot/src/Executors.cxx:PyObject* PyROOT::TCharExecutor::Execute( G__CallFunc* func, void* self )
pyroot/src/Executors.cxx:PyObject* PyROOT::TIntExecutor::Execute( G__CallFunc* func, void* self )
pyroot/src/Executors.cxx:PyObject* PyROOT::TULongExecutor::Execute( G__CallFunc* func, void* self )
pyroot/src/Executors.cxx:PyObject* PyROOT::TLongLongExecutor::Execute( G__CallFunc* func, void* self )
pyroot/src/Executors.cxx:   return PyLong_FromLongLong( (Long64_t)G__Longlong( func->Execute( self ) ) );
pyroot/src/Executors.cxx:PyObject* PyROOT::TULongLongExecutor::Execute( G__CallFunc* func, void* self )
pyroot/src/Executors.cxx:   return PyLong_FromUnsignedLongLong( (ULong64_t)G__ULonglong( func->Execute( self ) ) );
pyroot/src/Executors.cxx:PyObject* PyROOT::TDoubleExecutor::Execute( G__CallFunc* func, void* self )
pyroot/src/Executors.cxx:PyObject* PyROOT::T##name##RefExecutor::Execute( G__CallFunc* func, void* self )\
pyroot/src/Executors.cxx:      const G__value& result = func->Execute( self );                        \
pyroot/src/Executors.cxx:PyObject* PyROOT::TSTLStringRefExecutor::Execute( G__CallFunc* func, void* self )
pyroot/src/Executors.cxx:PyObject* PyROOT::TVoidExecutor::Execute( G__CallFunc* func, void* self )
pyroot/src/Executors.cxx:PyObject* PyROOT::TCStringExecutor::Execute( G__CallFunc* func, void* self )
pyroot/src/Executors.cxx:PyObject* PyROOT::TVoidArrayExecutor::Execute( G__CallFunc* func, void* self )
pyroot/src/Executors.cxx:PyObject* PyROOT::T##name##ArrayExecutor::Execute( G__CallFunc* func, void* self )\
pyroot/src/Executors.cxx:PyObject* PyROOT::TSTLStringExecutor::Execute( G__CallFunc* func, void* self )
pyroot/src/Executors.cxx:PyObject* PyROOT::TTGlobalExecutor::Execute( G__CallFunc* func, void* self )
pyroot/src/Executors.cxx:PyObject* PyROOT::TRootObjectExecutor::Execute( G__CallFunc* func, void* self )
pyroot/src/Executors.cxx:PyObject* PyROOT::TRootObjectByValueExecutor::Execute( G__CallFunc* func, void* self )
pyroot/src/Executors.cxx:   G__pop_tempobject_nodel();
pyroot/src/Executors.cxx:PyObject* PyROOT::TConstructorExecutor::Execute( G__CallFunc* func, void* klass )
pyroot/src/Executors.cxx:PyObject* PyROOT::TPyObjectExecutor::Execute( G__CallFunc* func, void* self )
pyroot/src/Executors.cxx:   G__TypeInfo ti( fullType.c_str() );
pyroot/src/Executors.cxx:      if ( ti.Property() & G__BIT_ISENUM )
pyroot/src/MethodHolder.cxx:      TempLevelGuard_t() { G__settemplevel( 1 ); }
pyroot/src/MethodHolder.cxx:      ~TempLevelGuard_t() { G__settemplevel( -1 ); }
pyroot/src/MethodHolder.cxx:   G__ClassInfo* GetGlobalNamespaceInfo() {
pyroot/src/MethodHolder.cxx:      static G__ClassInfo gcl;
pyroot/src/MethodHolder.cxx:   fMethodCall = new G__CallFunc();
pyroot/src/MethodHolder.cxx:   G__ClassInfo* gcl = ((TClass*)fClass.Id())->GetClassInfo();
pyroot/src/MethodHolder.cxx:      &fOffset, G__ClassInfo::ExactMatch ) );
pyroot/src/MethodHolder.cxx:   if ( G__get_return( 0 ) > G__RETURN_NORMAL )
pyroot/src/MethodHolder.cxx:      G__security_recover( 0 );    // 0 ensures silence
pyroot/src/MethodHolder.cxx:      G__ClassInfo* cli = ((TClass*)fClass.Id())->GetClassInfo();
pyroot/src/MethodHolder.cxx:      fOffset = objTag == methTag ? 0 : G__isanybase( methTag, objTag, (Long_t)object );
pyroot/src/PropertyProxy.cxx:           ( ! ( ~pyprop->fProperty & ( kIsEnum | G__BIT_ISSTATIC ) ) ) ) {
pyroot/src/PropertyProxy.cxx:      fOwnerIsNamespace = dm->GetClass()->GetClassInfo()->Property() & G__BIT_ISNAMESPACE;
pyroot/src/PropertyProxy.cxx:         offset = G__isanybase( fOwnerTagnum, realTagnum, (Long_t)obj );
pyroot/src/Pythonize.cxx:   int TFNPyCallback( G__value* res, G__CONST char*, struct G__param* libp, int hash )
pyroot/src/Pythonize.cxx:      G__ifunc_table* ifunc = 0;
pyroot/src/Pythonize.cxx:      G__CurrentCall( G__RECMEMFUNCENV, &ifunc, &index );
pyroot/src/Pythonize.cxx:      G__MethodInfo mi; mi.Init((long)ifunc, index, 0);
pyroot/src/Pythonize.cxx:            (double*)G__int(libp->para[0]), 4 );
pyroot/src/Pythonize.cxx:               (double*)G__int(libp->para[1]), ci->second );
pyroot/src/Pythonize.cxx:      G__letdouble( res, 100, d );
pyroot/src/Pythonize.cxx:   int TMinuitPyCallback( G__value* res, G__CONST char*, struct G__param* libp, int hash )
pyroot/src/Pythonize.cxx:      G__ifunc_table* ifunc = 0;
pyroot/src/Pythonize.cxx:      G__CurrentCall( G__RECMEMFUNCENV, &ifunc, &index );
pyroot/src/Pythonize.cxx:      G__MethodInfo mi; mi.Init((long)ifunc, index, 0);
pyroot/src/Pythonize.cxx:            (Int_t*)G__int(libp->para[0]), 1 );
pyroot/src/Pythonize.cxx:         int npar = G__int(libp->para[0]);
pyroot/src/Pythonize.cxx:            (Double_t*)G__int(libp->para[1]), npar );
pyroot/src/Pythonize.cxx:         PyList_SetItem( arg3, 0, PyFloat_FromDouble( G__double(libp->para[2]) ) );
pyroot/src/Pythonize.cxx:            (Double_t*)G__int(libp->para[3]), npar );
pyroot/src/Pythonize.cxx:            arg1, arg2, arg3, arg4, (int)G__int(libp->para[4]) );
pyroot/src/Pythonize.cxx:         *(Double_t*)G__Doubleref(&libp->para[2]) = PyFloat_AsDouble( PyList_GetItem( arg3, 0 ) );
pyroot/src/Pythonize.cxx:      G__MethodInfo Register( void* callback,
pyroot/src/Pythonize.cxx:         G__ClassInfo gcl;                   // global namespace
pyroot/src/Pythonize.cxx:         G__MethodInfo m = gcl.GetMethod( name, signature, &offset );
pyroot/src/Pythonize.cxx:            G__ifunc_table_internal* ifunc = G__get_ifunc_internal(m.ifunc());
pyroot/src/Pythonize.cxx:         G__MethodInfo m = Register( (void*)TFNPyCallback, name, "double*, double*", "D" );
pyroot/src/Pythonize.cxx:         G__MethodInfo m = Register( (void*)TMinuitPyCallback, name,
pyroot/src/RootWrapper.cxx:      G__DataMemberInfo dmi = klass->GetClassInfo()->GetDataMember( mb->GetName(), &offset );
pyroot/src/RootWrapper.cxx:   if ( ! (bool)klass && G__defined_templateclass( const_cast< char* >( lookup.c_str() ) ) ) {
pyroot/src/RootWrapper.cxx:   if ( ! (bool)klass && G__defined_tagname( lookup.c_str(), 2 ) != -1 ) {
pyroot/src/RootWrapper.cxx:   G__DataMemberInfo dt;
pyroot/src/RootWrapper.cxx:         TGlobal gbl = TGlobal( new G__DataMemberInfo( dt ) );
pyroot/src/RootWrapper.cxx:   G__MethodInfo mt;
pyroot/src/RootWrapper.cxx:         TFunction* func = new TFunction( new G__MethodInfo( mt ) );
pyroot/src/RootWrapper.cxx:            offset = G__isanybase(klass->GetClassInfo()->Tagnum(), clActual->GetClassInfo()->Tagnum(), (Long_t)address );
pyroot/src/RootWrapper.cxx:        ( G__TypeInfo( gbl->GetTypeName() ).Property() & G__BIT_ISENUM ) ) {
pyroot/src/TPyClassGenerator.cxx:   int PyCtorCallback( G__value* res, G__CONST char*, struct G__param* libp, int hash )
pyroot/src/TPyClassGenerator.cxx:      G__linked_taginfo pti;
pyroot/src/TPyClassGenerator.cxx:      res->tagnum = G__get_linked_tagnum( &pti );
pyroot/src/TPyClassGenerator.cxx:   int PyMemFuncCallback( G__value* res, G__CONST char*, struct G__param* libp, int hash )
pyroot/src/TPyClassGenerator.cxx:      PyObject* self = (PyObject*)G__getstructoffset();
pyroot/src/TPyClassGenerator.cxx:            arg = PyFloat_FromDouble( G__Mdouble(libp->para[i]) );
pyroot/src/TPyClassGenerator.cxx:            arg = PyFloat_FromDouble( (double)G__Mfloat(libp->para[i]) );
pyroot/src/TPyClassGenerator.cxx:            arg = PyLong_FromLong( G__Mlong(libp->para[i]) );
pyroot/src/TPyClassGenerator.cxx:            arg = PyLong_FromUnsignedLong( G__Mulong(libp->para[i] ) );
pyroot/src/TPyClassGenerator.cxx:            arg = PyInt_FromLong( (Long_t)G__Mint(libp->para[i]) );
pyroot/src/TPyClassGenerator.cxx:            arg = PyInt_FromLong( (Long_t)G__Muint(libp->para[i]) );
pyroot/src/TPyClassGenerator.cxx:            arg = PyInt_FromLong( (Long_t)G__Mshort(libp->para[i]) );
pyroot/src/TPyClassGenerator.cxx:            arg = PyInt_FromLong( (Long_t)G__Mushort(libp->para[i]) );
pyroot/src/TPyClassGenerator.cxx:            char cc[2]; cc[0] = G__Mchar(libp->para[i]); cc[1] = '\0';
pyroot/src/TPyClassGenerator.cxx:            arg = PyString_FromString( (char*)G__Mlong(libp->para[i]) );
pyroot/src/TPyClassGenerator.cxx:   G__linked_taginfo pti;
pyroot/src/TPyClassGenerator.cxx:   G__add_compiledheader( (clName+".h").c_str() );
pyroot/src/TPyClassGenerator.cxx:   int tagnum = G__get_linked_tagnum( &pti );
pyroot/src/TPyClassGenerator.cxx:   G__tagtable_setup(
pyroot/src/TPyClassGenerator.cxx:      tagnum, sizeof(PyObject), G__CPPLINK, 0x00020000, "", 0, 0 );
pyroot/src/TPyClassGenerator.cxx:   G__ClassInfo gcl( tagnum );
pyroot/src/TPyROOTApplication.cxx:   G__set_errmsgcallback( (void*)&Utility::ErrMsgCallback );
pyroot/src/Utility.cxx:   G__TypeInfo ti( name.c_str() );
pyroot/src/Utility.cxx:   if ( ti.Property() & G__BIT_ISENUM )
pyroot/src/Utility.cxx:   char* errFile = G__stripfilename( G__get_ifile()->name );
pyroot/src/Utility.cxx:   int errLine = G__get_ifile()->line_number;
pyroot/src/Utility.cxx:Bool_t PyROOT::Utility::InstallMethod( G__ClassInfo* scope, PyObject* callback, 
pyroot/src/Utility.cxx:   G__linked_taginfo pti;
pyroot/src/Utility.cxx:   int tagnum = G__get_linked_tagnum( &pti );
rint/src/TRint.cxx:   if (!G__get_security_error())
rint/src/TRint.cxx:      G__genericerror("\n *** Break *** keyboard interrupt");
rint/src/TTabCom.cxx:      G__display_class(fout, (char*)"", 0, 0);
rint/src/TTabCom.cxx:      G__DataMemberInfo *a;
rint/src/TTabCom.cxx:      G__DataMemberInfo t;
rint/src/TTabCom.cxx:         a = new G__DataMemberInfo();
rint/src/TTabCom.cxx:      G__MethodInfo *a;
rint/src/TTabCom.cxx:      G__MethodInfo t;
rint/src/TTabCom.cxx:         a = new G__MethodInfo();
rint/src/TTabCom.cxx:   G__display_includepath(fout);
roofitcore/src/RooGenCategory.cxx:  _userFuncName = G__p2f2funcname(userFunc);
ruby/src/drr.cxx:void drr_map_args2(VALUE inargs, char *cproto, G__CallFunc *f, int offset=1)
ruby/src/drr.cxx:    G__CallFunc func;
ruby/src/drr.cxx:    G__ClassInfo klass(classname);
ruby/src/drr.cxx:    G__MethodInfo minfo(klass.GetMethod(classname, cproto, &offset)); 
ruby/src/drr.cxx:    G__CallFunc *func = new G__CallFunc();
ruby/src/drr.cxx:    G__ClassInfo *klass = new G__ClassInfo (classname);
ruby/src/drr.cxx:    G__MethodInfo *minfo = new G__MethodInfo(klass->GetMethod(methname, cproto, &offset)); 
ruby/src/drr.cxx:    G__CallFunc *func = NULL; 
table/src/TTable.cxx:   switch(G__loadfile((Char_t *)exprFileName)) {
table/src/TTable.cxx:         G__unloadfile((Char_t *)exprFileName);
table/src/TTable.cxx:   G__ClassInfo globals;
table/src/TTable.cxx:   G__MethodInfo func = globals.GetMethod(funcName,argtypes,&offset);
table/src/TTable.cxx:   struct G__bytecodefunc *pbc = func.GetBytecode();
table/src/TTable.cxx:      G__unloadfile((Char_t *)exprFileName);
table/src/TTable.cxx:   G__CallFunc callfunc;
table/src/TTable.cxx:   G__unloadfile((Char_t *)exprFileName);
thread/src/TThread.cxx:   G__set_alloclockfunc(CINT_alloc_lock);
thread/src/TThread.cxx:   G__set_allocunlockfunc(CINT_alloc_unlock);
tree/src/TSelectorCint.cxx:void TSelectorCint::SetFuncProto(G__CallFunc *cf, G__ClassInfo* cl,
tree/src/TSelectorCint.cxx:void TSelectorCint::Build(TSelector *iselector, G__ClassInfo *cl, Bool_t isowner)
tree/src/TSelectorCint.cxx:   fClass        = new G__ClassInfo(*cl);
tree/src/TSelectorCint.cxx:   fFuncVersion  = new G__CallFunc();
tree/src/TSelectorCint.cxx:   fFuncInit     = new G__CallFunc();
tree/src/TSelectorCint.cxx:   fFuncBegin    = new G__CallFunc();
tree/src/TSelectorCint.cxx:   fFuncSlBegin  = new G__CallFunc();
tree/src/TSelectorCint.cxx:   fFuncNotif    = new G__CallFunc();
tree/src/TSelectorCint.cxx:   fFuncSlTerm   = new G__CallFunc();
tree/src/TSelectorCint.cxx:   fFuncTerm     = new G__CallFunc();
tree/src/TSelectorCint.cxx:   fFuncCut      = new G__CallFunc();
tree/src/TSelectorCint.cxx:   fFuncFill     = new G__CallFunc();
tree/src/TSelectorCint.cxx:   fFuncProc     = new G__CallFunc();
tree/src/TSelectorCint.cxx:   fFuncOption   = new G__CallFunc();
tree/src/TSelectorCint.cxx:   fFuncObj      = new G__CallFunc();
tree/src/TSelectorCint.cxx:   fFuncInp      = new G__CallFunc();
tree/src/TSelectorCint.cxx:   fFuncOut      = new G__CallFunc();
tree/src/TSelectorCint.cxx:   fFuncGetAbort = new G__CallFunc();
tree/src/TSelectorCint.cxx:   fFuncGetStat  = new G__CallFunc();
tree/src/TSelector.cxx:   G__ClassInfo cl;
tree/src/TTree.cxx:      G__ClassInfo* classinfo = clones->GetClass()->GetClassInfo();
tree/src/TTree.cxx:            G__ClassInfo* classinfo = inklass->GetClassInfo();
utils/src/rootcint.cxx:   void  G__setothermain(int othermain);
utils/src/rootcint.cxx:   void  G__setglobalcomp(int globalcomp);
utils/src/rootcint.cxx:   int   G__main(int argc, char **argv);
utils/src/rootcint.cxx:   void  G__exit(int rtn);
utils/src/rootcint.cxx:   struct G__includepath *G__getipathentry();
utils/src/rootcint.cxx:const char *autoldtmpl = "G__auto%dLinkDef.h";
utils/src/rootcint.cxx:G__ShadowMaker *shadowMaker=0;
utils/src/rootcint.cxx:                           G__set_class_autoloading_table(buffer,""); // We never load namespaces on their own.
utils/src/rootcint.cxx:            G__set_class_autoloading_table(buffer,(char*)line.c_str());
utils/src/rootcint.cxx:   typedef void G__parse_hook_t ();
utils/src/rootcint.cxx:   G__parse_hook_t* G__set_beforeparse_hook (G__parse_hook_t* hook);
utils/src/rootcint.cxx:   G__set_class_autoloading_table("ROOT","libCore.so");
utils/src/rootcint.cxx:   G__set_class_autoloading_callback(&AutoLoadCallback);
utils/src/rootcint.cxx:bool CheckInputOperator(G__ClassInfo &cl)
utils/src/rootcint.cxx:   G__ClassInfo gcl;
utils/src/rootcint.cxx:   G__MethodInfo methodinfo = gcl.GetMethod("operator>>",proto,&offset);
utils/src/rootcint.cxx:   G__MethodArgInfo args( methodinfo );
utils/src/rootcint.cxx:bool CheckClassDef(G__ClassInfo &cl)
utils/src/rootcint.cxx:   G__MethodInfo methodinfo = cl.GetMethod(name,proto,&offset);
utils/src/rootcint.cxx:   bool parentHasClassDef = methodinfo.IsValid() && (methodinfo.Property() & G__BIT_ISPUBLIC);
utils/src/rootcint.cxx:int GetClassVersion(G__ClassInfo &cl)
utils/src/rootcint.cxx:   int version = (int)G__int(G__calc(funcname.c_str()));
utils/src/rootcint.cxx:string GetNonConstMemberName(G__DataMemberInfo &m, const string &prefix = "")
utils/src/rootcint.cxx:      ret += G__ShadowMaker::GetNonConstTypeName(m);
utils/src/rootcint.cxx:bool NeedShadowClass(G__ClassInfo& cl)
utils/src/rootcint.cxx:   if (G__ShadowMaker::IsStdPair(cl)) return true;
utils/src/rootcint.cxx:   if (G__ShadowMaker::IsSTLCont(cl.Name())) return false;
utils/src/rootcint.cxx:bool NeedTypedefShadowClass(G__ClassInfo& cl)
utils/src/rootcint.cxx:int NeedTemplateKeyword(G__ClassInfo &cl)
utils/src/rootcint.cxx:      struct G__Definedtemplateclass *templ = G__defined_templateclass(templatename);
utils/src/rootcint.cxx:         G__IntList * ilist = templ->instantiatedtagnum;
utils/src/rootcint.cxx:bool HasCustomOperatorNew(G__ClassInfo& cl);
utils/src/rootcint.cxx:bool HasCustomOperatorNewPlacement(G__ClassInfo& cl);
utils/src/rootcint.cxx:bool HasCustomOperatorNewArrayPlacement(G__ClassInfo& cl);
utils/src/rootcint.cxx:bool HasDefaultConstructor(G__ClassInfo& cl,string *args=0);
utils/src/rootcint.cxx:bool NeedConstructor(G__ClassInfo& cl);
utils/src/rootcint.cxx:bool HasCustomOperatorNew(G__ClassInfo& cl)
utils/src/rootcint.cxx:   G__ClassInfo gcl;
utils/src/rootcint.cxx:   G__MethodInfo methodinfo = gcl.GetMethod(name,proto,&offset);
utils/src/rootcint.cxx:bool HasCustomOperatorNewPlacement(G__ClassInfo& cl)
utils/src/rootcint.cxx:   G__ClassInfo gcl;
utils/src/rootcint.cxx:   G__MethodInfo methodinfo = gcl.GetMethod(name,proto,&offset);
utils/src/rootcint.cxx:   G__MethodInfo methodinfoPlacement = gcl.GetMethod(name,protoPlacement,&offset);
utils/src/rootcint.cxx:      G__ClassInfo clNew(methodinfo.GetDefiningScopeTagnum());
utils/src/rootcint.cxx:      G__ClassInfo clPlacement(methodinfoPlacement.GetDefiningScopeTagnum());
utils/src/rootcint.cxx:bool HasCustomOperatorNewArrayPlacement(G__ClassInfo& cl)
utils/src/rootcint.cxx:   G__ClassInfo gcl;
utils/src/rootcint.cxx:   G__MethodInfo methodinfo = gcl.GetMethod(name,proto,&offset);
utils/src/rootcint.cxx:   G__MethodInfo methodinfoPlacement = gcl.GetMethod(name,protoPlacement,&offset);
utils/src/rootcint.cxx:      G__ClassInfo clNew(methodinfo.GetDefiningScopeTagnum());
utils/src/rootcint.cxx:      G__ClassInfo clPlacement(methodinfoPlacement.GetDefiningScopeTagnum());
utils/src/rootcint.cxx:bool CheckConstructor(G__MethodInfo &methodinfo, int argRequested)
utils/src/rootcint.cxx:      && (methodinfo.Property() & G__BIT_ISPUBLIC)) {
utils/src/rootcint.cxx:            G__MethodArgInfo args( methodinfo );
utils/src/rootcint.cxx:bool HasDefaultConstructor(G__ClassInfo& cl, string *arg)
utils/src/rootcint.cxx:      G__MethodInfo methodinfo  = cl.GetMethod(cl.TmpltName(),proto.c_str(),&offset,G__ClassInfo::ExactMatch,G__ClassInfo::InThisScope);
utils/src/rootcint.cxx:      G__MethodInfo tmethodinfo = cl.GetMethod(cl.Name(),     proto.c_str(),&offset,G__ClassInfo::ExactMatch,G__ClassInfo::InThisScope);
utils/src/rootcint.cxx:         if  (methodinfo.IsValid() && !(methodinfo.Property() & G__BIT_ISPUBLIC) ) {
utils/src/rootcint.cxx:bool NeedConstructor(G__ClassInfo& cl)
utils/src/rootcint.cxx:bool CheckConstructor(G__ClassInfo& cl)
utils/src/rootcint.cxx:bool NeedDestructor(G__ClassInfo& cl)
utils/src/rootcint.cxx:   G__MethodInfo methodinfo = cl.GetMethod(name.c_str(),proto,&offset);
utils/src/rootcint.cxx:   if (methodinfo.IsValid() && !(methodinfo.Property() & G__BIT_ISPUBLIC) ) {
utils/src/rootcint.cxx:bool IsTemplateFloat16(G__ClassInfo &cl)
utils/src/rootcint.cxx:   static G__TypeInfo ti;
utils/src/rootcint.cxx:               G__ClassInfo subcl(current);
utils/src/rootcint.cxx:               G__ClassInfo subcl(current);
utils/src/rootcint.cxx:bool IsTemplateDouble32(G__ClassInfo &cl)
utils/src/rootcint.cxx:   static G__TypeInfo ti;
utils/src/rootcint.cxx:               G__ClassInfo subcl(current);
utils/src/rootcint.cxx:               G__ClassInfo subcl(current);
utils/src/rootcint.cxx:int IsSTLContainer(G__DataMemberInfo &m)
utils/src/rootcint.cxx:int IsSTLContainer(G__BaseClassInfo &m)
utils/src/rootcint.cxx:int IsStreamable(G__DataMemberInfo &m)
utils/src/rootcint.cxx:G__TypeInfo &TemplateArg(G__DataMemberInfo &m, int count = 0)
utils/src/rootcint.cxx:   static G__TypeInfo ti;
utils/src/rootcint.cxx:G__TypeInfo &TemplateArg(G__BaseClassInfo &m, int count = 0)
utils/src/rootcint.cxx:   static G__TypeInfo ti;
utils/src/rootcint.cxx:void WriteAuxFunctions(G__ClassInfo &cl)
utils/src/rootcint.cxx:   string mappedname = G__map_cpp_name((char*)classname.c_str());
utils/src/rootcint.cxx:int ElementStreamer(G__TypeInfo &ti, const char *R__t,int rwmode,const char *tcl=0)
utils/src/rootcint.cxx:int STLContainerStreamer(G__DataMemberInfo &m, int rwmode)
utils/src/rootcint.cxx:   G__TypeInfo &ti = TemplateArg(m);
utils/src/rootcint.cxx:      G__TypeInfo &ti = TemplateArg(m,1);
utils/src/rootcint.cxx:   if (m.Property() & G__BIT_ISPOINTER) pa+=2;
utils/src/rootcint.cxx:int STLStringStreamer(G__DataMemberInfo &m, int rwmode)
utils/src/rootcint.cxx:int STLBaseStreamer(G__BaseClassInfo &m, int rwmode)
utils/src/rootcint.cxx:int PointerToPointer(G__DataMemberInfo &m)
utils/src/rootcint.cxx:void WriteInputOperator(G__ClassInfo &cl)
utils/src/rootcint.cxx:   G__ClassInfo space = cl.EnclosingSpace();
utils/src/rootcint.cxx:   if (space.Property() & G__BIT_ISNAMESPACE)
utils/src/rootcint.cxx:void WriteClassFunctions(G__ClassInfo &cl, int /*tmplt*/ = 0)
utils/src/rootcint.cxx:   G__ClassInfo ns = cl.EnclosingSpace();
utils/src/rootcint.cxx:      G__ShadowMaker nestTempShadowMaker(*dictSrcOut, "");
utils/src/rootcint.cxx:void WriteClassInit(G__ClassInfo &cl)
utils/src/rootcint.cxx:   string mappedname = G__map_cpp_name((char*)classname.c_str());
utils/src/rootcint.cxx:      if (G__ShadowMaker::IsStdPair(cl)) {
utils/src/rootcint.cxx:      G__ClassInfo gcl;
utils/src/rootcint.cxx:      G__MethodInfo methodinfo = gcl.GetMethod(versionFunc,proto,&offset);
utils/src/rootcint.cxx:      //fprintf(stderr,"DEBUG: %s has value %d\n",classname.c_str(),(int)G__int(G__calc(temporary)));
utils/src/rootcint.cxx:void WriteNamespaceInit(G__ClassInfo &cl)
utils/src/rootcint.cxx:   if (! (cl.Property() & G__BIT_ISNAMESPACE) ) return;
utils/src/rootcint.cxx:   string mappedname = G__map_cpp_name((char*)classname.c_str());
utils/src/rootcint.cxx:      G__ClassInfo gcl;
utils/src/rootcint.cxx:      G__MethodInfo methodinfo = gcl.GetMethod(versionFunc,proto,&offset);
utils/src/rootcint.cxx:const char *GrabIndex(G__DataMemberInfo &member, int printError)
utils/src/rootcint.cxx:         case G__DataMemberInfo::NOT_INT:
utils/src/rootcint.cxx:         case G__DataMemberInfo::NOT_DEF:
utils/src/rootcint.cxx:         case G__DataMemberInfo::IS_PRIVATE:
utils/src/rootcint.cxx:         case G__DataMemberInfo::UNKNOWN:
utils/src/rootcint.cxx:void WriteStreamer(G__ClassInfo &cl)
utils/src/rootcint.cxx:   G__ClassInfo ns = cl.EnclosingSpace();
utils/src/rootcint.cxx:      G__ShadowMaker nestTempShadowMaker(*dictSrcOut, "");
utils/src/rootcint.cxx:      G__BaseClassInfo b(cl);
utils/src/rootcint.cxx:   //if ((cl.RootFlag() & G__USEBYTECOUNT)) ubc = 1;
utils/src/rootcint.cxx:      G__BaseClassInfo b(cl);
utils/src/rootcint.cxx:      G__DataMemberInfo m(cl);
utils/src/rootcint.cxx:         //  - the member G__virtualinfo inserted by the CINT RTTI system
utils/src/rootcint.cxx:         if (!(m.Property() & G__BIT_ISSTATIC) &&
utils/src/rootcint.cxx:             strcmp(m.Name(), "G__virtualinfo")) {
utils/src/rootcint.cxx:            if (((m.Type())->Property() & G__BIT_ISFUNDAMENTAL) ||
utils/src/rootcint.cxx:                ((m.Type())->Property() & G__BIT_ISENUM)) {
utils/src/rootcint.cxx:               if (m.Property() & G__BIT_ISARRAY &&
utils/src/rootcint.cxx:                   m.Property() & G__BIT_ISPOINTER) {
utils/src/rootcint.cxx:               } else if (m.Property() & G__BIT_ISPOINTER) {
utils/src/rootcint.cxx:               } else if (m.Property() & G__BIT_ISARRAY) {
utils/src/rootcint.cxx:                        if ((m.Type())->Property() & G__BIT_ISENUM)
utils/src/rootcint.cxx:                        if ((m.Type())->Property() & G__BIT_ISENUM)
utils/src/rootcint.cxx:                        if ((m.Type())->Property() & G__BIT_ISENUM)
utils/src/rootcint.cxx:                        if ((m.Type())->Property() & G__BIT_ISENUM)
utils/src/rootcint.cxx:               } else if ((m.Type())->Property() & G__BIT_ISENUM) {
utils/src/rootcint.cxx:               if (m.Property() & G__BIT_ISARRAY &&
utils/src/rootcint.cxx:                   m.Property() & G__BIT_ISPOINTER) {
utils/src/rootcint.cxx:               } else if (m.Property() & G__BIT_ISPOINTER) {
utils/src/rootcint.cxx:               } else if (m.Property() & G__BIT_ISARRAY) {
utils/src/rootcint.cxx:void WriteAutoStreamer(G__ClassInfo &cl)
utils/src/rootcint.cxx:   G__BaseClassInfo base(cl);
utils/src/rootcint.cxx:   G__ClassInfo ns = cl.EnclosingSpace();
utils/src/rootcint.cxx:      G__ShadowMaker nestTempShadowMaker(*dictSrcOut, "");
utils/src/rootcint.cxx:void WriteStreamerBases(G__ClassInfo &cl)
utils/src/rootcint.cxx:   G__BaseClassInfo br(cl);
utils/src/rootcint.cxx:   G__BaseClassInfo bw(cl);
utils/src/rootcint.cxx:void WritePointersSTL(G__ClassInfo &cl)
utils/src/rootcint.cxx:   char a[G__LONGLINE];
utils/src/rootcint.cxx:   char clName[G__LONGLINE];
utils/src/rootcint.cxx:   strcpy(clName, G__map_cpp_name((char *)cl.Fullname()));
utils/src/rootcint.cxx:   if (version < 0 && !(cl.RootFlag() & G__USEBYTECOUNT) ) return;
utils/src/rootcint.cxx:   G__BaseClassInfo base(cl);
utils/src/rootcint.cxx:   G__DataMemberInfo m(cl);
utils/src/rootcint.cxx:      if ((m.Property() & G__BIT_ISSTATIC)) continue;
utils/src/rootcint.cxx:      if (m.Property() & G__BIT_ISPOINTER) {
utils/src/rootcint.cxx:      string mTypeName = G__ShadowMaker::GetNonConstTypeName(m);
utils/src/rootcint.cxx:      if (m.Property() & G__BIT_ISARRAY) {
utils/src/rootcint.cxx:         if (m.Property() & G__BIT_ISPOINTER) {
utils/src/rootcint.cxx:         if (m.Property() & G__BIT_ISARRAY) {
utils/src/rootcint.cxx:            if (m.Property() & G__BIT_ISPOINTER) {
utils/src/rootcint.cxx:            if (m.Property() & G__BIT_ISPOINTER) {
utils/src/rootcint.cxx:         if (m.Property() & G__BIT_ISARRAY) {
utils/src/rootcint.cxx:            if (m.Property() & G__BIT_ISPOINTER) {
utils/src/rootcint.cxx:            if (m.Property() & G__BIT_ISPOINTER) {
utils/src/rootcint.cxx:void WriteBodyShowMembers(G__ClassInfo& cl, bool outside)
utils/src/rootcint.cxx:   G__DataMemberInfo m(cl);
utils/src/rootcint.cxx:   char clName[G__LONGLINE];
utils/src/rootcint.cxx:   strcpy(clName,G__map_cpp_name((char *)cl.Fullname()));
utils/src/rootcint.cxx:   if (version < 0 && !(cl.RootFlag() & G__USEBYTECOUNT) ) clflag = 0;
utils/src/rootcint.cxx:      //  - the member G__virtualinfo inserted by the CINT RTTI system
utils/src/rootcint.cxx:      if (!(m.Property() & G__BIT_ISSTATIC) &&
utils/src/rootcint.cxx:          strcmp(m.Name(), "G__virtualinfo")) {
utils/src/rootcint.cxx:         if (((m.Type())->Property() & G__BIT_ISFUNDAMENTAL) ||
utils/src/rootcint.cxx:             ((m.Type())->Property() & G__BIT_ISENUM)) {
utils/src/rootcint.cxx:            if (m.Property() & G__BIT_ISARRAY &&
utils/src/rootcint.cxx:                m.Property() & G__BIT_ISPOINTER) {
utils/src/rootcint.cxx:            } else if (m.Property() & G__BIT_ISPOINTER) {
utils/src/rootcint.cxx:            } else if (m.Property() & G__BIT_ISARRAY) {
utils/src/rootcint.cxx:            if (m.Property() & G__BIT_ISARRAY &&
utils/src/rootcint.cxx:                m.Property() & G__BIT_ISPOINTER) {
utils/src/rootcint.cxx:            } else if (m.Property() & G__BIT_ISPOINTER) {
utils/src/rootcint.cxx:            } else if (m.Property() & G__BIT_ISARRAY) {
utils/src/rootcint.cxx:            } else if (m.Property() & G__BIT_ISREFERENCE) {
utils/src/rootcint.cxx:                  char compareName[G__LONGLINE];
utils/src/rootcint.cxx:   G__BaseClassInfo b(cl);
utils/src/rootcint.cxx:void WriteShowMembers(G__ClassInfo &cl, bool outside = false)
utils/src/rootcint.cxx:   string mappedname = G__map_cpp_name((char*)classname.c_str());
utils/src/rootcint.cxx:      G__ClassInfo ns = cl.EnclosingSpace();
utils/src/rootcint.cxx:         G__ShadowMaker nestTempShadowMaker(*dictSrcOut, "");
utils/src/rootcint.cxx:         string mappedname = G__map_cpp_name((char*)classname.c_str());
utils/src/rootcint.cxx:void WriteClassCode(G__ClassInfo &cl, bool force = false)
utils/src/rootcint.cxx:   if ((cl.Property() & (G__BIT_ISCLASS|G__BIT_ISSTRUCT)) && (force || cl.Linkage() == G__CPPLINK) ) {
utils/src/rootcint.cxx:         if (!(cl.RootFlag() & G__NOSTREAMER)) {
utils/src/rootcint.cxx:            if ((cl.RootFlag() & G__USEBYTECOUNT /*G__AUTOSTREAMER*/)) {
utils/src/rootcint.cxx:         if (cl.RootFlag() & G__USEBYTECOUNT) WritePointersSTL(cl);
utils/src/rootcint.cxx:   // Can be only called after G__main(). Return pointer to static
utils/src/rootcint.cxx:   struct G__includepath *ipath = G__getipathentry();
utils/src/rootcint.cxx:   //   G__add_compiledheader("bundlename");
utils/src/rootcint.cxx:   sprintf(checkline, "  G__add_compiledheader(\"%s\");", esc_bundlename);
utils/src/rootcint.cxx:                  fprintf(tmpdict, "  G__add_compiledheader(\"%s\");\n", s);
utils/src/rootcint.cxx:         argvv[argcc++] = "-DG__NOCINTDLL";
utils/src/rootcint.cxx:   G__ShadowMaker::VetoShadow(); // we create them ourselves
utils/src/rootcint.cxx:   G__setothermain(2);
utils/src/rootcint.cxx:   G__set_ioctortype_handler( (int (*)(const char*))AddConstructorType );
utils/src/rootcint.cxx:   if (gLiblistPrefix.length()) G__set_beforeparse_hook (EnableAutoLoading);
utils/src/rootcint.cxx:   if (G__main(argcc, argvv) < 0) {
utils/src/rootcint.cxx:   G__setglobalcomp(0);  // G__NOLINK
utils/src/rootcint.cxx:            gccxml_rootcint_call+=" -DG__NOCINTDLL";
utils/src/rootcint.cxx:       << "#ifndef G__ROOT" << std::endl
utils/src/rootcint.cxx:       << "#define G__ROOT" << std::endl
utils/src/rootcint.cxx:   G__ShadowMaker myShadowMaker((*dictSrcOut), shadowNSName, NeedShadowClass,
utils/src/rootcint.cxx:   G__ShadowMaker::VetoShadow(false);
utils/src/rootcint.cxx:   G__ClassInfo cl;
utils/src/rootcint.cxx:      if (cl.Linkage() == G__CPPLINK && !cl.IsLoaded()) {
utils/src/rootcint.cxx:      if ((cl.Property() & (G__BIT_ISCLASS|G__BIT_ISSTRUCT)) && cl.Linkage() == G__CPPLINK) {
utils/src/rootcint.cxx:      } else if (((cl.Property() & (G__BIT_ISNAMESPACE)) && cl.Linkage() == G__CPPLINK)) {
utils/src/rootcint.cxx:      if ((cl.Property() & (G__BIT_ISCLASS|G__BIT_ISSTRUCT)) && cl.Linkage() == G__CPPLINK) {
utils/src/rootcint.cxx:            if (!(cl.RootFlag() & G__NOINPUTOPERATOR)) {
utils/src/rootcint.cxx:      if ((cl.Property() & (G__BIT_ISCLASS|G__BIT_ISSTRUCT)) && cl.Linkage() == G__CPPLINK) {
utils/src/rootcint.cxx:         // Create G__ClassInfo object for this class and process. Be
utils/src/rootcint.cxx:                  case '+': extraRootflag |= G__USEBYTECOUNT; break;
utils/src/rootcint.cxx:                  case '!': extraRootflag |= G__NOINPUTOPERATOR; break;
utils/src/rootcint.cxx:                  case '-': extraRootflag |= G__NOSTREAMER; break;
utils/src/rootcint.cxx:            if ( extraRootflag & (G__USEBYTECOUNT | G__NOSTREAMER) ) {
utils/src/rootcint.cxx:               extraRootflag &= ~G__NOSTREAMER;
utils/src/rootcint.cxx:         G__ClassInfo cl(request);
utils/src/rootcint.cxx:         // CINT's G__ClassInfo.
utils/src/rootcint.cxx:            if ((cl.Property() & (G__BIT_ISCLASS|G__BIT_ISSTRUCT)) && cl.Linkage() != G__CPPLINK) {
utils/src/rootcint.cxx:               if (G__ShadowMaker::IsSTLCont(cl.Name()) == 0 ) {
utils/src/rootcint.cxx:                     fprintf(fpd, "#define G__DICTIONARY gccxml\n");
utils/src/rootcint.cxx:                     fprintf(fpd, "#define G__DICTIONARY reflex\n");
utils/src/rootcint.cxx:   G__setglobalcomp(-1);  // G__CPPLINK
utils/src/rootcint.cxx:   G__exit(0);
utils/src/RStl.cxx:void WriteClassInit(G__ClassInfo &cl);
utils/src/RStl.cxx:void WriteAuxFunctions(G__ClassInfo &cl);
utils/src/RStl.cxx:int ElementStreamer(G__TypeInfo &ti,const char *R__t,int rwmode,const char *tcl=0);
utils/src/RStl.cxx:   G__ClassInfo cl(TClassEdit::ShortType(stlclassname.c_str(),
utils/src/RStl.cxx:   G__ClassInfo cl(classname.c_str());
utils/src/RStl.cxx:   G__ClassInfo cl;
utils/src/RStl.cxx:void ROOT::RStl::WriteStreamer(FILE *file, G__ClassInfo &stlcl)
utils/src/RStl.cxx:   streamerName += G__map_cpp_name((char *)shortTypeName.c_str());
utils/src/RStl.cxx:   string typedefName = G__map_cpp_name((char *)shortTypeName.c_str());
utils/src/RStl.cxx:   G__TypeInfo firstType( splitName[1].c_str());
utils/src/RStl.cxx:   G__TypeInfo secondType;
utils/src/RStl.cxx:   G__ClassInfo cl;
winnt/src/TWinNTSystem.cxx:   extern int G__get_security_error();
winnt/src/TWinNTSystem.cxx:   extern int G__genericerror(const char* msg);
winnt/src/TWinNTSystem.cxx:            if (!G__get_security_error()) {
winnt/src/TWinNTSystem.cxx:               G__genericerror("\n *** Break *** keyboard interrupt");


===========================
We don't care about cintex anymore (or do we need to?):

cintex/src/CINTClassBuilder.cxx:      fTaginfo = new G__linked_taginfo;
cintex/src/CINTClassBuilder.cxx:      fTaginfo->tagnum = G__defined_tagname(fTaginfo->tagname, 2);
cintex/src/CINTClassBuilder.cxx:         G__ClassInfo info(fTaginfo->tagnum);
cintex/src/CINTClassBuilder.cxx:         if (!(info.Property() & (G__BIT_ISSTRUCT | G__BIT_ISCLASS))) {
cintex/src/CINTClassBuilder.cxx:            G__search_tagname(fTaginfo->tagname, cl.IsClass() ? 'c' : 's'); 
cintex/src/CINTClassBuilder.cxx:      fTaginfo->tagnum = G__get_linked_tagnum(fTaginfo);
cintex/src/CINTClassBuilder.cxx:         rootFlag += G__BIT_ISABSTRACT;  // Abstract class
cintex/src/CINTClassBuilder.cxx:      G__tagtable_setup( fTaginfo->tagnum,    // tag number
cintex/src/CINTClassBuilder.cxx:                         G__CPPLINK,          // cpplink
cintex/src/CINTClassBuilder.cxx:                         fSetup_memvar,       // G__setup_memvarMyClass
cintex/src/CINTClassBuilder.cxx:                         fSetup_memfunc);     // G__setup_memfuncMyClass
cintex/src/CINTClassBuilder.cxx:      int autoload = G__set_class_autoloading(0); // To avoid recursive loads
cintex/src/CINTClassBuilder.cxx:      G__set_class_autoloading(autoload);
cintex/src/CINTClassBuilder.cxx:      int autoload = G__set_class_autoloading(0); // To avoid recursive loads
cintex/src/CINTClassBuilder.cxx:      G__set_class_autoloading(autoload);
cintex/src/CINTClassBuilder.cxx:      G__tag_memfunc_setup(fTaginfo->tagnum);
cintex/src/CINTClassBuilder.cxx:      ::G__tag_memfunc_reset();
cintex/src/CINTClassBuilder.cxx:      G__tag_memvar_setup(fTaginfo->tagnum);
cintex/src/CINTClassBuilder.cxx:         G__memvar_setup((void*)0,'l',0,0,-1,-1,-1,4,"G__virtualinfo=",0,0);
cintex/src/CINTClassBuilder.cxx:      G__tag_memvar_reset();
cintex/src/CINTClassBuilder.cxx:      if ( 0 == ::G__getnumbaseclass(fTaginfo->tagnum) )  {     
cintex/src/CINTClassBuilder.cxx:         if ( 0 == ::G__getnumbaseclass(fTaginfo->tagnum) )  {
cintex/src/CINTClassBuilder.cxx:               int b_tagnum = G__search_tagname(b_nam.c_str(), 'a');
cintex/src/CINTClassBuilder.cxx:               long int type = (level == 0) ?  G__ISDIRECTINHERIT : 0;
cintex/src/CINTClassBuilder.cxx:                     type = type | G__ISVIRTUALBASE;
cintex/src/CINTClassBuilder.cxx:               int mod = base.IsPublic() ? G__PUBLIC : ( base.IsPrivate() ? G__PRIVATE : G__PROTECTED );
cintex/src/CINTClassBuilder.cxx:               ::G__inheritance_setup(fTaginfo->tagnum, b_tagnum, offset, mod, type );
cintex/src/CINTEnumBuilder.cxx:         G__ClassInfo cintEnum(name.c_str());
cintex/src/CINTEnumBuilder.cxx:            G__linked_taginfo taginfo;
cintex/src/CINTEnumBuilder.cxx:            G__get_linked_tagnum(&taginfo);
cintex/src/CINTEnumBuilder.cxx:            ::G__tagtable_setup( tagnum, sizeof(int), -1, 0,(char*)NULL, NULL, NULL);
cintex/src/CINTEnumBuilder.cxx:            ::G__resetplocal();
cintex/src/CINTEnumBuilder.cxx:            int stagnum = ::G__defined_tagname(sname.c_str(), 2);
cintex/src/CINTEnumBuilder.cxx:            ::G__tag_memvar_setup(stagnum);
cintex/src/CINTEnumBuilder.cxx:               ::G__memvar_setup((void*)G__PVOID, 'p', 0, 0, -1, -1, -1, 1, item.c_str(), 1, (char*)NULL);
cintex/src/CINTEnumBuilder.cxx:               ::G__memvar_setup((void*)G__PVOID, 'i', 0, 1, tagnum, -1, isstatic, 1, item.c_str(), 0, (char*)NULL);
cintex/src/CINTEnumBuilder.cxx:            ::G__resetglobalenv();
cintex/src/CINTEnumBuilder.cxx:            ::G__tag_memvar_reset();
cintex/src/Cintex.cxx:      int autoload = G__set_class_autoloading(0); // To avoid recursive loads
cintex/src/Cintex.cxx:      G__set_class_autoloading(autoload);
cintex/src/Cintex.cxx:         int autoload = G__set_class_autoloading(0); // To avoid recursive loads
cintex/src/Cintex.cxx:         G__set_class_autoloading(autoload);
cintex/src/Cintex.cxx:         int autoload = G__set_class_autoloading(0); // To avoid recursive loads
cintex/src/Cintex.cxx:         G__set_class_autoloading(autoload);
cintex/src/CINTFunctional.cxx:   void StubContext_t::ProcessParam(G__param* libp) {
cintex/src/CINTFunctional.cxx:         case 'd': fParcnv[i].obj.d  = G__double(libp->para[i]);fParam[i] = &fParcnv[i].obj.d; break;
cintex/src/CINTFunctional.cxx:         case 'f': fParcnv[i].obj.fl = (float)G__double(libp->para[i]);fParam[i] = &fParcnv[i].obj.fl; break;
cintex/src/CINTFunctional.cxx:         case 'n': fParcnv[i].obj.ll = G__Longlong(libp->para[i]);fParam[i] = &fParcnv[i].obj.ll; break;
cintex/src/CINTFunctional.cxx:         case 'm': fParcnv[i].obj.ull= G__ULonglong(libp->para[i]);fParam[i] = &fParcnv[i].obj.ull; break;
cintex/src/CINTFunctional.cxx:         case 'q': fParcnv[i].obj.ld = G__Longdouble(libp->para[i]);fParam[i] = &fParcnv[i].obj.ld; break;
cintex/src/CINTFunctional.cxx:         case 'i': fParcnv[i].obj.i  = G__int(libp->para[i]);   fParam[i] = &fParcnv[i].obj.i; break;
cintex/src/CINTFunctional.cxx:   void StubContext_t::ProcessResult(G__value* result, void* obj) { 
cintex/src/CINTFunctional.cxx:      case 'y': G__setnull(result); break;
cintex/src/CINTFunctional.cxx:                                G__value* result,
cintex/src/CINTFunctional.cxx:                                G__CONST char* /*funcname*/,
cintex/src/CINTFunctional.cxx:                                G__param* libp,
cintex/src/CINTFunctional.cxx:         void* r = (*context->fStub)((void*)G__getstructoffset(), context->fParam, context->fStubctx);
cintex/src/CINTFunctional.cxx:         if ( context->fRet_byvalue )  G__store_tempobject(*result);
cintex/src/CINTFunctional.cxx:         G__genericerror(errtxt.c_str());
cintex/src/CINTFunctional.cxx:         G__setnull(result);
cintex/src/CINTFunctional.cxx:         G__genericerror("Exception: Unknown C++ exception");
cintex/src/CINTFunctional.cxx:         G__setnull(result);
cintex/src/CINTFunctional.cxx:                                     G__value* result,
cintex/src/CINTFunctional.cxx:                                     G__CONST char* /*funcname*/,
cintex/src/CINTFunctional.cxx:                                     G__param *libp,
cintex/src/CINTFunctional.cxx:         long nary = G__getaryconstruct();
cintex/src/CINTFunctional.cxx:         G__genericerror(errtxt.c_str());
cintex/src/CINTFunctional.cxx:         G__genericerror("Exception: Unknown C++ exception");
cintex/src/CINTFunctional.cxx:                                     G__value* result,
cintex/src/CINTFunctional.cxx:                                     G__CONST char* /*funcname*/,
cintex/src/CINTFunctional.cxx:                                     G__param* /*libp*/,
cintex/src/CINTFunctional.cxx:      void* obj = (void*)G__getstructoffset();
cintex/src/CINTFunctional.cxx:      if( G__getaryconstruct() ) {
cintex/src/CINTFunctional.cxx:         if( G__PVOID == G__getgvp() ) { //  delete[] (TYPE*)(G__getstructoffset());
cintex/src/CINTFunctional.cxx:            for(int i = G__getaryconstruct()-1; i>=0 ; i--)
cintex/src/CINTFunctional.cxx:         long g__Xtmp = G__getgvp();
cintex/src/CINTFunctional.cxx:         G__setgvp(G__PVOID);
cintex/src/CINTFunctional.cxx:         G__setgvp(g__Xtmp);
cintex/src/CINTFunctional.cxx:         if( !(long(obj) == G__getgvp() && G__PVOID != G__getgvp()) )  {
cintex/src/CINTFunctional.cxx:            ::operator delete (obj); //G__operator_delete(obj);
cintex/src/CINTFunctional.cxx:      G__setnull(result);
cintex/src/CINTFunctional.cxx:   G__InterfaceMethod Allocate_stub_function( StubContext_t* obj, 
cintex/src/CINTFunctional.cxx:                                              int (*fun)(StubContext_t*, G__value*, G__CONST char*, G__param*, int ) )
cintex/src/CINTFunctional.cxx:      obj->fMethodCode = (G__InterfaceMethod)code;
cintex/src/CINTFunctionBuilder.cxx:         G__lastifuncposition();
cintex/src/CINTFunctionBuilder.cxx:         int ns_tag = G__search_tagname(sname.c_str(),'n');
cintex/src/CINTFunctionBuilder.cxx:         G__tag_memfunc_setup(ns_tag);
cintex/src/CINTFunctionBuilder.cxx:         G__resetifuncposition();
cintex/src/CINTFunctionBuilder.cxx:         G__tag_memfunc_reset();
cintex/src/CINTFunctionBuilder.cxx:      int access        = G__PUBLIC;
cintex/src/CINTFunctionBuilder.cxx:      int memory_type   = 1; // G__LOCAL;  // G__AUTO=-1
cintex/src/CINTFunctionBuilder.cxx:      G__InterfaceMethod stub;
cintex/src/CINTFunctionBuilder.cxx:         funcname = G__ClassInfo(tagnum).Name();
cintex/src/CINTFunctionBuilder.cxx:         funcname += G__ClassInfo(tagnum).Name();
cintex/src/CINTFunctionBuilder.cxx:         access = G__PRIVATE;
cintex/src/CINTFunctionBuilder.cxx:         access = G__PROTECTED;
cintex/src/CINTFunctionBuilder.cxx:         access = G__PUBLIC;
cintex/src/CINTFunctionBuilder.cxx:         const_ness = G__CONSTFUNC;
cintex/src/CINTFunctionBuilder.cxx:         memory_type += G__CLASSSCOPE;
cintex/src/CINTFunctionBuilder.cxx:      G__hash(funcname, hash, tmp);
cintex/src/CINTFunctionBuilder.cxx:      G__usermemfunc_setup( const_cast<char*>(funcname.c_str()), // function Name
cintex/src/CINTScopeBuilder.cxx:      G__linked_taginfo taginfo;
cintex/src/CINTScopeBuilder.cxx:      int tagnum = G__defined_tagname(taginfo.tagname, 2);
cintex/src/CINTScopeBuilder.cxx:      G__ClassInfo info(tagnum);
cintex/src/CINTScopeBuilder.cxx:         G__get_linked_tagnum(&taginfo);
cintex/src/CINTScopeBuilder.cxx:            G__tagtable_setup( taginfo.tagnum,       // tag number
cintex/src/CINTScopeBuilder.cxx:                               G__CPPLINK,           // cpplink
cintex/src/CINTTypedefBuilder.cxx:            if( -1 != G__defined_typename(nam.c_str()) ) return -1;
cintex/src/CINTTypedefBuilder.cxx:            if ( !scope.IsTopScope() ) stagnum = ::G__defined_tagname(CintName(scope.Name(SCOPED)).c_str(), 1);
cintex/src/CINTTypedefBuilder.cxx:            int r = ::G__search_typename2( t.Name().c_str(), rtypenum, rtagnum, 0, stagnum);
cintex/src/CINTTypedefBuilder.cxx:            ::G__setnewtype(-1,NULL,0);
cintex/src/CINTTypedefBuilder.cxx:         G__linked_taginfo taginfo;
cintex/src/CINTTypedefBuilder.cxx:         G__search_typename2(name, 117, G__get_linked_tagnum(&taginfo),0,-1);
cintex/src/CINTTypedefBuilder.cxx:         G__setnewtype(-1,NULL,0);
cintex/src/CINTUtils.cxx:         tagnum = ::G__defined_tagname(dsc.second.c_str(), 2);
cintex/src/CINTUtils.cxx:            G__linked_taginfo taginfo;
cintex/src/CINTUtils.cxx:            G__get_linked_tagnum(&taginfo);
cintex/src/CINTUtils.cxx:      else            return G__search_tagname(n.c_str(),'c');
cintex/src/CINTUtils.cxx:            G__TypedefInfo tdef(ctype.second.c_str());
cintex/src/CINTUtils.cxx:            int tagnum = G__defined_tagname(ctype.second.c_str(), 2);
cintex/src/CINTUtils.cxx:            else if ( tagnum != -1 ) arg_sig += "'" + string(G__fulltagname(tagnum, 1)) + "'";
cintex/src/CINTUtils.cxx:   void FillCintResult( G__value* result, const Type& typ, void* obj ) {
cintex/src/CINTUtils.cxx:      case 'y': G__setnull(result); break;
cintex/src/CINTUtils.cxx:         result->tagnum = G__search_tagname(ctype.second.c_str(),'c');
cintex/src/CINTVariableBuilder.cxx:         ::G__resetplocal();
cintex/src/CINTVariableBuilder.cxx:         int stagnum = ::G__defined_tagname(sname.c_str(), 2);
cintex/src/CINTVariableBuilder.cxx:         ::G__tag_memvar_setup(stagnum);      
cintex/src/CINTVariableBuilder.cxx:         ::G__resetglobalenv();
cintex/src/CINTVariableBuilder.cxx:         ::G__tag_memvar_reset();
cintex/src/CINTVariableBuilder.cxx:      int member_isstatic = G__AUTO;
cintex/src/CINTVariableBuilder.cxx:         member_isstatic = G__LOCALSTATIC;
cintex/src/CINTVariableBuilder.cxx:            ::G__loadlonglong(&member_tagnum, &member_typnum, G__LONGLONG);
cintex/src/CINTVariableBuilder.cxx:            ::G__loadlonglong(&member_tagnum, &member_typnum, G__ULONGLONG);
cintex/src/CINTVariableBuilder.cxx:            ::G__loadlonglong(&member_tagnum, &member_typnum, G__LONGDOUBLE);
cintex/src/CINTVariableBuilder.cxx:      if ( dm.IsPrivate() )        member_access = G__PRIVATE;
cintex/src/CINTVariableBuilder.cxx:      else if ( dm.IsProtected() ) member_access = G__PROTECTED;
cintex/src/CINTVariableBuilder.cxx:      else if ( dm.IsPublic() )    member_access = G__PUBLIC;
cintex/src/CINTVariableBuilder.cxx:            << (G__AUTO==member_isstatic ? "auto " : "static ")
cintex/src/CINTVariableBuilder.cxx:      ::G__memvar_setup((void*)dm.Offset(),                         // p
cintex/src/ROOTClassEnhancer.cxx:      int tagnum = ::G__defined_tagname(tagname, 2);
cintex/src/ROOTClassEnhancer.cxx:      G__ClassInfo cl_info(tagnum);
