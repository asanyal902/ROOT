// @(#)root/g3d:$Name:  $:$Id: TShape.cxx,v 1.1.1.1 2000/05/16 17:00:43 rdm Exp $
// Author: Nenad Buncic   17/09/95

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/

#include "TNode.h"
#include "TShape.h"
#include "TView.h"
#include "TVirtualPad.h"
#include "TGeometry.h"
#include "TMaterial.h"
#include "TFile.h"

ClassImp(TShape)

//______________________________________________________________________________
//*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
//*-*
//*-*  This is the base class for all geometry shapes.
//*-*  The list of shapes currently supported correspond to the shapes
//*-*  in Geant version 3:
//*-*     TBRIK,TCONE,TCONS,TGTRA,TPARA,TPCON,TPGON
//*-*    ,TTRAP,TTRD1,TTRD2,THYPE, TTUBE and TTUBS.
//*-*
//*-*  The figure below shows instances of all these shapes. This figure
//*-*  is generated by the ROOT 3-D viewer.
//Begin_Html
/*
<img src="gif/tshape_classtree.gif">
*/
//End_Html
//Begin_Html
/*
<img src="gif/shapes.gif">
*/
//End_Html
//*-*
//*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*

//______________________________________________________________________________
TShape::TShape()
{
//*-*-*-*-*-*-*-*-*-*-*-*-*Shape default constructor-*-*-*-*-*-*-*-*-*-*-*-*-*
//*-*                      =========================

   fVisibility = 1;
   fMaterial   = 0;
}


//______________________________________________________________________________
TShape::TShape(const char *name,const char *title, const char *materialname)
       : TNamed (name, title), TAttLine(), TAttFill()
{
//*-*-*-*-*-*-*-*-*-*-*-*-*Shape normal constructor-*-*-*-*-*-*-*-*-*-*-*-*-*
//*-*                      ========================

   fVisibility = 1;
   if (!gGeometry) gGeometry = new TGeometry("Geometry","Default Geometry");
   fMaterial   = gGeometry->GetMaterial(materialname);
   fNumber     = gGeometry->GetListOfShapes()->GetSize();
   gGeometry->GetListOfShapes()->Add(this);
#ifdef WIN32
//*-* The color "1" - default produces a very bad 3D image with OpenGL
   Color_t lcolor = 16;
   SetLineColor(lcolor);
#endif

}

//______________________________________________________________________________
TShape::~TShape()
{
//*-*-*-*-*-*-*-*-*-*-*-*-*Shape default destructor-*-*-*-*-*-*-*-*-*-*-*-*-*
//*-*                      ========================

   if (gGeometry) gGeometry->GetListOfShapes()->Remove(this);

}

//______________________________________________________________________________
Int_t TShape::ShapeDistancetoPrimitive(Int_t numPoints, Int_t px, Int_t py)
{
  Int_t dist = 9999;
  TView *view = gPad->GetView();
  if (!(numPoints && view)) return dist;

  Float_t *points =  new Float_t[3*numPoints];
  SetPoints(points);
  Float_t dpoint2, x1, y1, xndc[3];
  for (Int_t i = 0; i < numPoints; i++) {
     if (gGeometry) gGeometry->Local2Master(&points[3*i],&points[3*i]);
     view->WCtoNDC(&points[3*i], xndc);
     x1     = gPad->XtoAbsPixel(xndc[0]);
     y1     = gPad->YtoAbsPixel(xndc[1]);
     dpoint2= (px-x1)*(px-x1) + (py-y1)*(py-y1);
     if (dpoint2 < dist) dist = (Int_t)dpoint2;
  }
  delete [] points;
  return Int_t(TMath::Sqrt(Float_t(dist)));
}
//______________________________________________________________________________
void TShape::Paint(Option_t *)
{
   // This method must be overridden by the real shape implementation.

   // AbstractMethod("Paint");
}

//______________________________________________________________________________
void TShape::PaintShape(X3DBuffer *buff, Bool_t rangeView)
{
//*-*-*-*-*Paint 3-D shape in current pad with its current attributes*-*-*-*-*
//*-*      ==========================================================
//
// rangeView = kTRUE - means no real painting
//                     just estimate the range
//                     of this shape only

    //*-* Paint in the pad
    //*-* Convert to the master system

    if (!buff) return;

    Float_t *point = &(buff->points[0]);
    if (gGeometry) {
       for (Int_t j = 0; j < buff->numPoints; j++)
           gGeometry->Local2Master(&point[3*j],&point[3*j]);
    }
    
    Float_t x0, y0, z0, x1, y1, z1;
    const Int_t kExpandView = 2;
    int i0;

    x0 = x1 = buff->points[0];
    y0 = y1 = buff->points[1];
    z0 = z1 = buff->points[2];

    if (!rangeView) {
      TAttLine::Modify();  //Change line attributes only if necessary
      TAttFill::Modify();  //Change fill area attributes only if necessary
    }

    for (Int_t i = 0; i < buff->numSegs; i++) {
        i0 = 3*buff->segs[3*i+1];
        Float_t *ptpoints_0 = &(buff->points[i0]);
        i0 = 3*buff->segs[3*i+2];
        Float_t *ptpoints_3 = &(buff->points[i0]);
        if (!rangeView) gPad->PaintLine3D(ptpoints_0, ptpoints_3);
        else {
            x0 = ptpoints_0[0] < x0 ? ptpoints_0[0] : x0;
            y0 = ptpoints_0[1] < y0 ? ptpoints_0[1] : y0;
            z0 = ptpoints_0[2] < z0 ? ptpoints_0[2] : z0;
            x1 = ptpoints_3[0] > x1 ? ptpoints_3[0] : x1;
            y1 = ptpoints_3[1] > y1 ? ptpoints_3[1] : y1;
            z1 = ptpoints_3[2] > z1 ? ptpoints_3[2] : z1;
        }
    }
    if (rangeView)
    {
      TView *view = gPad->GetView();
      if (view->GetAutoRange()) view->SetRange(x0,y0,z0,x1,y1,z1,kExpandView);
    }
}
//______________________________________________________________________________
void TShape::SetPoints(Float_t *){
   AbstractMethod("SetPoints(Float_t *buffer)");
}

//______________________________________________________________________________
void TShape::Streamer(TBuffer &R__b)
{
   // Stream an object of class TShape.

   if (R__b.IsReading()) {
      UInt_t R__s, R__c;
      Version_t R__v = R__b.ReadVersion(&R__s, &R__c);
      if (R__v > 1) {
         TShape::Class()->ReadBuffer(R__b, this, R__v, R__s, R__c);
         return;
      }
      //====process old versions before automatic schema evolution
      TNamed::Streamer(R__b);
      TAttLine::Streamer(R__b);
      TAttFill::Streamer(R__b);
      if (gFile) {
         if (gFile->GetVersion() > 22300) TAtt3D::Streamer(R__b);
      } else {
         TAtt3D::Streamer(R__b);
      }
      R__b >> fNumber;
      R__b >> fVisibility;
      R__b >> fMaterial;
      R__b.CheckByteCount(R__s, R__c, TShape::IsA());
      //====end of old versions
      
   } else {
      TShape::Class()->WriteBuffer(R__b,this);
   }
}

