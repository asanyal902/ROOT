#1 * Could you please protect _ALL_ your changes in CINT by #ifdef
G__NOSTUBS?

Can be done... the only thing is to discuss the nostubs-test thingy
to make it coherent (it doesn't look trivial though).

Axel: This is not urgent - but you have large chunks of code that can be trivially protected - and that should be protected, because some compilers will not like it. So that ABI specific code should be protected en bloc.

POSTPONED
-------------------------------------------------------------------------------
#2 * why do you need mathcore/inc/Math/LinkDef2.h?

 I changed it but I don't remember why... MathCore is a tricky beast
 anyways and it needs to be re-checked because there are still some
 warnings...

POSTPONED
-------------------------------------------------------------------------------
#3 * why do you exclude COREDO from libCore (Makefile, line 600)?

 my bad... we changed that so many times that I don't even remember
 what we were supposed to do.... (I think I took it out in that
 failed attempt to separate the dictionaries from the libraries)


 DONE
-------------------------------------------------------------------------------
#4 * TClass.h: why do you need New(ENewType defConstructor =
 _TClass::_kClassNew);?

 It's an issue with the evaluation of the default parameters when
 calling a function. For enums, the class must be specified...

 Since we know what class we are dealing with, it should be possible
 to avoid it but that doesn't work for the moment... (you end up with
 an error saying that kClassNew is not know)

Axel: OK, that's a blocker. We need to discuss.

Axel explained this and it was actually not very complicated. We just needed to pass the tagnum
in the global variable.
DONE
-------------------------------------------------------------------------------
#5 * cint/lib/dll_stl/str.h: why did you _replace_
 op==(string::it,string::it) by op==(string::rev_it,string::rev_it)?

 yes... there were problems with the function pointer to it... for
 some weird reason you can have a pointer to the latter but not to
 the former... I know it's bad, that's why a left an -easily-
 trackable comment over there ;)

Axel: This, too, needs to be fixed; we need ideally both op==, and cannot survive without the original one.

POSTPONED
-------------------------------------------------------------------------------
#6 * cint/src/Class.cxx: why do you need to overload
 Cint::G__ClassInfo::GetMethod() - can't you just add a default
 value for noerror to be backward comp?

 yes... it was a remanent of the CInt "architecture" where I did that
 for some other functions.... anyways, it doesn't matter because that
 method is deprecated and can be removed.
 That method has been removed.

DONE
-------------------------------------------------------------------------------
#7 * fproto.h: could you rename G__get_address() to
 G__get_symbol_address(), please?

 If everything were that simple... :D

DONE
-------------------------------------------------------------------------------

#8 * fproto.h: any reason why you changed G__find_[first|
 last]_scope_operator to return a char* instead of a const char*?
 Consequences in v6_typedef.cxx:51, :1093

 nopes... this is one of those merge issues

DONE 
(Changes made in fproto.h, v6_opr.cxx, v6_struct.cxx,
v6_typedef.cxx)

-------------------------------------------------------------------------------
#9 * v6_lib.cxx: could you update the file doc, explaining what
 actually _is_ done instead of what might maybe be done? :-)

 hehehe... such things happen when you change plans along the way ;)

DONE
-------------------------------------------------------------------------------
#10 * v6_lib.cxx: why does this file contain functions that are not
 needed anymore?

 just in case... :D (I was thinking about deleting them but in that
 case the file would be too small and we would have to delete it too :
 ( )

For the last three comments... I have deleted this file since most of
it has been deprecated... now we end up with a short function and I
will move it to newlink.cxx


DONE
-------------------------------------------------------------------------------
#11 * v6_typedef.cxx:791ff: if you set filenum=-1 at least ".typedefs"
 should crash. I think there is something similar in G__struct. But
 anyway - why do you see this typedef staying around (so it can get
 a wrong file name) even though the tmp file has apparently been
 unloaded?

 I don't remember when you see it... but you do, and in an ugly
 way... this is one of those places where we needed a better grasp of
 CInt to make changes... I will ask you about it later on...

POSTPONED
-------------------------------------------------------------------------------
#12 * v6_typedef.cxx: int G__defined_typename2(const char *type_name,
 int noerror) "Has to be changed to avoid code replication" - can
 you? :-)

 I hope... all those replicated functions are way too ugly

Axel:
The problems with the function duplicates are
* you fix one because you found a bug - but the other don't get fixed because GDB didn't complain about them
* in the end they are slightly different, and nobody knows whether that's intentional or by accident (because of patches not making it into all versions of the function)
* it's extremely difficult to see what the intended difference between the functions is - much more than a "if (mode==kDictionaryOutput) {...}" or whatever.

It's done... but I had to change all its callers.. is that fine?

DONE
-------------------------------------------------------------------------------
#13 * common.h:255: why?! what used to be G__STATICCONST is now
 G__FUNCTHROW, and one cannot OR these bits anymore, because
 G__STATICCONST is not a bit anymore!

 yes.. you are right.. there was a misunderstanding among us and I
 kind of messed it up... now some things come to my mind again :D


for the record, we should avoid mixing decimal and hexas....
DONE

Axel: How many bits do you have left? the CONST part gets folded in - so can you still afford a 0x20?
Yeps... that's what I did... used the 6th bit for that

-------------------------------------------------------------------------------
#14 * v6_init.cxx: you have reverted my typeid(size_t) patch!

 I have never seen that before (and Diego agrees) ... this one goes
 to the merge problem too :/


your typeid should be there now... it's the same merge problem.. sigh..

DONE
-------------------------------------------------------------------------------
#15 * v6_ifunc.cxx:3485ff: could you tag everything that is compiler
 specific in the non-stubs handling, so we know where to work on for
 new compilers? Like
 //%%%G__NOSTUB compiler specific BEGIN%%%
 ...
 //%%%G__NOSTUB compiler specific END%%%

 We tried.... the idea was to put all that in a single function...
 but we didn't succeed... we will try to mark to dependant parts

POSTPONED
-------------------------------------------------------------------------------

#16 * v6_ifunc.cxx:4691: //1 is the old behavior - which "1"?

 in the new get_method_handles we need this thing _not_ to be
 recursive so we always pass 0 instead of the variable (which wold
 pass 1 in the old behaviour)

RECHECK

Axel: Please put a more explicit comment in there.

That seems to be unchanged. I'm removing the comment.
DONE
-------------------------------------------------------------------------------


#17 * v6_ifunc.cxx:5448: why?

 i think it was because _sometimes_ CInt wont put the names of the
 destructors in G__struct (of course, such thing is beyond my
 understanding).

-------------------------------------------------------------------------------
#18 * v6_ifunc.cxx:6794ff: G__get_ifunchandle2,
 G__get_ifunchandle_base2, G__argtype2param2 (claiming to be exactly
 the same as G__argtype2param...), G__get_methodhandle3,
 G__get_methodhandle4: can you reduce the code duplication? It's a
 _lot_... And it makes it much harder to understand what the
 difference between the unnumbered and the numbered version of the
 function is.

 Yes... I know... again, I didn't want to screw things up at the
 beginning so I preferred to do that instead of changing the original
 functions.... I guess now is a good time to re factor all that.

I removed all of the except for G__get_methodhandle4 which is a copy of *methodhandle2 but
this is for optimization purposes... we save a little bit in the function call is we can use the
ifunc_table_internal instead of the ref.

DONE
-------------------------------------------------------------------------------
#19 * v6_ifunc.cxx:7059: what's the consequence of that "if (buf.type !
 = -1)"? Do the stubless calls not support variadic functions?

 They do... but not the parser. (when reading the symbols)

Axel: Ehrm, so that boils down to the same thing? Variadic functions will get a wrapper? 
(That's fine - I'm just trying to understand what you are doing there.)

This means that the "..." will be ignored whe converting the parameters in a "char *" to a G__param,
I think this would work because the number of parameters in a variadic function can change and 
the "..." don't count for that (the parameters are evaluated in a different way).

(and yes, we can remove the stubs for variadic functions)

DONE
-------------------------------------------------------------------------------
#20 * v6_ifunc.cxx:7259: spaces

 yips... I'm still looking for the -w in svn ;)


RECHECK
-------------------------------------------------------------------------------
#21 * bc_inst.cxx:289ff: when you say you can't fix it why keep the
 "FIXME!"?

 I want a flag to point out a potential problem.... we can always
 change it for "Potential SEGFAULT " :D

Axel: :-) OK.

Changed the FIXME by a warning being a bit more verbose
DONE
-------------------------------------------------------------------------------
#22 * v6_newlink.cxx:27: ext/hash_map only exists on GCC compilers.
 This include will break CINT e.g. on windows, solaris,... Same with
 cxxabi.h. Again, these must be protected with G__NOSTUBS _and_ the
 appropriate test on the compiler macro (G__GCCVER or whatever)

 Yips... no doubt about that... we will bother you again later to see
 how we can try to compile it on windows...

-------------------------------------------------------------------------------
#23 * v6_newlink.cxx:350: G__wrappers and G__nostubs should be defined
 in globals[2].cxx

 Yes, My Lord! ... ohh such good memories...

DONE
-------------------------------------------------------------------------------

#24 * v6_newlink.cxx:1680ff: I think G__float was not to be used; use
 G__double instead. Do you need G__float?

 I wasnt sure about it... I will follow your lead on this...

 I though float and double were different (isn't float single
 precision, therefore only 32 bits in x86_64?)

Axel: Yes, but CINT always stores values as doubles. obj.f should not be used.

ok... The only thing is remembering to turn the double (known by cint) to a float when we want
to push it for the function call

DONE
-------------------------------------------------------------------------------
#25 * v6_newlink.cxx: 1832f: ... *= -1; is more readable (twice)

 :?... we discussed that in person...

DONE
-------------------------------------------------------------------------------
#26 * v6_newlink.cxx: 1847f: if you found one function candidate in the
 current class then you do not need to loop over the bases, or do
 you? Shouldn't the bases' functions be hidden? I.e. shouldn't it be
 if (cbases && n == 0)?

 We are looking for ambiguous functions... so we need to look at all
 of them.

Axel: Doubt it; I'll come over to discuss it.

RECHECK (reread that code)

-------------------------------------------------------------------------------
#27 * v6_newlink.cxx: 1905, 1930: why do you set ifunc_res - it's not
 used anywhere?

 I don't remember... ;)

ifunc_res has been removed.

DONE
-------------------------------------------------------------------------------

#28 * v6_newlink.cxx: 2050: instead of copying each parameter (param =
 rpara->para[k]) could you just keep a ptr or better yet a const ref
 to it?

 can do

DONE
-------------------------------------------------------------------------------
#29 * v6_newlink.cxx: 2095ff: can't you trivially combine the __asm__
 calls of these three cases, by having the double value set
 differently but then passing it by the same lines of code?

 yes... it just had a low priority...

Axel: Agreed. This should be done as soon as Diego add another supported compiler :-)
-------------------------------------------------------------------------------
#30 * v6_newlink.cxx: 2125, 2292: osize is unused

 nevermind... how can you see such things?... if you have some kind
 tool to look for that kind of error it will be deeply appreciated...
 my carelessness doesn't really follow my common sense...

Axel: It's my eyes. Sorry, I cannot spare them.

DONE
-------------------------------------------------------------------------------
#31 * v6_newlink.cxx: 2150ff: why do you need to create a local copy of
 the value in param.obj - can't you pass param.obj.xyz to __asm__
 directly?

 remnants of code that was changed 12 times... :D

DONE 

(We still have some of those that use things like G__int(), we have to check if they can be removed too)
-------------------------------------------------------------------------------
#32 * v6_newlink.cxx: 2215: long long does not fit into 2 ints. Why is
 the case for G__uint 64 _so_ different?

Axel: Mind commenting on that one? ;-) I assume you'll fix it?

sizeof(long long) = 8
sizeof(int) = 4

So we are assuming that to pass a long long to a function we have to push it to the stack as two 
words. This has to be done for all the types being bigger than 4 (i.e. "long long" and "double")

Note: What do we do with the "long double" which should be 12 bytes long? 

RECHECK
-------------------------------------------------------------------------------
#33 * v6_newlink.cxx: 2282: I suppose "Parameter's type?" is meant to
 be "Return type?"

 yipes... that tool you have again? :P

Some comments were added

DONE
-------------------------------------------------------------------------------
#34 * v6_newlink.cxx: 2238: no way Jose - can't squeeze a long double
 into an int!

 I thought we weren't doing it... must check


I don't see it :/


RECHECK
-------------------------------------------------------------------------------
#35 * v6_newlink.cxx: 2450: type 'y' is "void" :-)

 eventually... we came to understand such subtleties...

DONE
-------------------------------------------------------------------------------
#36 * v6_newlink.cxx: 2630ff: could you please combine (most of) the
 code for the array-new and the non-array-new?

 we would like too... again... it's low at the priority list

Axel: Humm. See my reasoning above why delaying the refactoring of copied code is bad.

-------------------------------------------------------------------------------
#37 * v6_newlink.cxx: 2760ff: don't I know this code from somewhere
 already? Could you refactor it, please?

 I know... I'm sure there must a tool to do such things too :D

Axel: There is, actually, at least on windows. But it's about twice as fast to do it by hand ;-)

-------------------------------------------------------------------------------
#38 * v6_newlink.cxx: 3000: why is the c'tor call so different from the
 regular func calls (involving eax etc)? Or can you "just" set up
 yet another regular func call? Keep in mind that we need to re-
 implement _all_ of that for every new ABI!

 159th thing to do :/ ... yes, it's ugly... and yes, we would like to
 have just one nice asm function...
-------------------------------------------------------------------------------

#39 * v6_newlink.cxx: 3038: "tagnum = (int) ((*iter).second);" ->
 "tagnum = iter->second;"

 This made laugh ....

DONE
-------------------------------------------------------------------------------
#40 * v6_newlink.cxx: 3084: I don't understand why CINT thinks a class
 doesn't derive from TObject if it doesn't have a ClassDef.

 The G__isbaseclass doesn't work... is there another way to check
 this kind of thing?

Axel: Need to discuss, I don't understand.

We discussed it, Axel said CInt doesn't need a ClassDef to "know" about a function, it only
needs to read the header file. Now I don't understand why it doesnt work either.

RECHECK
-------------------------------------------------------------------------------
#41 * v6_newlink.cxx: 3137: what do we do about the offset for virtual
 inheritance - does G__isanybase handle that?

 we are betting on it...

Axel: And it does!
-------------------------------------------------------------------------------

#42 * v6_newlink.cxx: 3197: can you combine array / scalar deletion?
 Can you factor out the call setup code, at _least_ combine it with
 the new() part?

 with some luck...
-------------------------------------------------------------------------------

#43 * v6_newlink.cxx: 3303: what does that comment reference? I don't
 see any EAX.

 it did serve its purpose... at some point...

 I guess it's time to send it to a greener field...

DONE
-------------------------------------------------------------------------------
#44 * v6_newlink.cxx: 3381: this-ptr adjustment happens inside
 G__stub_method_calling? Please add a comment if that's the case.

 I don't see what you refer to... but there shouldnt be a permanent
 adjustment in G__stub_method_calling...

Axel: Assuming I remember correctly: the this-ptr adjustment was asymmetric, say it happened in 
the "else" part but not in the "if". So I was wondering whether it happens in a function call within 
the "if" part.

It's because the adjustment is needed when calling the stub but not when we use asm directly.
It has to do with diego's changes to remove the stubs of inherited functions. In that case, an
adjustment of the this pointer to the base classs is needed.

DONE
-------------------------------------------------------------------------------
#45 * v6_newlink.cxx: 3346: must have wrappers #ifndef
 G__EXCEPTIONWRAPPER?

 I dont see your point... I must rem to ask you in person.

Axel: If G__EXCEPTIONWRAPPER is not defined then the thing blows up, because you're not handling that part of the code (I think).

You were rigth... this is fixed.

DONE
-------------------------------------------------------------------------------
#46 * v6_newlink.cxx: 3723 (and more): don't put C++ comments into
 dict; we can (and do) generate also C dictionaries with this code.

 noted...

-------------------------------------------------------------------------------
#47 * v6_newlink.cxx: 4453: "q" == long double == cast is missing!
 must check

DONE
-------------------------------------------------------------------------------
#48 * v6_newlink.cxx: 4504: UInt_t etc are ROOT! Don't use them in CINT.

 hauhauahuahauha...

How did that even compile?! Did you #include "Rtypes.h"?

DONE
-------------------------------------------------------------------------------
#49 * v6_newlink.cxx: 4080, 9007: "Dont try to evaluate this condition"
 which condition? Mention 

"if(ifunc->pentry[j]->size<0) continue; /*already precompiled */" 
in the comment.

 can be done.. ;)
DONE
-------------------------------------------------------------------------------
50* ?
-------------------------------------------------------------------------------
#51 * v6_newlink.cxx: 4090 (and below, also 5155, 5200, 5300,6800...):
 why do you veto these (and only these) STL classes? And could you
 please factor it out + cache the result?

 those are the one posing problems when generating the dicts.... I
 thought they were the ones hand coded into Cint... and yes... it's
 ugly... I hate all those confusing IF's we have with them...

Axel: Need to talk to you which problems they have.

-------------------------------------------------------------------------------
#52 * v6_newlink.cxx: 9359: #else // 1289_YET  || !1993 etc - where
 does that come from?
 I don't know... that was already there.

 Note: Check for consistency


#53 * v6_newlink.cxx: 11930: //1 is which old behavior? What "1"?

 duplicated question :P


#54 * v6_newlink.cxx: 12476: what happened to the "#endif /
 *G__SMALLOBJECT*/"?

 I couldnt find this one :/


#55 * v6_symbols.cxx: should we rename this to v6_symbols_gcc3.cxx or
 at least v6_symbols_gcc.cxx?

 "You say potato... "

 no prob..

 Although I think It's not specific... I would like to see how true
 that is...


#56 * v6_symbols.cxx: use a simpler hash (much faster and pretty good,
 too), e.g.
     inline Hash_t Hash(const std::string& s) {
        Hash_t hash = 5381;
        const char* str = s.c_str();

        while (*str) {
           hash *= 5;
           hash += *(str++);
        }
        return hash;
     }

 Everything reducing code is welcome...


#57 * v6_symbols.cxx: TSymbol: use const char* as member fMangled (just
 point to the lib's text), make fIdWhatever an int witha  bitmask
 (saves 4bytes per symbol + c'tor instructions)

 All that code is crap... it was supposed to proof of concept...

#58 * v6_symbols.cxx: TSymbol::Hash() { return fClassHash; } is
 sufficient :-)
#59 * v6_symbols.cxx: TSymbolLookup::AddRegistered, SetLibname should
 take a "const string&" or better yet a const char*.
#60 * v6_symbols.cxx: TSymbolLookup::fRegistered should be a set!
#61 * v6_symbols.cxx: TSymbolLookup::SetSymbols() (and d'tor): who
 deletes the list<TSymbol*>?

 Ditto...


#62 * v6_symbols.cxx: MapDependantTypesTree: ROOT specific, must be
 moved to ROOT.

 It was there at the beginning... but it's so ugly I can't believe it
 has to be there...

#63 * v6_symbols.cxx: locate_linkmap, get_linkmap: not used anymore?
 then remove, please.

 just in case... it was a tough nut so I like to see it around...

 (don't worry... it will be removed in one of the cleanups)

#64 * v6_symbols.cxx: example TTree::TFriendLock::TFriendLock: we need
 to discuss this. What's the issue exactly?

 I think it's because we find it when we demangle the symbols but we
 don't find it in CInt's memory (no ClassDef) ...

#65 * v6_symbols.cxx: paramtoken[index]=='0'...: use >=, <= or "isdigit"

 isdigit... I knew someone would be smart enough to put that function
 somewhere :D

#66 * v6_var.cxx: 1513: why obj.i?

 i don't rem the trigger but it was causing a segfault... what are
 the side effects? (can we really get float from i?... it looks fishy)


#67 * v6_var.cxx: 4106keep:
 -#ifdef G__ASM_DBG
 -               if (G__asm_dbg) {
 -                  G__fprinterr(G__serr, "%3x,%3x: PUSHSTROS  %s:%d
 \n", G__asm_cp, G__asm_dt, __FILE__, __LINE__);
 -               }
 -#endif // G__ASM_DBG


#68 * G__ci.h: must _not_ contain G__ifunc_table_internal (that's where
 its name comes from). Do we really need it in the public interface?

 I think it's there because we put them some other functions that
 need it... I dont see a problem moving it...
 Or can it be moved to fproto.h?


#69 * G__ci.h: no G__float


#70 * G__ci.h: why did G__display_class change the constness of its
 name parameter?

 svn says that happened in a merge... we have to check it out


#71 * G__ci.h: you shouldn't change G__memfunc_setup; just introduce
 G__memfunc_setup_sym (or ...2).

 did we change it?...

 "Where is my mind...."

#72 * rootcint.cxx: 4450ff: --cxx still needed? -o still needed?

 deprecated...

#73 * rootcint.cxx: doc for if (!strcmp(argv[ic], "-.")) talks about -S!

 we are trying to see if we can make enough damage to earn a
 permanent position :P

#74 * rootcint.cxx: 4680: indentation

 that has to be rechecked.... for every file

#75 * rootcint.cxx: can you send me a diff with 'svn diff -x "-b -u"'
 of rootcint.cxx, please?

 is this what you want to see?
 <rootcint_bu.diff>

#76 * utils/Module.mk: why did you replace ROOTCINTTMPEXE by
 ROOTCINTTMPDEP? I believe that's wrong... You probably need to
 revert this file.

 We changed them all... you are probably right


#77 * TApplication.cxx: 175ff: Why is this needed to be moved? FLT_MAX:
 TH1 must #include float.h so why doesn't CINT find that symbol?

 I dont know... that code is pretty old... I will check it out.


#78 * base/inc/TString.h: again, why do you need to prefix the enum
 constant with its class name? This should not be required.

 duplicated... commented at the beginning..

#79  * v6_lib.cxx: why do you have so many commented include statements?

 ditto... (I was half expecting it to change again)

#80 * in config/Makefile.linux, could you surround the GCC version extraction by
ifeq ($(ENABLESTUBS)$(ENABLESTUBSTEST),no)
...
endif

DONE
-------------------------------------------------------------------------------

#81 * in config/Makefile.linux, why do you have two clauses
ifeq ($(ENABLESTUBS),no)
setting the CXXFLAGS 1.5 times?

DONE
-------------------------------------------------------------------------------

#82 * in config/Makefile.linux, if you decide that the GCC version is improper,
could you reset ENABLESTUBS:=yes?

DONE
-------------------------------------------------------------------------------

#83 * what happens if I do configure --no-stubs --no-stubs-test

--no-stubs-test WINS!

DONE
-------------------------------------------------------------------------------

#84 * in config/Makefile.linux, can you combine the two ROOTCINTTMP setters (for
ENABLESTUBS, ENABLESTUBSTEST) and only set -DG__NOSTUBS etc when ENABLESTUBS is
set?

DONE
-------------------------------------------------------------------------------

#85 * cint/src/Class.cxx, line 849ff: what happened to the "rootspecial" stuff -
can you really just remove it? Around line 905 you left the call to
CheckValidRootInfo() but removed the access to
G__struct.rootspecial[tagnum]->defaultconstructor - why is it not the same for
line 849ff? And do you need the rootspacial? Or can you really just remove it?


#86 * v6_init.cxx: G__dicttype - could you make that an enum, possibly with a step
number? E.g. what used to be "3" could be kDictType3_ForceOutline or so. What
happened to G__dicttype==1?

dicttype = 1 generates dictionary with showMembers (look for dicttype in rootcint.cxx)

DONE
-------------------------------------------------------------------------------

#87 * v6_newlink.cxx: 6652: please keep "if(ifn>=G__MAXIFUNC)"

#88 * v6_newlink.cxx: 9961: why don't we veto static functions anymore?

#89 * v6_loadfile.cxx: 189: where does the "c!=-1" come from?

#90 * rootcint_nostubs.ch: what happens (flow control wise) if an error occurs say
at the second call to rootcint or the call to g++? "rm -rf /"?

#91 * rootcint_nostubs_tmp.sh: is there a difference to rootcint_nostubs.sh? Can
you combine the two?

DONE
-------------------------------------------------------------------------------

#92 * v6_newlink.cxx: 4155: where does G__if_ary_union_constructor come from? What
does it do? Doc, please.
