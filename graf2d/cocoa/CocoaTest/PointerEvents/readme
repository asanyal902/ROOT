Pointer tests.

It's very difficult to test, I think the only way to check this is just to carefully read the code.
But still - some test cases. They are not covering all possible cases, but at least some basic.
As I do not have testers for GUI and any testing framework for GUI, I have this primitive tests to catch
something really stupid (and they, actually, did some work already).
The idea is to compile the same test with X11/TGCocoa versions and compare event messages.
They are not identical, there some completely strange things with X11 and its window manager (they can add
some unexpected events), but in general events should be more or less the same.


TEST1-4 : crossing events with and without grab (grab is implicit).

TEST1: crossing events without any grabs (implicit on 'root' only, if button pressed), only one top-level window.

Description (example)

Move into 4 from screen:
Enter notify for 4

Move from 4 to 5 and 6 (overlapping part):

Leave notify 4
Enter notify 5
Enter notify 6 (order of enter notify events is different with TGCocoa)

Move again to 4 (from overlapping part):

Leave notify 6
Leave notify 5
Enter notify 4

Press button in 4 (and do not release):

Leave notify 4

Move to 6 (overlapping part):

No events reported (implicit grab on 'root').

Release button:

Enter notify 4
Enter notify 5
Enter notify 6 (we "jumped" from implicitly grabbed 'root') - order can be different with
TGCocoa

TEST2: crossing events without grabs (implicit on 'root' only, if button pressed), two top-level windows.

 
Description (example)

Move from screen to window 4:

Enter notify 4

Move from 4 to 8 (another top-level window):

Leave notify 4
Enter notify 7
Enter notify 8 (order of enter notify events is reversed with TGCocoa).

Press button (and do not release) on window 8:

Leave notify 8
Leave notify 7

Move to window 6 (overlapping part):

No events reported (implicit grab on 'root').

Release button in 6:

Enter notify 4
Enter notify 5
Enter notify 6 (order is reversed with TGCocoa).

If, instead, we press button while in a window 6, there is a difference between TGCocoa and X11 (on Ubuntu):
at the beginning of test, window 4 is "behind" window 7 in a window stack, when pressing button - it's raised
(by WM?) and there is a strange sequence of leave/enter notify events along the window tree forth and back -
this I'm NOT GOING to emulate, since this is not a part of any specification.

TEST3:

Setup as in TEST1, but now window 5 has button press mask (to become an implicit grab). 
Also, button 5 can have button release mask (+-) to test other buttons press/release events while
still holding the primary button (button which initiated grab).

Description (example)

Move from screen to window 4:

Enter notify 4

Move to 5:

Leave notify 4
Enter notify 5

Move to 6:

Leave notify 5
Enter notify 6

Press a left/right mouse button (and do not release):

Leave notify 6
Enter notify 5
Button press 5 (Here I see the difference: on Ubuntu button press precedes crossing events - I do not care about all this shit: according to X11 protocol crossing events are generated BEFORE button press event).

Move from 5 (to the right, so leave both 6,5,4 at one move):

Leave notify 5

Move back (into overlapping part):

Enter notify 5

Press/release another mouse button:

Button press 5
Button release 5 (if you have kButtonReleaseMask, see test's setup)

Release the button, which initialised the grab: 

Button release 5
Leave notify 5
Enter notify 6

////
While in grab, also check what happens when mouse moves for example, from

Move from 4 to 5:

Enter notify 5

From 5 to 6

Leave notify 5

From 6 to 5

Enter notify 5


TEST4:

Setup as in TEST2, window 5 and 7 has additional kButtonPressMask | kButtonReleaseMask, because of kButtonPressMask they can initiate implicit grab.

Description a) (example)

Move from screen to window 8:

Enter notify 7
Enter notify 8 (order can be reversed with TGCocoa).

Press left or right mouse button and do not release:

Leave notify 8
Enter notify 7
Button press 7

Move from window 8 (we still were here) to window 6 (overlapping part):

Leave notify 7

Press another mouse button and release it:

Button press 7
Button release 7

Release the button, which initiated the grab:

Button release 7

Leave notify 7
Enter notify 4
Enter notify 5
Enter notify 6 (the order of enter notify events is reversed with TGCocoa).

Description b) (example)

Move from screen to window 4:

Enter notify 4

From 4 to 5:

Leave notify 4
Enter notify 5

From 5 to 6:

Leave notify 5
Enter notify 6

Press mouse button (left or right, do not release):

Leave notify 6
Enter notify 5
Button press 5

Move from 6 (we still were here) to 8:

Leave notify 5

Press/release another mouse button:

Button press 5
Button release 5

Release button, which started the grab:

Button release 5
Leave notify 5
Leave notify 4
Enter notify 7
Enter notify 8 (order of enter events is reversed with TGCocoa).


TEST5-8 : crossing events with passive grab (owner_events can be true or false).

TEST5:

Setup as in TEST1.

There is a passive grab on window 5.

Description (example)

Move from screen to 4:

Enter notify 4

From 4 to 5:

Leave notify 4
Enter notify 5

From 5 to 6:

Leave notify 5
Enter notify 6

Press mouse button (left or right, do not release):

Leave notify 6
Enter notify 5
Button press 5 (grab is initiated) (on Ubuntu order of crossing events and button press - is reversed).

Move from 6 to 5:

Leave notify 6
Enter notify 5

From 5 to 4:

Leave notify 5
Enter notify 4

Press and release another button in 4:

Button press 5
Button release 5

Move from 4 to 5:

Leave notify 4
Enter notify 5

From 5 to 6:

Leave notify 5
Enter notify 6

Release button, which started the grab

Release button 5
Leave notify 5
Enter notify 6

