Pointer tests.

TEST1: crossing events without any grabs (implicit on 'root' only, if button pressed), only one top-level window.

Description (example)

Move into 4 from screen:
Enter notify for 4

Move from 4 to 5 and 6 (overlapping part):

Leave notify 4
Enter notify 5
Enter notify 6 (order of enter notify events is different with TGCocoa)

Move again to 4 (from overlapping part):

Leave notify 6
Leave notify 5
Enter notify 4

Press button in 4 (and do not release):

Leave notify 4

Move to 6 (overlapping part):

No events reported (implicit grab on 'root').

Release button:

Enter notify 4
Enter notify 5
Enter notify 6 (we "jumped" from implicitly grabbed 'root') - order can be different with
TGCocoa

TEST2: crossing events without grabs (implicit on 'root' only, if button pressed), two top-level windows.

 
Description (example)

Move from screen to window 4:

Enter notify 4

Move from 4 to 8 (another top-level window):

Leave notify 4
Enter notify 7
Enter notify 8 (order of enter notify events is reversed with TGCocoa).

Press button (and do not release) on window 8:

Leave notify 8
Leave notify 7

Move to window 6 (overlapping part):

No events reported (implicit grab on 'root').

Release button in 6:

Enter notify 4
Enter notify 5
Enter notify 6 (order is reversed with TGCocoa).

If, instead, we press button while in a window 6, there is a difference between TGCocoa and X11 (on Ubuntu):
at the beginning of test, window 4 is "behind" window 7 in a window stack, when pressing button - it's raised
(by WM?) and there is a strange sequence of leave/enter notify events along the window tree forth and back -
this I'm NOT GOING to emulate, since this is not a part of any specification.

TEST3:

Setup as in TEST1, but now window 5 has button press mask (to become an implicit grab). 
Also, button 5 can have button release mask (+-) to test other buttons press/release events while
still holding the primary button (button which initiated grab).

Description (example)

Move from screen to window 4:

Enter notify 4

Move to 5:

Leave notify 4
Enter notify 5

Move to 6:

Leave notify 5
Enter notify 6

Press a left/right mouse button (and do not release):

Leave notify 6
Enter notify 5
Button press 5 (Here I see the difference: on Ubuntu button press precedes crossing events - I do not care about all this shit: according to X11 protocol crossing events are generated BEFORE button press event).

Move from 5 (to the right, so leave both 6,5,4 at one move):

Leave notify 5

Move back (into overlapping part):

Enter notify 5

Press/release another mouse button:

Button press 5
Button release 5 (if you have kButtonReleaseMask, see test's setup)

Release the button, which initialised the grab: 

Button release 5
Leave notify 5
Enter notify 6

////
While in grab, also check what happens when mouse moves for example, from

Move from 4 to 5:

Enter notify 5

From 5 to 6

Leave notify 5

From 6 to 5

Enter notify 5


TEST4:

Setup as in TEST2, window 5 and 7 has additional kButtonPressMask | kButtonReleaseMask, because of kButtonPressMask they can initiate implicit grab.

Description a) (example)

Move from screen to window 8:

Enter notify 7
Enter notify 8 (order can be reversed with TGCocoa).

Press left or right mouse button and do not release:

Leave notify 8
Enter notify 7
Button press 7

Move from window 8 (we still were here) to window 6 (overlapping part):

Leave notify 7

Press another mouse button and release it:

Button press 7
Button release 7

Release the button, which initiated the grab:

Button release 7

Leave notify 7
Enter notify 4
Enter notify 5
Enter notify 6 (the order of enter notify events is reversed with TGCocoa).

