Index: core/meta/src/TClassRef.cxx
===================================================================
--- core/meta/src/TClassRef.cxx	(revision 35093)
+++ core/meta/src/TClassRef.cxx	(working copy)
@@ -55,37 +55,31 @@
 }
 
 //______________________________________________________________________________
-TClassRef &TClassRef::operator=(const TClassRef &rhs)
+void TClassRef::Assign(const TClassRef &rhs)
 {
-   // Assignment operator, increases reference count to original class object.
+   // Assignment operator implementation, increases reference count to original class object.
+   // This routines assumes that the copy actually need to be done.
 
-   if (this != &rhs) {      
-      if (fClassPtr != rhs.fClassPtr) {
-         if (fClassPtr) fClassPtr->RemoveRef(this);
-         fClassName = rhs.fClassName;
-         fClassPtr  = rhs.fClassPtr;
-         if (fClassPtr) fClassPtr->AddRef(this);
-      }
-   }
-   return *this;
+   if (fClassPtr) fClassPtr->RemoveRef(this);
+   fClassName = rhs.fClassName;
+   fClassPtr  = rhs.fClassPtr;
+   if (fClassPtr) fClassPtr->AddRef(this);
 }
 
 //______________________________________________________________________________
-TClassRef &TClassRef::operator=(TClass* rhs)
+void TClassRef::Assign(TClass* rhs)
 {
    // Assignment operator, increases reference count to original class object.
+   // This routines assumes that the copy actually need to be done.
 
-   if (this->fClassPtr != rhs) {      
-      if (fClassPtr) fClassPtr->RemoveRef(this);
-      fClassPtr  = rhs;
-      if (fClassPtr) {
-         fClassName = fClassPtr->GetName();
-         fClassPtr->AddRef(this);
-      } else {
-         fClassName.clear();
-      }
+   if (fClassPtr) fClassPtr->RemoveRef(this);
+   fClassPtr  = rhs;
+   if (fClassPtr) {
+      fClassName = fClassPtr->GetName();
+      fClassPtr->AddRef(this);
+   } else {
+      fClassName.clear();
    }
-   return *this;
 }
 
 //______________________________________________________________________________
Index: core/meta/src/TClass.cxx
===================================================================
--- core/meta/src/TClass.cxx	(revision 35093)
+++ core/meta/src/TClass.cxx	(working copy)
@@ -717,7 +717,7 @@
    fVersionUsed(kFALSE), fProperty(0),
    fInterStreamer(0), fOffsetStreamer(0), fStreamerType(kNone),
    fCurrentInfo(0), fRefStart(0), fRefProxy(0),
-   fSchemaRules(0)
+   fSchemaRules(0), fStreamerImpl(&TClass::StreamerDefault)
 {
    // Default ctor.
 
@@ -741,7 +741,7 @@
    fVersionUsed(kFALSE), fProperty(0),
    fInterStreamer(0), fOffsetStreamer(0), fStreamerType(kNone),
    fCurrentInfo(0), fRefStart(0), fRefProxy(0),
-   fSchemaRules(0)
+   fSchemaRules(0), fStreamerImpl(&TClass::StreamerDefault)
 {
    // Create a TClass object. This object contains the full dictionary
    // of a class. It has list to baseclasses, datamembers and methods.
@@ -791,7 +791,7 @@
    fVersionUsed(kFALSE), fProperty(0),
    fInterStreamer(0), fOffsetStreamer(0), fStreamerType(kNone),
    fCurrentInfo(0), fRefStart(0), fRefProxy(0),
-   fSchemaRules(0)
+   fSchemaRules(0), fStreamerImpl(&TClass::StreamerDefault)
 {
    // Create a TClass object. This object contains the full dictionary
    // of a class. It has list to baseclasses, datamembers and methods.
@@ -820,7 +820,7 @@
    fVersionUsed(kFALSE), fProperty(0),
    fInterStreamer(0), fOffsetStreamer(0), fStreamerType(kNone),
    fCurrentInfo(0), fRefStart(0), fRefProxy(0),
-   fSchemaRules(0)
+   fSchemaRules(0), fStreamerImpl(&TClass::StreamerDefault)
 {
    // Create a TClass object. This object contains the full dictionary
    // of a class. It has list to baseclasses, datamembers and methods.
@@ -1081,7 +1081,8 @@
   fCurrentInfo(cl.fCurrentInfo),
   fRefStart(cl.fRefStart),
   fRefProxy(cl.fRefProxy),
-  fSchemaRules(cl.fSchemaRules)
+  fSchemaRules(cl.fSchemaRules),
+  fStreamerImpl(cl.fStreamerImpl)
 {
    //copy constructor
    
@@ -1190,7 +1191,14 @@
    delete fCollectionProxy;
    delete fIsAMethod;
    delete fSchemaRules;
-   delete fConversionStreamerInfo;
+   if (fConversionStreamerInfo) {
+      std::map<std::string, TObjArray*>::iterator it;
+      std::map<std::string, TObjArray*>::iterator end = fConversionStreamerInfo->end();
+      for( it = fConversionStreamerInfo->begin(); it != end; ++it ) {
+         delete it->second;
+      }
+      delete fConversionStreamerInfo;
+   }
 }
 
 //------------------------------------------------------------------------------
@@ -1672,6 +1680,9 @@
       gCint->CallFunc_SetFuncProto(f,fClassInfo,"Streamer","TBuffer&",&fOffsetStreamer);
       fInterStreamer = f;
       fOffsetStreamer = const_cast<TClass*>(this)->GetBaseClassOffset(TObject::Class());
+      if (fStreamerType == kTObject) {
+         fStreamerImpl = &TClass::StreamerTObjectInitialized;
+      }
    }
 }
 
@@ -4422,6 +4433,7 @@
    TClass *kl = const_cast<TClass*>(this);
 
    kl->fStreamerType = kNone;
+   kl->fStreamerImpl = &TClass::StreamerDefault;
 
    if (InheritsFrom(TObject::Class())) {
       kl->SetBit(kIsTObject);
@@ -4431,6 +4443,7 @@
       if (delta==0) kl->SetBit(kStartWithTObject);
 
       kl->fStreamerType  = kTObject;
+      kl->fStreamerImpl  = &TClass::StreamerTObject;
    }
 
    if (fClassInfo) {
@@ -4442,6 +4455,7 @@
 
          kl->SetBit(kIsForeign);
          kl->fStreamerType  = kForeign;
+         kl->fStreamerImpl  = &TClass::StreamerStreamerInfo;
 
       } else if ( kl->fStreamerType == kNone ) {
          if ( gCint->ClassInfo_FileName(fClassInfo) 
@@ -4449,16 +4463,29 @@
             kl->SetBit(kIsForeign);
          }
          kl->fStreamerType  = kInstrumented;
+         kl->fStreamerImpl   = &TClass::StreamerInstrumented;
       }
 
-      if (fStreamer)   kl->fStreamerType  = kExternal;
+      if (fStreamer) {
+         kl->fStreamerType  = kExternal;
+         kl->fStreamerImpl   = &TClass::StreamerExternal;
+      }
 
    } else {
 
-      if (fStreamer)   kl->fStreamerType  = kExternal;
+      if (fStreamer) {
+         kl->fStreamerType  = kExternal;
+         kl->fStreamerImpl  = &TClass::StreamerExternal;
+      }
 
       kl->fStreamerType |= kEmulated;
-
+      switch (fStreamerType) {
+         case kEmulated:               // intentional fall through
+         case kForeign|kEmulated:      // intentional fall through
+         case kInstrumented|kEmulated: kl->fStreamerImpl = &TClass::StreamerStreamerInfo; break;
+         case kExternal|kEmulated:     kl->fStreamerImpl = &TClass::StreamerExternal; break;
+         case kTObject|kEmulated:      kl->fStreamerImpl = &TClass::StreamerTObjectEmulated; break;
+      }  
       return 0;
    }
 
@@ -4867,6 +4894,138 @@
 }
 
 //______________________________________________________________________________
+void TClass::StreamerExternal(void *object, TBuffer &b, const TClass *onfile_class) const
+{
+   //There is special streamer for the class
+
+   //      case kExternal:
+   //      case kExternal|kEmulated: 
+
+   TClassStreamer *streamer = gThreadTsd ? GetStreamer() : fStreamer;
+   streamer->Stream(b,object,onfile_class);   
+}
+
+//______________________________________________________________________________
+void TClass::StreamerTObject(void *object, TBuffer &b, const TClass * /* onfile_class */) const
+{
+   // Case of TObjects
+
+   // case kTObject:
+
+   if (!fInterStreamer) {
+      CalculateStreamerOffset();
+   }
+   TObject *tobj = (TObject*)((Long_t)object + fOffsetStreamer);
+   tobj->Streamer(b);
+}
+
+//______________________________________________________________________________
+void TClass::StreamerTObjectInitialized(void *object, TBuffer &b, const TClass * /* onfile_class */) const
+{
+   // Case of TObjects when fInterStreamer is known to have been set.
+
+   //     case kTObject: if (fInterStreamer)
+   
+   TObject *tobj = (TObject*)((Long_t)object + fOffsetStreamer);
+   tobj->Streamer(b);   
+}
+
+//______________________________________________________________________________
+void TClass::StreamerTObjectEmulated(void *object, TBuffer &b, const TClass *onfile_class) const
+{
+   // Case of TObjects when we do not have the library defining the class.
+   
+   // case kTObject|kEmulated :
+   if (b.IsReading()) {
+      b.ReadClassEmulated(this, object, onfile_class);
+   } else {
+      b.WriteClassBuffer(this, object);
+   }            
+}
+
+//______________________________________________________________________________
+void TClass::StreamerInstrumented(void *object, TBuffer &b, const TClass * /* onfile_class */) const
+{
+   // Case of instrumented class with a library
+   
+   // case kInstrumented:
+   R__LOCKGUARD2(gCINTMutex);
+   CallFunc_t *func = (CallFunc_t*)fInterStreamer;
+   
+   if (!func)  {
+      // When called via TMapFile (e.g. Update()) make sure that the dictionary
+      // gets allocated on the heap and not in the mapped file.
+      TMmallocDescTemp setreset;
+      func  = gCint->CallFunc_Factory();
+      gCint->CallFunc_SetFuncProto(func,fClassInfo,"Streamer","TBuffer&",&fOffsetStreamer);
+      fInterStreamer = func;
+      fStreamerImpl = &TClass::StreamerInstrumentedInitialized;
+   } else {
+      // Reset the argument list!
+      gCint->CallFunc_SetArgs(func,"");
+   }
+   
+   // set arguments
+   gCint->CallFunc_SetArg(func,(Long_t)&b);
+   // call function
+   gCint->CallFunc_Exec(func,(char*)((Long_t)object + fOffsetStreamer) );
+}
+
+//______________________________________________________________________________
+void TClass::StreamerInstrumentedInitialized(void *object, TBuffer &b, const TClass * /* onfile_class */) const
+{
+   // Case of instrumented class with a library
+   
+   // case kInstrumented:
+   R__LOCKGUARD2(gCINTMutex);
+   CallFunc_t *func = (CallFunc_t*)fInterStreamer;
+   
+   // Reset the argument list!
+   gCint->CallFunc_SetArgs(func,"");   
+   // set arguments
+   gCint->CallFunc_SetArg(func,(Long_t)&b);
+   // call function
+   gCint->CallFunc_Exec(func,(char*)((Long_t)object + fOffsetStreamer) );
+}
+
+//______________________________________________________________________________
+void TClass::StreamerStreamerInfo(void *object, TBuffer &b, const TClass *onfile_class) const
+{
+   // Case of where we should directly use the StreamerInfo.
+   //    case kForeign:
+   //    case kForeign|kEmulated:
+   //    case kInstrumented|kEmulated:
+   //    case kEmulated:
+
+   if (b.IsReading()) {
+      b.ReadClassBuffer(this, object, onfile_class);
+      //ReadBuffer (b, object);
+   } else {
+      //WriteBuffer(b, object);
+      b.WriteClassBuffer(this, object);
+   }
+}
+
+//______________________________________________________________________________
+void TClass::StreamerDefault(void *object, TBuffer &b, const TClass *onfile_class) const
+{
+   // Default streaming in cases where either we have no way to know what to do
+   // or if Property() has not yet been called.
+   
+   if (fProperty==(-1)) {
+      Property();
+      if (fStreamerImpl == &TClass::StreamerDefault) {
+         Fatal("StreamerDefault", "fStreamerImpl not properly initialized (%d)", fStreamerType);        
+      } else {
+         (this->*fStreamerImpl)(object,b,onfile_class);
+      }
+   } else {
+      Fatal("StreamerDefault", "fStreamerType not properly initialized (%d)", fStreamerType);
+   }   
+}
+
+#ifdef OLD_STREAMER
+//______________________________________________________________________________
 void TClass::Streamer(void *object, TBuffer &b, const TClass *onfile_class) const
 {
    // Stream object of this class to or from buffer.
@@ -4877,7 +5036,7 @@
       case kExternal|kEmulated: 
       {
          //There is special streamer for the class
-         TClassStreamer *streamer = GetStreamer();
+         TClassStreamer *streamer = gThreadTsd ? GetStreamer() : fStreamer;
          streamer->SetOnFileClass( onfile_class );
          (*streamer)(b,object);
 
@@ -4954,6 +5113,7 @@
       }
    }
 }
+#endif
 
 //______________________________________________________________________________
 void TClass::AdoptStreamer(TClassStreamer *str)
@@ -4971,13 +5131,16 @@
    if (str) {
       fStreamerType = kExternal | ( fStreamerType&kEmulated );
       fStreamer = str;
+      fStreamerImpl = &TClass::StreamerExternal;
    } else if (fStreamer) {
       // Case where there was a custom streamer and it is hereby removed,
       // we need to reset fStreamerType
       fStreamer = str;
       fStreamerType = kNone;
-      fProperty = -1;
-      Property();
+      if (fProperty != -1) {
+         fProperty = -1;
+         Property();
+      }
    }
 }
 
Index: core/meta/inc/TClass.h
===================================================================
--- core/meta/inc/TClass.h	(revision 35093)
+++ core/meta/inc/TClass.h	(working copy)
@@ -131,6 +131,9 @@
    TVirtualRefProxy  *fRefProxy;        //!Pointer to reference proxy if this class represents a reference
    ROOT::TSchemaRuleSet *fSchemaRules;  //! Schema evolution rules
 
+   typedef void (TClass::*StreamerImpl_t)(void *obj, TBuffer &b, const TClass *onfile_class) const;
+   mutable StreamerImpl_t fStreamerImpl;//! Pointer to the function implementing the right streaming behavior for the class represented by this object.
+
    TMethod           *GetClassMethod(Long_t faddr);
    TMethod           *GetClassMethod(const char *name, const char *signature);
    Int_t              GetBaseClassOffsetRecurse(const TClass *base);
@@ -143,7 +146,17 @@
 
    void               SetClassVersion(Version_t version);
    void               SetClassSize(Int_t sizof) { fSizeof = sizof; }
-
+   
+   // Various implementation for TClass::Stramer
+   void StreamerExternal(void *object, TBuffer &b, const TClass *onfile_class) const;
+   void StreamerTObject(void *object, TBuffer &b, const TClass *onfile_class) const;
+   void StreamerTObjectInitialized(void *object, TBuffer &b, const TClass *onfile_class) const;
+   void StreamerTObjectEmulated(void *object, TBuffer &b, const TClass *onfile_class) const;
+   void StreamerInstrumented(void *object, TBuffer &b, const TClass *onfile_class) const;
+   void StreamerInstrumentedInitialized(void *object, TBuffer &b, const TClass *onfile_class) const;
+   void StreamerStreamerInfo(void *object, TBuffer &b, const TClass *onfile_class) const;
+   void StreamerDefault(void *object, TBuffer &b, const TClass *onfile_class) const;
+   
    static IdMap_t    *fgIdMap;          //Map from typeid to TClass pointer
    static ENewType    fgCallingNew;     //Intent of why/how TClass::New() is called
    static Int_t       fgClassCount;     //provides unique id for a each class
@@ -351,7 +364,11 @@
    void               Destructor(void *obj, Bool_t dtorOnly = kFALSE);
    void              *DynamicCast(const TClass *base, void *obj, Bool_t up = kTRUE);
    Bool_t             IsFolder(void *obj) const;
-   void               Streamer(void *obj, TBuffer &b, const TClass *onfile_class = 0) const;
+   inline void        Streamer(void *obj, TBuffer &b, const TClass *onfile_class = 0) const
+   {
+      // Inline for performance, skipping one function call.
+       (this->*fStreamerImpl)(obj,b,onfile_class);
+   }
 
    ClassDef(TClass,0)  //Dictionary containing class information
 };
Index: core/meta/inc/TClassStreamer.h
===================================================================
--- core/meta/inc/TClassStreamer.h	(revision 35093)
+++ core/meta/inc/TClassStreamer.h	(working copy)
@@ -35,7 +35,7 @@
    virtual void SetOnFileClass( const TClass* cl ) { fOnFileClass = const_cast<TClass*>(cl); }
    virtual const TClass* GetOnFileClass() const { return fOnFileClass; }
 
-   virtual TClassStreamer *Generate() {
+   virtual TClassStreamer *Generate() const {
       // Virtual copy constructor.
       return new TClassStreamer(*this); 
    }
@@ -48,6 +48,23 @@
       
       (*fStreamer)(b,objp);
    }
+   virtual void Stream(TBuffer &b, void *objp, const TClass *onfileClass)
+   {
+      // The address passed to operator() will be the address of the start of the
+      // object.   Overload this routine, if your derived class can optimize
+      // the handling of the onfileClass (rather than storing and restoring from the
+      // fOnFileClass member.
+      
+      // Note we can not name this routine 'operator()' has it would be slightly
+      // backward incompatible and lead to the following warning/error from the
+      // compiler in the derived class overloading the other operator():
+//      include/TClassStreamer.h:51: error: ‘virtual void TClassStreamer::operator()(TBuffer&, void*, const TClass*)’ was hidden
+//      include/TCollectionProxyFactory.h:180: error:   by ‘virtual void TCollectionClassStreamer::operator()(TBuffer&, void*)’
+//   cc1plus: warnings being treated as errors
+      
+      SetOnFileClass(onfileClass);
+      (*fStreamer)(b,objp);
+   }
    
 private:
    ClassStreamerFunc_t fStreamer;
Index: core/meta/inc/TClassRef.h
===================================================================
--- core/meta/inc/TClassRef.h	(revision 35093)
+++ core/meta/inc/TClassRef.h	(working copy)
@@ -40,6 +40,8 @@
 
    friend class TClass;
 
+   void Assign(const TClassRef &);
+   void Assign(TClass *);
    TClass   *InternalGetClass() const;
    void      ListReset();
 public:
@@ -47,8 +49,20 @@
    TClassRef(TClass *cl);
    TClassRef(const char *classname);
    TClassRef(const TClassRef&);
-   TClassRef &operator=(const TClassRef&);
-   TClassRef &operator=(TClass*);
+   inline TClassRef &operator=(const TClassRef &rhs) {
+      // Inline implementation of operator= to speed the no-op case.
+      if (this != &rhs && fClassPtr != rhs.fClassPtr) {
+         this->Assign(rhs);
+      }
+      return *this;
+   }
+   inline TClassRef &operator=(TClass *rhs) {
+      // Inline implementation of operator= to speed the no-op case.
+      if (this->fClassPtr != rhs) {
+         this->Assign(rhs);
+      }
+      return *this;
+   }      
 
    ~TClassRef() { if (fClassPtr) fClassPtr->RemoveRef(this); };
 
Index: core/cont/inc/TCollectionProxyInfo.h
===================================================================
--- core/cont/inc/TCollectionProxyInfo.h	(revision 35093)
+++ core/cont/inc/TCollectionProxyInfo.h	(working copy)
@@ -85,9 +85,6 @@
    struct EnvironBase;
    template <typename T> struct Environ;
 #endif
-#if defined(R__VCXX6)
-   template <class T> void Destruct(T* obj) { obj->~T(); }
-#endif
 
    template <class T, class Q> struct PairHolder {
       T first;
@@ -162,10 +159,9 @@
          TYPENAME T::const_reference ref = *(e->iter());
          return Type<T>::address(ref);
       }
-      static void* construct(void* env)  {
-         PEnv_t  e = PEnv_t(env);
-         PValue_t m = PValue_t(e->fStart);
-         for (size_t i=0; i<e->fSize; ++i, ++m)
+      static void* construct(void *what, size_t size)  {
+         PValue_t m = PValue_t(what);
+         for (size_t i=0; i<size; ++i, ++m)
             ::new(m) Value_t();
          return 0;
       }
@@ -177,18 +173,10 @@
             ::new(m) Value_t(*i);
          return 0;
       }
-      static void* destruct(void* env)  {
-         PEnv_t   e = PEnv_t(env);
-         PValue_t m = PValue_t(e->fStart);
-#if defined(R__VCXX6)
-         PCont_t  c = PCont_t(e->fObject);
-         for (size_t i=0; i < e->fSize; ++i, ++m )
-            ROOT::Destruct(m);
-#else
-         for (size_t i=0; i < e->fSize; ++i, ++m )
+      static void destruct(void *what, size_t size)  {
+         PValue_t m = PValue_t(what);
+         for (size_t i=0; i < size; ++i, ++m )
             m->~Value_t();
-#endif
-         return 0;
       }
    };
 
@@ -209,18 +197,14 @@
       typedef Env_t                 *PEnv_t;
       typedef Cont_t                *PCont_t;
       typedef Value_t               *PValue_t;
-      static void* resize(void* env)  {
-         PEnv_t  e = PEnv_t(env);
-         PCont_t c = PCont_t(e->fObject);
-         c->resize(e->fSize);
-         e->fIdx = 0;
-         return e->fStart = e->fSize ? Type<T>::address(*c->begin()) : 0;
+      static void resize(void* obj, size_t n) {
+         PCont_t c = PCont_t(obj);
+         c->resize(n);
       }
-      static void* feed(void* env)  {
-         PEnv_t   e = PEnv_t(env);
-         PCont_t  c = PCont_t(e->fObject);
-         PValue_t m = PValue_t(e->fStart); // Here start is actually a 'buffer' outside the buffer.
-         for (size_t i=0; i<e->fSize; ++i, ++m)
+      static void* feed(void *from, void *to, size_t size)  {
+         PCont_t  c = PCont_t(to);
+         PValue_t m = PValue_t(from);
+         for (size_t i=0; i<size; ++i, ++m)
             c->push_back(*m);
          return 0;
       }
@@ -246,16 +230,15 @@
       typedef Env_t                 *PEnv_t;
       typedef Cont_t                *PCont_t;
       typedef Value_t               *PValue_t;
-      static void* feed(void* env)  {
-         PEnv_t   e = PEnv_t(env);
-         PCont_t  c = PCont_t(e->fObject);
-         PValue_t m = PValue_t(e->fStart);
-         for (size_t i=0; i<e->fSize; ++i, ++m)
+      static void* feed(void *from, void *to, size_t size)  {
+         PCont_t  c = PCont_t(to);
+         PValue_t m = PValue_t(from);
+         for (size_t i=0; i<size; ++i, ++m)
             c->insert(*m);
          return 0;
       }
-      static void* resize(void* /* env */ )  {
-         return 0;
+      static void resize(void* /* obj */, size_t )  {
+         ;
       }
       static int value_offset()  {
          return 0;
@@ -279,16 +262,15 @@
       typedef Env_t                 *PEnv_t;
       typedef Cont_t                *PCont_t;
       typedef Value_t               *PValue_t;
-      static void* feed(void* env)  {
-         PEnv_t   e = PEnv_t(env);
-         PCont_t  c = PCont_t(e->fObject);
-         PValue_t m = PValue_t(e->fStart);
-         for (size_t i=0; i<e->fSize; ++i, ++m)
+      static void* feed(void *from, void *to, size_t size)  {
+         PCont_t  c = PCont_t(to);
+         PValue_t m = PValue_t(from);
+         for (size_t i=0; i<size; ++i, ++m)
             c->insert(*m);
          return 0;
       }
-      static void* resize(void* /* env */ )  {
-         return 0;
+      static void resize(void* /* obj */, size_t )  {
+         ;
       }
       static int value_offset()  {
          return ((char*)&((PValue_t(0x1000))->second)) - ((char*)PValue_t(0x1000));
@@ -304,29 +286,51 @@
       size_t fValueDiff;
       int    fValueOffset;
       void*  (*fSizeFunc)(void*);
-      void*  (*fResizeFunc)(void*);
+      void   (*fResizeFunc)(void*,size_t);
       void*  (*fClearFunc)(void*);
       void*  (*fFirstFunc)(void*);
       void*  (*fNextFunc)(void*);
-      void*  (*fConstructFunc)(void*);
-      void*  (*fDestructFunc)(void*);
-      void*  (*fFeedFunc)(void*);
+      void*  (*fConstructFunc)(void*,size_t);
+      void   (*fDestructFunc)(void*,size_t);
+      void*  (*fFeedFunc)(void*,void*,size_t);
       void*  (*fCollectFunc)(void*);
       void*  (*fCreateEnv)();
-
+      
+      // Set of function of direct iteration of the collections.
+      void (*fGetIterators)(void *collection, void *&begin_arena, void *&end_arena); 
+      // begin_arena and end_arena should contain the location of memory arena  of size fgIteratorSize. 
+      // If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement)
+      // Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena.
+      
+      void (*fCopyIterator)(void *&dest, const void *source);
+      // Copy the iterator source, into dest.   dest should contain should contain the location of memory arena  of size fgIteratorSize.
+      // If the collection iterator are of that size or less, the iterator will be constructed in place in this location (new with placement)
+      // Otherwise the iterator will be allocated via a regular new and its address returned by modifying the value of dest.
+      
+      void* (*fNext)(void *iter, void *end);
+      // iter and end should be pointer to respectively an iterator to be incremented and the result of colleciton.end()
+      // 'Next' will increment the iterator 'iter' and return 0 if the iterator reached the end.
+      // If the end is not reached, 'Next' will return the address of the content unless the collection contains pointers in
+      // which case 'Next' will return the value of the pointer.
+      
+      void (*fDeleteSingleIterator)(void *iter);
+      void (*fDeleteTwoIterators)(void *begin, void *end);
+      // If the sizeof iterator is greater than fgIteratorArenaSize, call delete on the addresses,
+      // Otherwise just call the iterator's destructor.
+      
    public:
       TCollectionProxyInfo(const type_info& info,
                            size_t iter_size,
                            size_t value_diff,
                            int    value_offset,
                            void*  (*size_func)(void*),
-                           void*  (*resize_func)(void*),
+                           void   (*resize_func)(void*,size_t),
                            void*  (*clear_func)(void*),
                            void*  (*first_func)(void*),
                            void*  (*next_func)(void*),
-                           void*  (*construct_func)(void*),
-                           void*  (*destruct_func)(void*),
-                           void*  (*feed_func)(void*),
+                           void*  (*construct_func)(void*,size_t),
+                           void   (*destruct_func)(void*,size_t),
+                           void*  (*feed_func)(void*,void*,size_t),
                            void*  (*collect_func)(void*),
                            void*  (*create_env)()
                            ) :
@@ -335,7 +339,8 @@
          fSizeFunc(size_func),fResizeFunc(resize_func),fClearFunc(clear_func),
          fFirstFunc(first_func),fNextFunc(next_func),fConstructFunc(construct_func),
          fDestructFunc(destruct_func),fFeedFunc(feed_func),fCollectFunc(collect_func),
-         fCreateEnv(create_env)
+         fCreateEnv(create_env),
+         fGetIterators(0),fCopyIterator(0),fNext(0),fDeleteSingleIterator(0),fDeleteTwoIterators(0)
       {
       }
  
@@ -434,7 +439,7 @@
          // TODO: Need to find something for going backwards....
          return 0;
       }
-      static void* construct(void*)  {
+      static void* construct(void*,size_t)  {
          // Nothing to construct.
          return 0;
       }
@@ -446,9 +451,8 @@
             ::new(m) Value_t(*i);
          return 0;
       }
-      static void* destruct(void*)  {
+      static void destruct(void*,size_t)  {
          // Nothing to destruct.
-         return 0;
       }
    };
    
@@ -461,18 +465,14 @@
       typedef Cont_t                *PCont_t;
       typedef Value_t               *PValue_t;
       
-      static void* resize(void* env)  {
-         PEnv_t  e = PEnv_t(env);
-         PCont_t c = PCont_t(e->fObject);
-         c->resize(e->fSize);
-         e->fIdx = 0;
-         return 0;
+      static void resize(void* obj,size_t n) {
+         PCont_t c = PCont_t(obj);
+         c->resize(n);
       }
-      static void* feed(void* env)  {
-         PEnv_t   e = PEnv_t(env);
-         PCont_t  c = PCont_t(e->fObject);
-         PValue_t m = PValue_t(e->fStart); // Here start is actually a 'buffer' outside the container.
-         for (size_t i=0; i<e->fSize; ++i, ++m)
+      static void* feed(void* from, void *to, size_t size)  {
+         PCont_t  c = PCont_t(to);
+         PValue_t m = PValue_t(from);
+         for (size_t i=0; i<size; ++i, ++m)
             c->push_back(*m);
          return 0;
       }
@@ -535,7 +535,7 @@
          e->fIterator.second = (e->fIterator.first != c->size()) ? c->test(e->fIterator.first) : false;
          return 0;
       }
-      static void* construct(void*)  {
+      static void* construct(void*,size_t)  {
          // Nothing to construct.
          return 0;
       }
@@ -547,9 +547,8 @@
             *m = c->test(i);
          return 0;
       }
-      static void* destruct(void*)  {
+      static void destruct(void*,size_t)  {
          // Nothing to destruct.
-         return 0;
       }
    };
    
@@ -563,16 +562,12 @@
       typedef Cont_t          *PCont_t;
       typedef Value_t         *PValue_t;
       
-      static void* resize(void* env)  {
-         PEnv_t  e = PEnv_t(env);
-         e->fIdx = 0;
-         return 0;
+      static void resize(void*,size_t)  {
       }
-      static void* feed(void* env)  {
-         PEnv_t   e = PEnv_t(env);
-         PCont_t  c = PCont_t(e->fObject);
-         PValue_t m = PValue_t(e->fStart); // Here start is actually a 'buffer' outside the container.
-         for (size_t i=0; i<e->fSize; ++i, ++m)
+      static void* feed(void *from, void *to, size_t size)  {
+         PCont_t  c = PCont_t(to);
+         PValue_t m = PValue_t(from); 
+         for (size_t i=0; i<size; ++i, ++m)
             c->set(i,*m);
          return 0;
       }
Index: core/cont/inc/TVirtualCollectionProxy.h
===================================================================
--- core/cont/inc/TVirtualCollectionProxy.h	(revision 35093)
+++ core/cont/inc/TVirtualCollectionProxy.h	(working copy)
@@ -9,8 +9,8 @@
  * For the list of contributors see $ROOTSYS/README/CREDITS.             *
  *************************************************************************/
 
-#ifndef Root_TVirtualCollectionProxy
-#define Root_TVirtualCollectionProxy
+#ifndef ROOT_TVirtualCollectionProxy
+#define ROOT_TVirtualCollectionProxy
 
 //////////////////////////////////////////////////////////////////////////
 //                                                                      //
@@ -22,10 +22,16 @@
 //                                                                      //
 //////////////////////////////////////////////////////////////////////////
 
+#ifndef ROOT_TObject
+#include "TObject.h"
+#endif
 #include "TClassRef.h"
 #include "TDataType.h"
 
 class TClass;
+namespace TStreamerInfoActions {
+   class TActionSequence;
+}
 
 class TVirtualCollectionProxy {
 private:
@@ -34,10 +40,17 @@
 
 protected:
    TClassRef fClass;
+   UInt_t    fProperties;
    virtual void SetValueClass(TClass *newcl) = 0;
    friend class TClass;
 
 public:
+   enum EProperty {
+      kIsInitialized = BIT(1),
+      kIsAssociative = BIT(2),
+      kIsEmulated    = BIT(3)
+   };
+   
    class TPushPop {
       // Helper class that insures that push and pop are done when entering
       // and leaving a C++ context (even in the presence of exceptions)
@@ -51,52 +64,123 @@
       TPushPop& operator=(const TPushPop&); // Not implemented
    };
 
-   TVirtualCollectionProxy() : fClass() {};
-   TVirtualCollectionProxy(TClass *cl) : fClass(cl) {};
+   TVirtualCollectionProxy() : fClass(), fProperties(0) {};
+   TVirtualCollectionProxy(TClass *cl) : fClass(cl), fProperties(0) {};
   
    virtual TVirtualCollectionProxy* Generate() const = 0; // Returns an object of the actual CollectionProxy class
    virtual ~TVirtualCollectionProxy() {};
-   virtual TClass   *GetCollectionClass() { return fClass; } // Return a pointer to the TClass representing the container
 
-   virtual void     *New() const {                // Return a new container object
-     return fClass.GetClass()==0 ? 0 : fClass->New();
+   virtual TClass   *GetCollectionClass() { return fClass; } 
+   // Return a pointer to the TClass representing the container
+   
+   virtual Int_t     GetCollectionType() = 0;                
+   // Return the type of collection see TClassEdit::ESTLType
+   
+   virtual ULong_t   GetIncrement() = 0;
+   // Return the offset between two consecutive value_types (memory layout).
+
+   virtual Int_t     GetProperties() { return fProperties; } 
+   // Return miscallenous properties of the proxy see TVirtualCollectionProxy::EProperty
+
+   virtual void     *New() const {
+      // Return a new container object
+      return fClass.GetClass()==0 ? 0 : fClass->New();
    }
-   virtual void     *New(void *arena) const {     // Execute the container constructor
-     return fClass.GetClass()==0 ? 0 : fClass->New(arena);
+   virtual void     *New(void *arena) const {
+      // Execute the container constructor
+      return fClass.GetClass()==0 ? 0 : fClass->New(arena);
    }
 
-   virtual void     *NewArray(Int_t nElements) const {                // Return a new container object
-     return fClass.GetClass()==0 ? 0 : fClass->NewArray(nElements);
+   virtual void     *NewArray(Int_t nElements) const {
+      // Return a new container object
+      return fClass.GetClass()==0 ? 0 : fClass->NewArray(nElements);
    }
-   virtual void     *NewArray(Int_t nElements, void *arena) const {     // Execute the container constructor
-     return fClass.GetClass()==0 ? 0 : fClass->NewArray(nElements, arena);
+   virtual void     *NewArray(Int_t nElements, void *arena) const {
+      // Execute the container constructor
+      return fClass.GetClass()==0 ? 0 : fClass->NewArray(nElements, arena);
    }
 
-   virtual void      Destructor(void *p, Bool_t dtorOnly = kFALSE) { // Execute the container destructor
-     TClass* cl = fClass.GetClass();
-     if (cl) cl->Destructor(p, dtorOnly);
+   virtual void      Destructor(void *p, Bool_t dtorOnly = kFALSE) {
+      // Execute the container destructor
+      TClass* cl = fClass.GetClass();
+      if (cl) cl->Destructor(p, dtorOnly);
    }
 
-   virtual void      DeleteArray(void *p, Bool_t dtorOnly = kFALSE) { // Execute the container array destructor
-     TClass* cl = fClass.GetClass();
-     if (cl) cl->DeleteArray(p, dtorOnly);
+   virtual void      DeleteArray(void *p, Bool_t dtorOnly = kFALSE) { 
+      // Execute the container array destructor
+      TClass* cl = fClass.GetClass();
+      if (cl) cl->DeleteArray(p, dtorOnly);
    }
 
-   virtual UInt_t    Sizeof() const = 0; // Return the sizeof the collection object.
+   virtual UInt_t    Sizeof() const = 0;
+   // Return the sizeof the collection object.
+   
+   virtual void      PushProxy(void *objectstart) = 0;
+   // Set the address of the container being proxied and keep track of the previous one.
+   
+   virtual void      PopProxy() = 0;             
+   // Reset the address of the container being proxied to the previous container
 
-   virtual void      PushProxy(void *objectstart) = 0; // Set the address of the container being proxied and keep track of the previous one.
-   virtual void      PopProxy() = 0;                   // Reset the address of the container being proxied to the previous container
+   virtual Bool_t    HasPointers() const = 0;
+   // Return true if the content is of type 'pointer to'
 
-   virtual Bool_t    HasPointers() const = 0; // Return true if the content is of type 'pointer to'
+   virtual TClass   *GetValueClass() = 0;
+   // Return a pointer to the TClass representing the content.
 
-   virtual TClass   *GetValueClass() = 0;     // Return a pointer to the TClass representing the content.
-   virtual EDataType GetType() = 0;           // If the content is a simple numerical value, return its type (see TDataType)
-   virtual void     *At(UInt_t idx) = 0;                       // Return the address of the value at index 'idx'
-   virtual void      Clear(const char *opt = "") = 0;          // Clear the container
-   virtual UInt_t    Size() const = 0;                         // Return the current size of the container
+   virtual EDataType GetType() = 0;
+   // If the content is a simple numerical value, return its type (see TDataType)
+
+   virtual void     *At(UInt_t idx) = 0;
+   // Return the address of the value at index 'idx'
+
+   virtual void      Clear(const char *opt = "") = 0;
+   // Clear the container
+   
+   virtual UInt_t    Size() const = 0;
+   // Return the current size of the container
+
    virtual void*     Allocate(UInt_t n, Bool_t forceDelete) = 0;
+   
    virtual void      Commit(void*) = 0;
+
            char     *operator[](UInt_t idx) const { return (char*)(const_cast<TVirtualCollectionProxy*>(this))->At(idx); }
+   
+   // MemberWise actions
+   virtual TStreamerInfoActions::TActionSequence *GetConversionReadMemberWiseActions(TClass *oldClass, Int_t version) = 0;
+   virtual TStreamerInfoActions::TActionSequence *GetReadMemberWiseActions(Int_t version) = 0;
+   virtual TStreamerInfoActions::TActionSequence *GetWriteMemberWiseActions() = 0;
+   
+   // Set of functions to iterate easily throught the collection
+   static const Int_t fgIteratorArenaSize = 16; // greater than sizeof(void*) + sizeof(UInt_t)
+
+   typedef void (*CreateIterators_t)(void *collection, void **begin_arena, void **end_arena);
+   virtual CreateIterators_t GetFunctionCreateIterators(Bool_t read = kTRUE) = 0; 
+   // begin_arena and end_arena should contain the location of memory arena  of size fgIteratorSize. 
+   // If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement)
+   // Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena.
+   
+   typedef void* (*CopyIterator_t)(void *dest, const void *source);
+   virtual CopyIterator_t GetFunctionCopyIterator(Bool_t read = kTRUE) = 0;
+   // Copy the iterator source, into dest.   dest should contain should contain the location of memory arena  of size fgIteratorSize.
+   // If the collection iterator are of that size or less, the iterator will be constructed in place in this location (new with placement)
+   // Otherwise the iterator will be allocated via a regular new and its address returned by modifying the value of dest.
+   
+   typedef void* (*Next_t)(void *iter, const void *end);
+   virtual Next_t GetFunctionNext(Bool_t read = kTRUE) = 0;
+   // iter and end should be pointer to respectively an iterator to be incremented and the result of collection.end()
+   // If the iterator has not reached the end of the collection, 'Next' increment the iterator 'iter' and return 0 if 
+   // the iterator reached the end.
+   // If the end was not reached, 'Next' returns the address of the content pointed to by the iterator before the 
+   // incrementation ; if the collection contains pointers 'Next' will return the value of the pointer.
+   
+   typedef void (*DeleteIterator_t)(void *iter);
+   typedef void (*DeleteTwoIterators_t)(void *begin, void *end);
+
+   virtual DeleteIterator_t GetFunctionDeleteIterator(Bool_t read = kTRUE) = 0;
+   virtual DeleteTwoIterators_t GetFunctionDeleteTwoIterators(Bool_t read = kTRUE) = 0;
+   // If the sizeof iterator is greater than fgIteratorArenaSize, call delete on the addresses,
+   // Otherwise just call the iterator's destructor.
+   
 };
 
 #endif
Index: core/base/src/String.cxx
===================================================================
--- core/base/src/String.cxx	(revision 35093)
+++ core/base/src/String.cxx	(working copy)
@@ -30,20 +30,24 @@
    UChar_t nwh;
    if (b.IsReading()) {
       b >> nwh;
-
-      if( obj->size() ) {
-         // Insure that the underlying data storage is not shared
-         (*obj)[0] = '\0';
+      ;
+      if (nwh == 0)  {
+         obj->clear();
+      } else {
+         if( obj->size() ) {
+            // Insure that the underlying data storage is not shared
+            (*obj)[0] = '\0';
+         }
+         if (nwh == 255)  {
+            b >> nbig;
+            obj->resize(nbig,'\0');
+            b.ReadFastArray((char*)obj->data(),nbig);
+         }
+         else  {
+            obj->resize(nwh,'\0');
+            b.ReadFastArray((char*)obj->data(),nwh);
+         }
       }
-      if (nwh == 255)  {
-         b >> nbig;
-         obj->resize(nbig,'\0');
-         b.ReadFastArray((char*)obj->data(),nbig);
-      }
-      else  {
-         obj->resize(nwh,'\0');
-         b.ReadFastArray((char*)obj->data(),nwh);
-      }
    } else if ( obj ) {
       nbig = obj->length();
       if (nbig > 254) {
Index: core/base/src/TBuffer.cxx
===================================================================
--- core/base/src/TBuffer.cxx	(revision 35093)
+++ core/base/src/TBuffer.cxx	(working copy)
@@ -288,3 +288,34 @@
 
    return 0;
 }
+
+//______________________________________________________________________________
+void TBuffer::PushDataCache(TVirtualArray *obj)
+{
+   // Push a new data cache area onto the list of area to be used for
+   // temporarily store 'missing' data members.
+   
+   fCacheStack.push_back(obj);
+}
+
+//______________________________________________________________________________
+TVirtualArray *TBuffer::PeekDataCache() const
+{
+   // Return the 'current' data cache area from the list of area to be used for
+   // temporarily store 'missing' data members.
+   
+   if (fCacheStack.empty()) return 0;
+   return fCacheStack.back();
+}
+
+//______________________________________________________________________________
+TVirtualArray *TBuffer::PopDataCache()
+{
+   // Pop and Return the 'current' data cache area from the list of area to be used for
+   // temporarily store 'missing' data members.
+   
+   TVirtualArray *val = PeekDataCache();
+   fCacheStack.pop_back();
+   return val;
+}
+
Index: core/base/src/TString.cxx
===================================================================
--- core/base/src/TString.cxx	(revision 35093)
+++ core/base/src/TString.cxx	(working copy)
@@ -1089,14 +1089,37 @@
    UChar_t nwh;
    if (b.IsReading()) {
       b >> nwh;
-      if (nwh == 255)
-         b >> nbig;
-      else
-         nbig = nwh;
-      Pref()->UnLink();
-      fData = TStringRef::GetRep(nbig,nbig)->Data();
-      b.ReadFastArray(fData,nbig);
-      //for (int i = 0; i < nbig; i++) b >> fData[i];
+      if (nwh == 0) {
+         if (Pref()->References() > 1) {
+            Pref()->UnLink();
+            gNullStringRef->AddReference();
+            fData = gNullStringRef->Data();
+         } else {
+            // Clear string without changing its capacity.
+            fData[Pref()->fNchars = 0] = 0;
+         }
+      } else {
+         if (nwh == 255)
+            b >> nbig;
+         else
+            nbig = nwh;
+
+         if (Pref()->References() > 1 ||
+             Capacity() < nbig ||
+             Capacity() - nbig > GetMaxWaste()) {
+
+            Pref()->UnLink();
+            // We trying to optimize the I/O of TNamed in particular, so we duplicate
+            // some of the code in TStringRef::GetRep to save on the 'if statement'
+            // at the start of the function.
+            TStringRef *ret = (TStringRef*)new char[nbig + sizeof(TStringRef) + 1];
+            ret->fCapacity = nbig;
+            ret->SetRefCount(1);
+            fData = ret->Data();
+         }
+         fData[Pref()->fNchars = nbig] = 0; // Terminating null
+         b.ReadFastArray(fData,nbig);
+      }
    } else {
       nbig = Length();
       if (nbig > 254) {
Index: core/base/src/TObject.cxx
===================================================================
--- core/base/src/TObject.cxx	(revision 35093)
+++ core/base/src/TObject.cxx	(working copy)
@@ -801,7 +801,7 @@
    if (IsA()->CanIgnoreTObjectStreamer()) return;
    UShort_t pidf;
    if (R__b.IsReading()) {
-      Version_t R__v = R__b.ReadVersion(); if (R__v) { }
+      R__b.SkipVersion(); // Version_t R__v = R__b.ReadVersion(); if (R__v) { }
       R__b >> fUniqueID;
       R__b >> fBits;
       fBits |= kIsOnHeap;  // by definition de-serialized object is on heap
Index: core/base/inc/TBuffer.h
===================================================================
--- core/base/inc/TBuffer.h	(revision 35093)
+++ core/base/inc/TBuffer.h	(working copy)
@@ -32,10 +32,13 @@
 class TProcessID;
 class TClonesArray;
 class TRefTable;
+class TVirtualArray;
 
 class TBuffer : public TObject {
 
 protected:
+   typedef std::vector<TVirtualArray*> CacheList_t;
+
    Bool_t           fMode;          //Read or write mode
    Int_t            fVersion;       //Buffer format version
    Int_t            fBufSize;       //Size of buffer
@@ -44,6 +47,7 @@
    char            *fBufMax;        //End of buffer
    TObject         *fParent;        //Pointer to parent object owning this buffer
    ReAllocCharFun_t fReAllocFunc;   //! Realloc function to be used when extending the buffer.
+   CacheList_t      fCacheStack;    //Stack of pointers to the cache where to temporarily store the value of 'missing' data members
 
    // Default ctor
    TBuffer() : TObject(), fMode(0), fVersion(0), fBufSize(0), fBuffer(0),
@@ -112,6 +116,7 @@
    virtual Int_t      CheckByteCount(UInt_t startpos, UInt_t bcnt, const char *classname) = 0;
    virtual void       SetByteCount(UInt_t cntpos, Bool_t packInVersion = kFALSE)= 0;
 
+   virtual void       SkipVersion(const TClass *cl = 0) = 0;
    virtual Version_t  ReadVersion(UInt_t *start = 0, UInt_t *bcnt = 0, const TClass *cl = 0) = 0;
    virtual UInt_t     WriteVersion(const TClass *cl, Bool_t useBcnt = kFALSE) = 0;
    virtual UInt_t     WriteVersionMemberWise(const TClass *cl, Bool_t useBcnt = kFALSE) = 0;
@@ -128,6 +133,10 @@
    virtual void       ClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1) = 0;
    virtual TVirtualStreamerInfo *GetInfo() = 0;
 
+   virtual TVirtualArray *PeekDataCache() const;
+   virtual TVirtualArray *PopDataCache();
+   virtual void           PushDataCache(TVirtualArray *);
+   
    virtual TClass    *ReadClass(const TClass *cl = 0, UInt_t *objTag = 0) = 0;
    virtual void       WriteClass(const TClass *cl) = 0;
 
@@ -147,6 +156,10 @@
    virtual   void     WriteFloat16(Float_t *f, TStreamerElement *ele=0) = 0;
    virtual   void     ReadDouble32 (Double_t *d, TStreamerElement *ele=0) = 0;
    virtual   void     WriteDouble32(Double_t *d, TStreamerElement *ele=0) = 0;
+   virtual   void     ReadWithFactor(Float_t *ptr, Double_t factor, Double_t minvalue) = 0;
+   virtual   void     ReadWithNbits(Float_t *ptr, Int_t nbits) = 0;
+   virtual   void     ReadWithFactor(Double_t *ptr, Double_t factor, Double_t minvalue) = 0;
+   virtual   void     ReadWithNbits(Double_t *ptr, Int_t nbits) = 0;
 
    virtual   Int_t    ReadArray(Bool_t    *&b) = 0;
    virtual   Int_t    ReadArray(Char_t    *&c) = 0;
Index: cint/reflex/inc/Reflex/Builder/CollectionProxy.h
===================================================================
--- cint/reflex/inc/Reflex/Builder/CollectionProxy.h	(revision 35093)
+++ cint/reflex/inc/Reflex/Builder/CollectionProxy.h	(working copy)
@@ -170,11 +170,10 @@
 
 
    static void*
-   construct(void* env) {
-      PEnv_t e = PEnv_t(env);
-      PValue_t m = PValue_t(e->fStart);
+   construct(void* what, size_t size) {
+      PValue_t m = PValue_t(what);
 
-      for (size_t i = 0; i < e->fSize; ++i, ++m) {
+      for (size_t i = 0; i < size; ++i, ++m) {
          ::new (m) Value_t();
       }
       return 0;
@@ -194,15 +193,13 @@
    }
 
 
-   static void*
-   destruct(void* env) {
-      PEnv_t e = PEnv_t(env);
-      PValue_t m = PValue_t(e->fStart);
+   static void
+   destruct(void* what, size_t size) {
+      PValue_t m = PValue_t(what);
 
-      for (size_t i = 0; i < e->fSize; ++i, ++m) {
+      for (size_t i = 0; i < size; ++i, ++m) {
          m->~Value_t();
       }
-      return 0;
    }
 
 
@@ -225,23 +222,17 @@
    typedef Env_t* PEnv_t;
    typedef Cont_t* PCont_t;
    typedef Value_t* PValue_t;
-   static void*
-   resize(void* env) {
-      PEnv_t e = PEnv_t(env);
-      PCont_t c = PCont_t(e->fObject);
-      c->resize(e->fSize);
-      e->fIdx = 0;
-      return e->fStart = address(*c->begin());
+   static void resize(void* obj, size_t n) {
+      PCont_t c = PCont_t(obj);
+      c->resize(n);
    }
 
-
    static void*
-   feed(void* env) {
-      PEnv_t e = PEnv_t(env);
-      PCont_t c = PCont_t(e->fObject);
-      PValue_t m = PValue_t(e->fStart);
+      feed(void*from,void *to,size_t size) {
+      PValue_t m = PValue_t(from);
+      PCont_t c  = PCont_t(to);
 
-      for (size_t i = 0; i < e->fSize; ++i, ++m) {
+      for (size_t i = 0; i < size; ++i, ++m) {
          c->push_back(*m);
       }
       return 0;
@@ -273,21 +264,20 @@
    typedef Env_t* PEnv_t;
    typedef Cont_t* PCont_t;
    typedef Value_t* PValue_t;
+
    static void*
-   feed(void* env) {
-      PEnv_t e = PEnv_t(env);
-      PCont_t c = PCont_t(e->fObject);
-      PValue_t m = PValue_t(e->fStart);
+      feed(void*from,void*to,size_t size) {
+      PValue_t m = PValue_t(from);
+      PCont_t c  = PCont_t(to);
 
-      for (size_t i = 0; i < e->fSize; ++i, ++m) {
+      for (size_t i = 0; i < size; ++i, ++m) {
          c->insert(*m);
       }
       return 0;
    }
 
 
-   static void*
-   resize(void* /* env */) {
+   static void resize(void* /* obj */, size_t) {
       return 0;
    }
 
@@ -317,21 +307,20 @@
    typedef Env_t* PEnv_t;
    typedef Cont_t* PCont_t;
    typedef Value_t* PValue_t;
+
    static void*
-   feed(void* env) {
-      PEnv_t e = PEnv_t(env);
-      PCont_t c = PCont_t(e->fObject);
-      PValue_t m = PValue_t(e->fStart);
+      feed(void*from,void *to,size_t size) {
+      PValue_t m = PValue_t(from);
+      PCont_t  c = PCont_t(to);
 
-      for (size_t i = 0; i < e->fSize; ++i, ++m) {
+      for (size_t i = 0; i < size; ++i, ++m) {
          c->insert(*m);
       }
       return 0;
    }
 
 
-   static void*
-   resize(void* /* env */) {
+   static void resize(void* /* obj */, size_t) {
       return 0;
    }
 
@@ -370,13 +359,13 @@
    size_t value_diff;
    int value_offset;
    void*  (*size_func)(void*);
-   void*  (*resize_func)(void*);
+   void   (*resize_func)(void*,size_t);
    void*  (*clear_func)(void*);
    void*  (*first_func)(void*);
    void*  (*next_func)(void*);
-   void*  (*construct_func)(void*);
-   void*  (*destruct_func)(void*);
-   void*  (*feed_func)(void*);
+   void*  (*construct_func)(void*,size_t);
+   void   (*destruct_func)(void*,size_t);
+   void*  (*feed_func)(void*,void*,size_t);
    void*  (*collect_func)(void*);
    void*  (*create_env)();
 };
@@ -416,6 +405,15 @@
    static void*
    Void_func0() { return 0; }
 
+   static void
+   Void_func2b(void*,size_t) { ; }
+
+   static void*
+   Void_func2(void*,size_t) { return 0; }
+
+   static void*
+   Void_func3(void*,void*,size_t) { return 0; }
+
    static CollFuncTable*
    Generate() {
       CollFuncTable* p = new CollFuncTable();
@@ -426,11 +424,11 @@
       p->first_func = Void_func;
       p->next_func = Void_func;
       p->clear_func = Void_func;
-      p->resize_func = Void_func;
+      p->resize_func = Void_func2b;
       p->collect_func = Void_func;
-      p->construct_func = Void_func;
-      p->destruct_func = Void_func;
-      p->feed_func = Void_func;
+      p->construct_func = Void_func2;
+      p->destruct_func = Void_func2b;
+      p->feed_func = Void_func3;
       p->create_env = Void_func0;
       return p;
    } // Generate
@@ -651,7 +649,7 @@
 
 
    static void*
-   construct(void*) {
+   construct(void*,size_t) {
       // Nothing to construct.
       return 0;
    }
@@ -670,10 +668,9 @@
    }
 
 
-   static void*
-   destruct(void*) {
+   static void
+   destruct(void*,size_t) {
       // Nothing to destruct.
-      return 0;
    }
 
 
@@ -689,11 +686,7 @@
    typedef Cont_t* PCont_t;
    typedef Value_t* PValue_t;
 
-   static void*
-   resize(void* env) {
-      PEnv_t e = PEnv_t(env);
-      e->fIdx = 0;
-      return 0;
+   static void resize(void* obj, size_t n) {
    }
 
 
@@ -709,7 +702,18 @@
       return 0;
    }
 
+   static void*
+      feed(void* from, void* to, size_t size) {
+      PValue_t m = PValue_t(from);
+      PCont_t c  = PCont_t(to);
 
+      for (size_t i = 0; i < size; ++i, ++m) {
+         c->set(i, *m);
+      }
+      return 0;
+   }
+
+
    static int
    value_offset() {
       return 0;
Index: tree/tree/src/TBranchElement.cxx
===================================================================
--- tree/tree/src/TBranchElement.cxx	(revision 35093)
+++ tree/tree/src/TBranchElement.cxx	(working copy)
@@ -38,12 +38,15 @@
 #include "TStreamerInfo.h"
 #include "TTree.h"
 #include "TVirtualCollectionProxy.h"
+#include "TVirtualCollectionIterators.h"
 #include "TVirtualPad.h"
 #include "TBranchSTL.h"
 #include "TVirtualArray.h"
 #include "TBufferFile.h"
 #include "TInterpreter.h"
 
+#include "TStreamerInfoActions.h"
+
 ClassImp(TBranchElement)
 
 //______________________________________________________________________________
@@ -78,8 +81,12 @@
       TBranchElement* br = (TBranchElement*) branches->At(i);
       switch (br->GetType()) {
          case 31: br->SetType(41); break;
-         case 41: br->SetType(31); break;
-      };
+         case 41: {
+            br->SetType(31); 
+            br->fCollProxy = 0;
+            break;
+         }
+      }
       br->SetReadLeavesPtr();
       // Note: This is a tail recursion.
       SwitchContainer(br->GetListOfBranches());
@@ -139,6 +146,8 @@
 , fBranchClass()
 , fBranchOffset(0)
 , fBranchID(-1)
+, fReadActionSequence(0)
+, fIterators(0)
 {
    // -- Default and I/O constructor.
    fNleaves = 0;
@@ -173,6 +182,8 @@
 , fBranchClass(sinfo->GetClass())
 , fBranchOffset(0)
 , fBranchID(-1)
+, fReadActionSequence(0)
+, fIterators(0)
 {
    // -- Constructor when the branch object is not a TClonesArray nor an STL container.
    //
@@ -209,6 +220,8 @@
 , fBranchClass(sinfo->GetClass())
 , fBranchOffset(0)
 , fBranchID(-1)
+, fReadActionSequence(0)
+, fIterators(0)
 {
    // -- Constructor when the branch object is not a TClonesArray nor an STL container.
    //
@@ -560,7 +573,8 @@
             if (err >= 0) {
                // Return on success.
                // FIXME: Why not on error too?
-               return;
+               SetReadLeavesPtr();
+              return;
             }
          }
       }
@@ -599,6 +613,8 @@
 , fParentClass()
 , fBranchClass(TClonesArray::Class())
 , fBranchID(-1)
+, fReadActionSequence(0)
+, fIterators(0)
 {
    // -- Constructor when the branch object is a TClonesArray.
    //
@@ -618,6 +634,8 @@
 , fParentClass()
 , fBranchClass(TClonesArray::Class())
 , fBranchID(-1)
+, fReadActionSequence(0)
+, fIterators(0)
 {
    // -- Constructor when the branch object is a TClonesArray.
    //
@@ -729,6 +747,8 @@
 , fParentClass()
 , fBranchClass(cont->GetCollectionClass())
 , fBranchID(-1)
+, fReadActionSequence(0)
+, fIterators(0)
 {
    // -- Constructor when the branch object is an STL collection.
    //
@@ -747,6 +767,8 @@
 , fParentClass()
 , fBranchClass(cont->GetCollectionClass())
 , fBranchID(-1)
+, fReadActionSequence(0)
+, fIterators(0)
 {
    // -- Constructor when the branch object is an STL collection.
    //
@@ -880,6 +902,9 @@
       delete fCollProxy;
    }
    fCollProxy = 0;
+   
+   delete fReadActionSequence;
+   delete fIterators;
 }
 
 //
@@ -1719,7 +1744,14 @@
             }
          }
          fInit = kTRUE;
+
+         // Get the action sequence we need to copy for reading.
+         SetReadActionSequence();
+      } else if (!fReadActionSequence) {
+         // Get the action sequence we need to copy for reading.
+         SetReadActionSequence();
       }
+      SetReadLeavesPtr();
    }
 }
 
@@ -2611,9 +2643,9 @@
             //
             // Compensate for the i/o routines adding our local offset later.
             if (subBranch->fObject == 0 && localOffset == TStreamerInfo::kMissing) {
-               subBranch->fOffset = TStreamerInfo::kMissing;
+               subBranch->SetOffset(TStreamerInfo::kMissing);
             } else {
-               subBranch->fOffset = offset - localOffset;
+               subBranch->SetOffset(offset - localOffset);
             }
          } else {
             // -- Set fBranchOffset for sub-branch.
@@ -3146,7 +3178,9 @@
    // TODO: Exception safety a la TPushPop
    TVirtualCollectionProxy* proxy = GetCollectionProxy();
    TVirtualCollectionProxy::TPushPop helper(proxy, fObject);
-   void* alternate = proxy->Allocate(fNdata, true);
+   void* alternate = proxy->Allocate(fNdata, true);   
+   fIterators->CreateIterators(alternate);
+   
    Int_t nbranches = fBranches.GetEntriesFast();
    switch (fSTLtype) {
       case TClassEdit::kSet:
@@ -3213,9 +3247,18 @@
       return;
    }
    TStreamerInfo *info = GetInfo();
+   if (info == 0) return;
+
    TVirtualCollectionProxy *proxy = GetCollectionProxy();
    TVirtualCollectionProxy::TPushPop helper(proxy, fObject);
 
+//   TVirtualCollectionIterators *iter = fBranchCount->fIterators;
+//   fReadActionSequence->ReadBufferVecPtr(b,iter->fBegin,iter->fEnd);
+
+//   char **arr = (char **)proxy->At(0);
+//   char **end = arr + proxy->Size();
+//   fReadActionSequence->ReadBufferVecPtr(b,arr,end);
+
    info->ReadBufferSTLPtrs(b, proxy, fNdata, fID, fOffset);
    for(UInt_t ii=0; ii < fIDs.size(); ++ii) {
       info->ReadBufferSTLPtrs(b, proxy, fNdata, fIDs[ii], fOffset);
@@ -3244,15 +3287,15 @@
       return;
    }
    TStreamerInfo *info = GetInfo();
+   if (info == 0) return;
+   // Since info is not null, fReadActionSequence is not null either.
+
+   // Still calling PushPop for the legacy entries.
    TVirtualCollectionProxy *proxy = GetCollectionProxy();
    TVirtualCollectionProxy::TPushPop helper(proxy, fObject);
-
-   //info->ReadBufferSTL(b, GetCollectionProxy(), fNdata, fID, fOffset);
-   info->ReadBuffer(b, *proxy, fID, fNdata, fOffset,1);
-   for(UInt_t ii=0; ii < fIDs.size(); ++ii) {
-      //info->ReadBufferSTL(b, GetCollectionProxy(), fNdata, fIDs[ii], fOffset);
-      info->ReadBuffer(b, *proxy,  fIDs[ii], fNdata, fOffset,1);
-   }
+   
+   TVirtualCollectionIterators*iter = fBranchCount->fIterators;
+   fReadActionSequence->ReadBuffer(b,iter->fBegin,iter->fEnd);
 }
 
 //______________________________________________________________________________
@@ -3322,10 +3365,12 @@
       return;
    }
    TStreamerInfo *info = GetInfo();
-   info->ReadBufferClones(b, clones, fNdata, fID, fOffset);
-   for(UInt_t ii=0; ii < fIDs.size(); ++ii) {
-      info->ReadBufferClones(b, clones, fNdata, fIDs[ii], fOffset);
-   }   
+   if (info==0) return;
+   // Since info is not null, fReadActionSequence is not null either.
+   
+   char **arr = (char **)clones->GetObjectRef(0);
+   char **end = arr + fNdata;
+   fReadActionSequence->ReadBufferVecPtr(b,arr,end);
 }
 
 //______________________________________________________________________________
@@ -3362,10 +3407,8 @@
    if (!info) {
       return;
    }
-   info->ReadBuffer(b, (char**) &fObject, fID);
-   for(UInt_t ii=0; ii < fIDs.size(); ++ii) {
-      info->ReadBuffer(b, (char**) &fObject, fIDs[ii]);
-   }   
+   // Since info is not null, fReadActionSequence is not null either.
+   fReadActionSequence->ReadBuffer(b, fObject);
 }
 
 //______________________________________________________________________________
@@ -3401,10 +3444,8 @@
    if (!info) {
       return;
    }
-   info->ReadBuffer(b, (char**) &fObject, fID);
-   for(UInt_t ii=0; ii < fIDs.size(); ++ii) {
-      info->ReadBuffer(b, (char**) &fObject, fIDs[ii]);
-   }   
+   // Since info is not null, fReadActionSequence is not null either.
+   fReadActionSequence->ReadBuffer(b, fObject);
 }
 
 //______________________________________________________________________________
@@ -3438,10 +3479,8 @@
    if (!info) {
       return;
    }
-   info->ReadBuffer(b, (char**) &fObject, fID);
-   for(UInt_t ii=0; ii < fIDs.size(); ++ii) {
-      info->ReadBuffer(b, (char**) &fObject, fIDs[ii]);
-   }
+   // Since info is not null, fReadActionSequence is not null either.
+   fReadActionSequence->ReadBuffer(b, fObject);
    fNdata = (Int_t) GetValue(0, 0);
 }
 
@@ -3812,11 +3851,14 @@
          if (matched) {
             // Change from 3/31 to 4/41
             SetType(4);
-            SwitchContainer(GetListOfBranches());
-            SetReadLeavesPtr();
             // Set the proxy.
             fSTLtype = TMath::Abs(TClassEdit::IsSTLCont(newType->GetName()));
             fCollProxy = newType->GetCollectionProxy()->Generate();
+
+            SwitchContainer(GetListOfBranches());
+            SetReadLeavesPtr();
+            
+            fIterators = new TVirtualCollectionIterators(fCollProxy);
          } else {
             // FIXME: Must maintain fObject here as well.
             fAddress = 0;
@@ -3833,49 +3875,69 @@
             if (fSTLtype == TClassEdit::kNotSTL) {
                fSTLtype = TMath::Abs(TClassEdit::IsSTLCont(newType->GetName()));
             }
+            delete fCollProxy;
+            Int_t nbranches = GetListOfBranches()->GetEntries();
             fCollProxy = newType->GetCollectionProxy()->Generate();
-         } else {
+            for (Int_t i = 0; i < nbranches; ++i) {
+               TBranchElement* br = (TBranchElement*) GetListOfBranches()->UncheckedAt(i);
+               br->fCollProxy = 0;
+               if (br->fReadActionSequence) {
+                  br->SetReadActionSequence();
+               }
+            }
+            SetReadActionSequence();
+            SetReadLeavesPtr();
+            delete fIterators;
+            fIterators = new TVirtualCollectionIterators(fCollProxy);
+         } 
+         else if ((newType == TClonesArray::Class()) && (oldProxy->GetValueClass() && !oldProxy->HasPointers() && oldProxy->GetValueClass()->InheritsFrom(TObject::Class()))) 
+         {            
             // The new collection and the old collection are not compatible,
             // we cannot use the new collection to read the data.
             // Actually we could check if the new collection is a
             // compatible ROOT collection.
-            if ((newType == TClonesArray::Class()) && (oldProxy->GetValueClass() && !oldProxy->HasPointers() && oldProxy->GetValueClass()->InheritsFrom(TObject::Class()))) {
-               // We cannot insure that the TClonesArray is set for the
-               // proper class (oldProxy->GetValueClass()), so we assume that
-               // the transformation was done properly by the class designer.
-
-               // Change from 4/41 to 3/31
-               SetType(3);
-               SwitchContainer(GetListOfBranches());
-               SetReadLeavesPtr();
-               // Reset the proxy.
-               fSTLtype = kNone;
-               switch(fStreamerType) {
-                  case TVirtualStreamerInfo::kAny:
-                  case TVirtualStreamerInfo::kSTL:
-                     fStreamerType = TVirtualStreamerInfo::kObject;
-                     break;
-                  case TVirtualStreamerInfo::kAnyp:
-                  case TVirtualStreamerInfo::kSTLp:
-                     fStreamerType = TVirtualStreamerInfo::kObjectp;
-                     break;
-                  case TVirtualStreamerInfo::kAnyP:
-                     fStreamerType = TVirtualStreamerInfo::kObjectP;
-                     break;
-               }
-               fClonesName = oldProxy->GetValueClass()->GetName();
-               delete fCollProxy;
-               fCollProxy = 0;
-               TClass* clm = TClass::GetClass(GetClonesName());
-               if (clm) {
-                  clm->BuildRealData(); //just in case clm derives from an abstract class
-                  clm->GetStreamerInfo();
-               }
-            } else {
-               // FIXME: We must maintain fObject here as well.
-               fAddress = 0;
+            
+            // We cannot insure that the TClonesArray is set for the
+            // proper class (oldProxy->GetValueClass()), so we assume that
+            // the transformation was done properly by the class designer.
+            
+            // Change from 4/41 to 3/31
+            SetType(3);
+            // Reset the proxy.
+            fSTLtype = kNone;
+            switch(fStreamerType) {
+               case TVirtualStreamerInfo::kAny:
+               case TVirtualStreamerInfo::kSTL:
+                  fStreamerType = TVirtualStreamerInfo::kObject;
+                  break;
+               case TVirtualStreamerInfo::kAnyp:
+               case TVirtualStreamerInfo::kSTLp:
+                  fStreamerType = TVirtualStreamerInfo::kObjectp;
+                  break;
+               case TVirtualStreamerInfo::kAnyP:
+                  fStreamerType = TVirtualStreamerInfo::kObjectP;
+                  break;
             }
+            fClonesName = oldProxy->GetValueClass()->GetName();
+            delete fCollProxy;
+            fCollProxy = 0;
+            TClass* clm = TClass::GetClass(GetClonesName());
+            if (clm) {
+               clm->BuildRealData(); //just in case clm derives from an abstract class
+               clm->GetStreamerInfo();
+            }
+            SwitchContainer(GetListOfBranches());
+            SetReadLeavesPtr();
+            delete fIterators;
+            fIterators = 0;
+         } else {
+            // FIXME: We must maintain fObject here as well.
+            fAddress = 0;
          }
+      } else {
+         if (!fIterators) {
+            fIterators = new TVirtualCollectionIterators(GetCollectionProxy());
+         }
       }
    }
 
@@ -4189,6 +4251,62 @@
 }
 
 //______________________________________________________________________________
+void TBranchElement::SetOffset(Int_t offset)
+{
+   // Set offset of the object (to which the data member represented by this
+   // branch belongs) inside its containing object (if any).
+   
+   // We need to make sure that the Read and Write action's configuration
+   // properly reflect this value.
+   
+   if (fReadActionSequence) {
+      fReadActionSequence->AddToOffset(offset - fOffset);
+   }
+   fOffset = offset;
+}
+   
+//______________________________________________________________________________
+void TBranchElement::SetReadActionSequence()
+{
+   // Set the sequence of actions needed to read the data out of the buffer.
+   
+   if (fInfo == 0) {
+      // We are called too soon.  We will be called again by InitInfo
+      return;
+   }
+
+   // Get the action sequence we need to copy for reading.
+   TStreamerInfoActions::TActionSequence *original = 0;
+   TStreamerInfoActions::TActionSequence *transient = 0;
+   if (fType == 41) {
+      if (GetParentClass() == GetInfo()->GetClass()) {
+         if( fTargetClassName.Length() && fTargetClassName != fClassName ) {
+            original = GetCollectionProxy()->GetConversionReadMemberWiseActions(fBranchClass.GetClass(), fClassVersion);
+         } else {
+            original = GetCollectionProxy()->GetReadMemberWiseActions(fClassVersion);
+         }
+      } else {
+         // Base class and embedded objects.
+         
+         transient = TStreamerInfoActions::TActionSequence::CreateReadMemberWiseActions(GetInfo(),GetCollectionProxy());
+         original = transient;
+      }
+   } else if (fType == 31) {
+      original = fInfo->GetReadMemberWiseActions(kTRUE);            
+   } else if (0<=fType && fType<=2) {
+      // Note: this still requires the ObjectWise sequence to not be optimized!
+      original = fInfo->GetReadMemberWiseActions(kFALSE);
+   }
+   if (original) {
+      fIDs.insert(fIDs.begin(),fID); // Include the main element in the sequence.
+      if (fReadActionSequence) delete fReadActionSequence;
+      fReadActionSequence = original->CreateSubSequence(fIDs,fOffset);
+      fIDs.erase(fIDs.begin());
+   }
+   delete transient;
+}
+
+//______________________________________________________________________________
 void TBranchElement::SetReadLeavesPtr()
 {
    // Set the ReadLeaves pointer to execute the expected operations.
@@ -4221,6 +4339,8 @@
    } else {
       Fatal("SetReadLeavePtr","Unexpected branch type %d for %s",fType,GetName());
    }
+   
+   SetReadActionSequence();
 }
 
 //______________________________________________________________________________
@@ -4239,6 +4359,8 @@
       fInfo = 0;
       fInit = kFALSE;
       fInitOffsets = kFALSE;
+      delete fReadActionSequence;
+      fReadActionSequence = 0;
 
       Int_t nbranches = fBranches.GetEntriesFast();
       for (Int_t i = 0; i < nbranches; ++i) {
@@ -4353,7 +4475,7 @@
          fLeaves.Add(leaf);
          fTree->GetListOfLeaves()->Add(leaf);
       }
-      SetReadLeavesPtr();
+      // SetReadLeavesPtr();
    }
    else {
       TDirectory* dirsav = fDirectory;
Index: tree/tree/inc/TBranchElement.h
===================================================================
--- tree/tree/inc/TBranchElement.h	(revision 35093)
+++ tree/tree/inc/TBranchElement.h	(working copy)
@@ -34,8 +34,12 @@
 class TFolder;
 class TStreamerInfo;
 class TVirtualCollectionProxy;
+class TVirtualCollectionIterators;
 class TVirtualArray;
 
+namespace TStreamerInfoActions { class TActionSequence; }
+
+
 class TBranchElement : public TBranch {
 
 // Friends
@@ -80,7 +84,9 @@
    TClassRef                fBranchClass;   //! Reference to class definition in fClassName
    Int_t                   *fBranchOffset;  //! Sub-Branch offsets with respect to current transient class
    Int_t                    fBranchID;      //! ID number assigned by a TRefTable.
-   std::vector<Int_t>       fIDs;           //! List of the serial number of all the StreamerInfo to be used.
+   std::vector<Int_t>       fIDs;           //! List of the serial number of all the StreamerInfo to be used.   
+   TStreamerInfoActions::TActionSequence *fReadActionSequence;  //! Set of actions to be executed to extract the data from the basket.
+   TVirtualCollectionIterators           *fIterators;     //! holds the iterators when the branch is of fType==4.
 
 // Not implemented
 private:
@@ -119,6 +125,7 @@
    void ReadLeavesMemberBranchCount(TBuffer& b);
    void ReadLeavesMemberCounter(TBuffer& b);
    void SetReadLeavesPtr();
+   void SetReadActionSequence();
 
 // Public Interface.
 public:
@@ -176,6 +183,7 @@
    virtual void             SetBasketSize(Int_t buffsize);
    virtual void             SetBranchFolder() { SetBit(kBranchFolder); }
    virtual void             SetClassName(const char* name) { fClassName = name; }
+   virtual void             SetOffset(Int_t offset);
    inline  void             SetParentClass(TClass* clparent);
    virtual void             SetParentName(const char* name) { fParentName = name; }
    virtual void             SetTargetClassName(const char *name);
Index: io/sql/src/TBufferSQL2.cxx
===================================================================
--- io/sql/src/TBufferSQL2.cxx	(revision 35093)
+++ io/sql/src/TBufferSQL2.cxx	(working copy)
@@ -931,6 +931,13 @@
 }
 
 //______________________________________________________________________________
+void TBufferSQL2::SkipVersion(const TClass *cl)
+{
+   // Skip class version from I/O buffer.
+   ReadVersion(0,0,cl);
+}
+
+//______________________________________________________________________________
 Version_t TBufferSQL2::ReadVersion(UInt_t *start, UInt_t *bcnt, const TClass *)
 {
    // read version value from buffer
@@ -1072,6 +1079,46 @@
 }
 
 //______________________________________________________________________________
+void TBufferSQL2::ReadWithFactor(Float_t *ptr, Double_t /* factor */, Double_t /* minvalue */)
+{
+   // Read a Double32_t from the buffer when the factor and minimun value have been specified
+   // see comments about Double32_t encoding at TBufferFile::WriteDouble32().
+   // Currently TBufferXML does not optimize space in this case.
+   
+   SqlReadBasic(*ptr);
+}
+
+//______________________________________________________________________________
+void TBufferSQL2::ReadWithNbits(Float_t *ptr, Int_t /* nbits */) 
+{
+   // Read a Float16_t from the buffer when the number of bits is specified (explicitly or not)
+   // see comments about Float16_t encoding at TBufferFile::WriteFloat16().
+   // Currently TBufferXML does not optimize space in this case.
+   
+   SqlReadBasic(*ptr);
+}
+
+//______________________________________________________________________________
+void TBufferSQL2::ReadWithFactor(Double_t *ptr, Double_t /* factor */, Double_t /* minvalue */) 
+{
+   // Read a Double32_t from the buffer when the factor and minimun value have been specified
+   // see comments about Double32_t encoding at TBufferFile::WriteDouble32().   
+   // Currently TBufferXML does not optimize space in this case.
+   
+   SqlReadBasic(*ptr);
+}
+
+//______________________________________________________________________________
+void TBufferSQL2::ReadWithNbits(Double_t *ptr, Int_t /* nbits */) 
+{
+   // Read a Double32_t from the buffer when the number of bits is specified (explicitly or not)
+   // see comments about Double32_t encoding at TBufferFile::WriteDouble32().   
+   // Currently TBufferXML does not optimize space in this case.
+   
+   SqlReadBasic(*ptr);
+}
+
+//______________________________________________________________________________
 void TBufferSQL2::WriteFloat16 (Float_t *f, TStreamerElement * /*ele*/)
 {
    // Write Float16 value
Index: io/sql/inc/TBufferSQL2.h
===================================================================
--- io/sql/inc/TBufferSQL2.h	(revision 35093)
+++ io/sql/inc/TBufferSQL2.h	(working copy)
@@ -152,8 +152,9 @@
    virtual Int_t    CheckByteCount(UInt_t startpos, UInt_t bcnt, const char *classname); // SL
    virtual void     SetByteCount(UInt_t cntpos, Bool_t packInVersion = kFALSE);  // SL
 
+   virtual void      SkipVersion(const TClass *cl = 0);
    virtual Version_t ReadVersion(UInt_t *start = 0, UInt_t *bcnt = 0, const TClass *cl = 0);  // SL
-   virtual UInt_t   WriteVersion(const TClass *cl, Bool_t useBcnt = kFALSE);  // SL
+   virtual UInt_t    WriteVersion(const TClass *cl, Bool_t useBcnt = kFALSE);  // SL
 
    virtual void*    ReadObjectAny(const TClass* clCast);
    virtual void     SkipObjectAny();
@@ -172,7 +173,11 @@
    virtual void     WriteFloat16(Float_t *f, TStreamerElement *ele=0);
    virtual void     ReadDouble32 (Double_t *d, TStreamerElement *ele=0);
    virtual void     WriteDouble32(Double_t *d, TStreamerElement *ele=0);
-
+   virtual void     ReadWithFactor(Float_t *ptr, Double_t factor, Double_t minvalue);
+   virtual void     ReadWithNbits(Float_t *ptr, Int_t nbits);
+   virtual void     ReadWithFactor(Double_t *ptr, Double_t factor, Double_t minvalue);
+   virtual void     ReadWithNbits(Double_t *ptr, Int_t nbits);
+   
    virtual Int_t    ReadArray(Bool_t    *&b);
    virtual Int_t    ReadArray(Char_t    *&c);
    virtual Int_t    ReadArray(UChar_t   *&c);
Index: io/xml/src/TBufferXML.cxx
===================================================================
--- io/xml/src/TBufferXML.cxx	(revision 35093)
+++ io/xml/src/TBufferXML.cxx	(working copy)
@@ -1358,6 +1358,13 @@
 }
 
 //______________________________________________________________________________
+void TBufferXML::SkipVersion(const TClass *cl)
+{
+   // Skip class version from I/O buffer.
+   ReadVersion(0,0,cl);
+}
+   
+//______________________________________________________________________________
 Version_t TBufferXML::ReadVersion(UInt_t *start, UInt_t *bcnt, const TClass * /*cl*/)
 {
    // read version value from buffer
@@ -1510,6 +1517,50 @@
 }
 
 //______________________________________________________________________________
+void TBufferXML::ReadWithFactor(Float_t *ptr, Double_t /* factor */, Double_t /* minvalue */)
+{
+   // Read a Double32_t from the buffer when the factor and minimun value have been specified
+   // see comments about Double32_t encoding at TBufferFile::WriteDouble32().
+   // Currently TBufferXML does not optimize space in this case.
+   
+   BeforeIOoperation();
+   XmlReadBasic(*ptr);
+}
+
+//______________________________________________________________________________
+void TBufferXML::ReadWithNbits(Float_t *ptr, Int_t /* nbits */) 
+{
+   // Read a Float16_t from the buffer when the number of bits is specified (explicitly or not)
+   // see comments about Float16_t encoding at TBufferFile::WriteFloat16().
+   // Currently TBufferXML does not optimize space in this case.
+   
+   BeforeIOoperation();
+   XmlReadBasic(*ptr);
+}
+
+//______________________________________________________________________________
+void TBufferXML::ReadWithFactor(Double_t *ptr, Double_t /* factor */, Double_t /* minvalue */) 
+{
+   // Read a Double32_t from the buffer when the factor and minimun value have been specified
+   // see comments about Double32_t encoding at TBufferFile::WriteDouble32().   
+   // Currently TBufferXML does not optimize space in this case.
+   
+   BeforeIOoperation();
+   XmlReadBasic(*ptr);
+}
+
+//______________________________________________________________________________
+void TBufferXML::ReadWithNbits(Double_t *ptr, Int_t /* nbits */) 
+{
+   // Read a Double32_t from the buffer when the number of bits is specified (explicitly or not)
+   // see comments about Double32_t encoding at TBufferFile::WriteDouble32().   
+   // Currently TBufferXML does not optimize space in this case.
+   
+   BeforeIOoperation();
+   XmlReadBasic(*ptr);
+}
+
+//______________________________________________________________________________
 void TBufferXML::WriteFloat16 (Float_t *f, TStreamerElement * /*ele*/)
 {
    // write a Float16_t to the buffer
Index: io/xml/inc/TBufferXML.h
===================================================================
--- io/xml/inc/TBufferXML.h	(revision 35093)
+++ io/xml/inc/TBufferXML.h	(working copy)
@@ -66,8 +66,9 @@
    virtual Int_t    CheckByteCount(UInt_t startpos, UInt_t bcnt, const char *classname); // SL
    virtual void     SetByteCount(UInt_t cntpos, Bool_t packInVersion = kFALSE);  // SL
 
+   virtual void      SkipVersion(const TClass *cl = 0);
    virtual Version_t ReadVersion(UInt_t *start = 0, UInt_t *bcnt = 0, const TClass *cl = 0);  // SL
-   virtual UInt_t   WriteVersion(const TClass *cl, Bool_t useBcnt = kFALSE);  // SL
+   virtual UInt_t    WriteVersion(const TClass *cl, Bool_t useBcnt = kFALSE);  // SL
 
    virtual void*    ReadObjectAny(const TClass* clCast);
    virtual void     SkipObjectAny();
@@ -86,7 +87,11 @@
    virtual void     WriteFloat16(Float_t *f, TStreamerElement *ele=0);
    virtual void     ReadDouble32 (Double_t *d, TStreamerElement *ele=0);
    virtual void     WriteDouble32(Double_t *d, TStreamerElement *ele=0);
-
+   virtual void     ReadWithFactor(Float_t *ptr, Double_t factor, Double_t minvalue);
+   virtual void     ReadWithNbits(Float_t *ptr, Int_t nbits);
+   virtual void     ReadWithFactor(Double_t *ptr, Double_t factor, Double_t minvalue);
+   virtual void     ReadWithNbits(Double_t *ptr, Int_t nbits);
+   
    virtual Int_t    ReadArray(Bool_t    *&b);
    virtual Int_t    ReadArray(Char_t    *&c);
    virtual Int_t    ReadArray(UChar_t   *&c);
Index: io/io/src/TStreamerInfo.cxx
===================================================================
--- io/io/src/TStreamerInfo.cxx	(revision 35093)
+++ io/io/src/TStreamerInfo.cxx	(working copy)
@@ -69,6 +69,8 @@
 
 #include "TVirtualMutex.h"
 
+#include "TStreamerInfoActions.h"
+
 TStreamerElement *TStreamerInfo::fgElement = 0;
 Int_t   TStreamerInfo::fgCount = 0;
 
@@ -140,6 +142,9 @@
    fNVirtualInfoLoc = 0;
    fVirtualInfoLoc = 0;
    fLiveCount = 0;
+   
+   fReadObjectWise = 0;
+   fReadMemberWise = 0;
 }
 
 //______________________________________________________________________________
@@ -168,6 +173,9 @@
    fNVirtualInfoLoc = 0;
    fVirtualInfoLoc = 0;
    fLiveCount = 0;
+   
+   fReadObjectWise = 0;
+   fReadMemberWise = 0;
 }
 
 //______________________________________________________________________________
@@ -187,6 +195,9 @@
    if (!fElements) return;
    fElements->Delete();
    delete fElements; fElements=0;
+   
+   delete fReadObjectWise;
+   delete fReadMemberWise;
 }
 
 //______________________________________________________________________________
@@ -1653,6 +1664,9 @@
       fNdata = 0;
       fSize = 0;
       ResetBit(kIsCompiled);
+      
+      if (fReadObjectWise) fReadObjectWise->fActions.clear();
+      if (fReadMemberWise) fReadMemberWise->fActions.clear();
    }
 }
 
@@ -1980,174 +1994,7 @@
    return result;
 }
 
-//______________________________________________________________________________
-void TStreamerInfo::Compile()
-{
-   // loop on the TStreamerElement list
-   // regroup members with same type
-   // Store predigested information into local arrays. This saves a huge amount
-   // of time compared to an explicit iteration on all elements.
 
-   R__LOCKGUARD(gCINTMutex);
-
-   // fprintf(stderr,"Running Compile for %s %d %d req=%d,%d\n",GetName(),fClassVersion,fOptimized,CanOptimize(),TestBit(kCannotOptimize));
-
-   // if (IsCompiled() && (!fOptimized || (CanOptimize() && !TestBit(kCannotOptimize)))) return;
-
-   fOptimized = kFALSE;
-   fNdata = 0;
-
-   TObjArray* infos = (TObjArray*) gROOT->GetListOfStreamerInfo();
-   if (fNumber >= infos->GetSize()) {
-      infos->AddAtAndExpand(this, fNumber);
-   } else {
-      if (!infos->At(fNumber)) {
-         infos->AddAt(this, fNumber);
-      }
-   }
-
-   delete[] fType;
-   fType = 0;
-   delete[] fNewType;
-   fNewType = 0;
-   delete[] fOffset;
-   fOffset = 0;
-   delete[] fLength;
-   fLength = 0;
-   delete[] fElem;
-   fElem = 0;
-   delete[] fMethod;
-   fMethod = 0;
-   delete[] fComp;
-   fComp = 0;
-
-
-   Int_t ndata = fElements->GetEntries();
-
-   fOffset = new Int_t[ndata+1];
-   fType   = new Int_t[ndata+1];
-
-   SetBit(kIsCompiled);
-
-   if (!ndata) {
-      // This may be the case for empty classes (e.g., TAtt3D).
-      // We still need to properly set the size of emulated classes (i.e. add the virtual table)
-      if (fClass->TestBit(TClass::kIsEmulation) && fNVirtualInfoLoc!=0) {
-         fSize = sizeof(TStreamerInfo*);
-      }
-      return;
-   }
-
-   fComp = new TCompInfo[ndata];
-   fNewType = new Int_t[ndata];
-   fLength = new Int_t[ndata];
-   fElem = new ULong_t[ndata];
-   fMethod = new ULong_t[ndata];
-
-   TStreamerElement* element;
-   TStreamerElement* previous = 0;
-   Int_t keep = -1;
-   Int_t i;
-
-   if (!CanOptimize()) {
-      SetBit(kCannotOptimize);
-   }
-
-   Bool_t isOptimized = kFALSE;
-
-   for (i = 0; i < ndata; ++i) {
-      element = (TStreamerElement*) fElements->At(i);
-      if (!element) {
-         break;
-      }
-      if (element->GetType() < 0) {
-         // -- Skip an ignored TObject base class.
-         // Note: The only allowed negative value here is -1,
-         // and signifies that Build() has found a TObject
-         // base class and TClass::IgnoreTObjectStreamer() was
-         // called.  In this case the compiled version of the
-         // elements omits the TObject base class element,
-         // which has to be compensated for by TTree::Bronch()
-         // when it is making branches for a split object.
-         continue;
-      }
-      Int_t asize = element->GetSize();
-      if (element->GetArrayLength()) {
-         asize /= element->GetArrayLength();
-      }
-      fType[fNdata] = element->GetType();
-      fNewType[fNdata] = element->GetNewType();
-      fOffset[fNdata] = element->GetOffset();
-      fLength[fNdata] = element->GetArrayLength();
-      fElem[fNdata] = (ULong_t) element;
-      fMethod[fNdata] = element->GetMethod();
-      // try to group consecutive members of the same type
-      if (!TestBit(kCannotOptimize) 
-          && (keep >= 0) 
-          && (element->GetType() < 10) 
-          && (fType[fNdata] == fNewType[fNdata]) 
-          && (fMethod[keep] == 0) 
-          && (element->GetType() > 0) 
-          && (element->GetArrayDim() == 0) 
-          && (fType[keep] < kObject) 
-          && (fType[keep] != kCharStar) /* do not optimize char* */ 
-          && (element->GetType() == (fType[keep]%kRegrouped)) 
-          && ((element->GetOffset()-fOffset[keep]) == (fLength[keep])*asize)
-          && ((fOldVersion<6) || !previous || /* In version of TStreamerInfo less than 6, the Double32_t were merged even if their annotation (aka factor) were different */
-              ((element->GetFactor() == previous->GetFactor())
-               && (element->GetXmin() == previous->GetXmin())
-               && (element->GetXmax() == previous->GetXmax())
-              )
-             )
-         ) 
-      {
-         if (fLength[keep] == 0) {
-            fLength[keep]++;
-         }
-         fLength[keep]++;
-         fType[keep] = element->GetType() + kRegrouped;
-         isOptimized = kTRUE;
-      } else {
-         if (fNewType[fNdata] != fType[fNdata]) {
-            if (fNewType[fNdata] > 0) {
-               if (fType[fNdata] != kCounter) {
-                  fType[fNdata] += kConv;
-               }
-            } else {
-               if (fType[fNdata] == kCounter) {
-                  Warning("Compile", "Counter %s should not be skipped from class %s", element->GetName(), GetName());
-               }
-               fType[fNdata] += kSkip;
-            }
-         }
-         keep = fNdata;
-         if (fLength[keep] == 0) {
-            fLength[keep] = 1;
-         }
-         fNdata++;
-      }
-      previous = element;
-   }
-
-   for (i = 0; i < fNdata; ++i) {
-      element = (TStreamerElement*) fElem[i];
-      if (!element) {
-         continue;
-      }
-      fComp[i].fClass = element->GetClassPointer();
-      fComp[i].fNewClass = element->GetNewClass();
-      fComp[i].fClassName = TString(element->GetTypeName()).Strip(TString::kTrailing, '*');
-      fComp[i].fStreamer = element->GetStreamer();
-   }
-   ComputeSize();
-
-   fOptimized = isOptimized;
-
-   if (gDebug > 0) {
-      ls();
-   }
-}
-
 //______________________________________________________________________________
 void TStreamerInfo::ComputeSize()
 {
@@ -2444,9 +2291,9 @@
                   sub_numberOfNamespaces = TMakeProject::GenerateClassPrefix(fp, subinfo->GetName() + len+2, kFALSE, sub_protoname, &sub_numberOfClasses, 3);                  
                } else {
                   sub_numberOfNamespaces = TMakeProject::GenerateClassPrefix(fp, subinfo->GetName() + len+2, kFALSE, sub_protoname, &sub_numberOfClasses, kFALSE);
+                  fprintf(fp, ";\n");
                }
 
-               fprintf(fp, ";\n");
                for (UInt_t i = 0;i < sub_numberOfClasses;++i) {
                   fprintf(fp, "}; // end of class.\n");
                }
Index: io/io/src/TEmulatedMapProxy.cxx
===================================================================
--- io/io/src/TEmulatedMapProxy.cxx	(revision 35093)
+++ io/io/src/TEmulatedMapProxy.cxx	(working copy)
@@ -204,6 +204,29 @@
    }
 }
 
+void TEmulatedMapProxy::ReadBuffer(TBuffer &b, void *obj, const TClass *onfileClass)
+{
+   // Read portion of the streamer.
+
+   SetOnFileClass((TClass*)onfileClass);
+   ReadBuffer(b,obj);
+}
+
+void TEmulatedMapProxy::ReadBuffer(TBuffer &b, void *obj)
+{
+   // Read portion of the streamer.
+
+   TPushPop env(this,obj);
+   int nElements = 0;
+   b >> nElements;
+   if ( fEnv->fObject )  {
+      Resize(nElements,true);
+   }
+   if ( nElements > 0 )  {
+      ReadMap(nElements, b);
+   }
+}
+
 void TEmulatedMapProxy::Streamer(TBuffer &b)
 {
    // TClassStreamer IO overload.
Index: io/io/src/TMakeProject.cxx
===================================================================
--- io/io/src/TMakeProject.cxx	(revision 35093)
+++ io/io/src/TMakeProject.cxx	(working copy)
@@ -412,7 +412,7 @@
    UInt_t numberOfClasses = 0;
    UInt_t numberOfNamespaces = GenerateClassPrefix(fp, clname, kTRUE, protoname, &numberOfClasses, implementEmptyClass, needGenericTemplate);
 
-   fprintf(fp, ";\n");
+   if (!implementEmptyClass) fprintf(fp, ";\n");
    for (UInt_t i = 0;i < numberOfClasses;++i) {
       fprintf(fp, "}; // end of class.\n");
       fprintf(fp, "#endif\n");
Index: io/io/src/TBufferFile.cxx
===================================================================
--- io/io/src/TBufferFile.cxx	(revision 35093)
+++ io/io/src/TBufferFile.cxx	(working copy)
@@ -161,36 +161,6 @@
 }
 
 //______________________________________________________________________________
-void TBufferFile::PushDataCache(TVirtualArray *obj)
-{
-   // Push a new data cache area onto the list of area to be used for
-   // temporarily store 'missing' data members.
-
-   fCacheStack.push_back(obj);
-}
-
-//______________________________________________________________________________
-TVirtualArray *TBufferFile::PeekDataCache() const
-{
-   // Return the 'current' data cache area from the list of area to be used for
-   // temporarily store 'missing' data members.
-
-   if (fCacheStack.empty()) return 0;
-   return fCacheStack.back();
-}
-
-//______________________________________________________________________________
-TVirtualArray *TBufferFile::PopDataCache()
-{
-   // Pop and Return the 'current' data cache area from the list of area to be used for
-   // temporarily store 'missing' data members.
-
-   TVirtualArray *val = PeekDataCache();
-   fCacheStack.pop_back();
-   return val;
-}
-
-//______________________________________________________________________________
 static void frombufOld(char *&buf, Long_t *x)
 {
    // Files written with versions older than 3.00/06 had a non-portable
@@ -373,27 +343,12 @@
    // see comments about Float16_t encoding at TBufferFile::WriteFloat16().
 
    if (ele && ele->GetFactor() != 0) {
-      //a range was specified. We read an integer and convert it back to a double.
-      UInt_t aint; *this >> aint; f[0] = (Float_t)(aint/ele->GetFactor() + ele->GetXmin());
+      ReadWithFactor(f, ele->GetFactor(), ele->GetXmin());
    } else {
       Int_t nbits = 0;
       if (ele) nbits = (Int_t)ele->GetXmin();
       if (!nbits) nbits = 12;
-      //we read the exponent and the truncated mantissa of the float
-      //and rebuild the float.
-      union {
-         Float_t xx;
-         Int_t ix;
-      };
-      UChar_t  theExp;
-      UShort_t theMan;
-      *this >> theExp;
-      *this >> theMan;
-      ix = theExp;
-      ix <<= 23;
-      ix |= (theMan & ((1<<(nbits+1))-1)) <<(23-nbits);
-      if(1<<(nbits+1) & theMan) xx = -xx;
-      f[0] = xx;
+      ReadWithNbits(f, nbits);      
    }
 }
 
@@ -404,8 +359,7 @@
    // see comments about Double32_t encoding at TBufferFile::WriteDouble32().
 
    if (ele && ele->GetFactor() != 0) {
-      //a range was specified. We read an integer and convert it back to a double.
-      UInt_t aint; *this >> aint; d[0] = (Double_t)(aint/ele->GetFactor() + ele->GetXmin());
+      ReadWithFactor(d, ele->GetFactor(), ele->GetXmin());
    } else {
       Int_t nbits = 0;
       if (ele) nbits = (Int_t)ele->GetXmin();
@@ -415,26 +369,82 @@
          *this >> afloat;
          d[0] = (Double_t)afloat;
       } else {
-         //we read the exponent and the truncated mantissa of the float
-         //and rebuild the double.
-         union {
-            Float_t xx;
-            Int_t ix;
-         };
-         UChar_t  theExp;
-         UShort_t theMan;
-         *this >> theExp;
-         *this >> theMan;
-         ix = theExp;
-         ix <<= 23;
-         ix |= (theMan & ((1<<(nbits+1))-1)) <<(23-nbits);
-         if(1<<(nbits+1) & theMan) xx = -xx;
-         d[0] = (Double_t)xx;
+         ReadWithNbits(d, nbits);      
       }
    }
 }
 
 //______________________________________________________________________________
+void TBufferFile::ReadWithFactor(Float_t *ptr, Double_t factor, Double_t minvalue)
+{
+   // Read a Double32_t from the buffer when the factor and minimun value have been specified
+   // see comments about Double32_t encoding at TBufferFile::WriteDouble32().
+
+   //a range was specified. We read an integer and convert it back to a double.
+   UInt_t aint; 
+   frombuf(this->fBufCur,&aint); 
+   ptr[0] = (Float_t)(aint/factor + minvalue);
+}
+
+//______________________________________________________________________________
+void TBufferFile::ReadWithNbits(Float_t *ptr, Int_t nbits) 
+{
+   // Read a Float16_t from the buffer when the number of bits is specified (explicitly or not)
+   // see comments about Float16_t encoding at TBufferFile::WriteFloat16().
+
+   //we read the exponent and the truncated mantissa of the float
+   //and rebuild the float.
+   union {
+      Float_t xx;
+      Int_t ix;
+   } temp;
+   UChar_t  theExp;
+   UShort_t theMan;
+   frombuf(this->fBufCur,&theExp);
+   frombuf(this->fBufCur,&theMan);
+   temp.ix = theExp;
+   temp.ix <<= 23;
+   temp.ix |= (theMan & ((1<<(nbits+1))-1)) <<(23-nbits);
+   if(1<<(nbits+1) & theMan) temp.xx = -temp.xx;
+   ptr[0] = temp.xx;
+}
+
+//______________________________________________________________________________
+void TBufferFile::ReadWithFactor(Double_t *ptr, Double_t factor, Double_t minvalue) 
+{
+   // Read a Double32_t from the buffer when the factor and minimun value have been specified
+   // see comments about Double32_t encoding at TBufferFile::WriteDouble32().
+
+   //a range was specified. We read an integer and convert it back to a double.
+   UInt_t aint; 
+   frombuf(this->fBufCur,&aint); 
+   ptr[0] = (Double_t)(aint/factor + minvalue);
+}
+
+//______________________________________________________________________________
+void TBufferFile::ReadWithNbits(Double_t *ptr, Int_t nbits) 
+{
+   // Read a Double32_t from the buffer when the number of bits is specified (explicitly or not)
+   // see comments about Double32_t encoding at TBufferFile::WriteDouble32().
+
+   //we read the exponent and the truncated mantissa of the float
+   //and rebuild the float.
+   union {
+      Float_t xx;
+      Int_t ix;
+   } temp;
+   UChar_t  theExp;
+   UShort_t theMan;
+   frombuf(this->fBufCur,&theExp);
+   frombuf(this->fBufCur,&theMan);
+   temp.ix = theExp;
+   temp.ix <<= 23;
+   temp.ix |= (theMan & ((1<<(nbits+1))-1)) <<(23-nbits);
+   if(1<<(nbits+1) & theMan) temp.xx = -temp.xx;
+   ptr[0] = (Double_t)temp.xx;
+}
+
+//______________________________________________________________________________
 void TBufferFile::WriteFloat16(Float_t *f, TStreamerElement *ele)
 {
    // write a Float16_t to the buffer.
@@ -2567,6 +2577,77 @@
 }
 
 //______________________________________________________________________________
+void TBufferFile::SkipVersion(const TClass *cl)
+{
+   // Skip class version from I/O buffer.
+   
+   Version_t version;
+   
+   // not interested in byte count
+   frombuf(this->fBufCur,&version);
+      
+   // if this is a byte count, then skip next short and read version
+   if (version & kByteCountVMask) {
+      frombuf(this->fBufCur,&version);
+      frombuf(this->fBufCur,&version);
+   }
+
+   if (cl && cl->GetClassVersion() != 0  && version<=1) {
+      if (version <= 0)  {
+         UInt_t checksum = 0;
+         //*this >> checksum;
+         frombuf(this->fBufCur,&checksum);
+         TStreamerInfo *vinfo = (TStreamerInfo*)cl->FindStreamerInfo(checksum);
+         if (vinfo) {
+            return;
+         } else {
+            // There are some cases (for example when the buffer was stored outside of
+            // a ROOT file) where we do not have a TStreamerInfo.  If the checksum is
+            // the one from the current class, we can still assume that we can read
+            // the data so let use it.
+            if (checksum==cl->GetCheckSum() || checksum==cl->GetCheckSum(1)) {
+               version = cl->GetClassVersion();
+            } else {
+               if (fParent) {
+                  Error("ReadVersion", "Could not find the StreamerInfo with a checksum of %d for the class \"%s\" in %s.",
+                        checksum, cl->GetName(), ((TFile*)fParent)->GetName());
+               } else {
+                  Error("ReadVersion", "Could not find the StreamerInfo with a checksum of %d for the class \"%s\"( buffer with no parent)",
+                        checksum, cl->GetName());
+               }
+               return;
+            }
+         }
+      }  else if (version == 1 && fParent && ((TFile*)fParent)->GetVersion()<40000 ) {
+         // We could have a file created using a Foreign class before
+         // the introduction of the CheckSum.  We need to check
+         if ((!cl->IsLoaded() || cl->IsForeign()) &&
+             cl->GetStreamerInfos()->GetLast()>1 ) {
+            
+            const TList *list = ((TFile*)fParent)->GetStreamerInfoCache();
+            const TStreamerInfo *local = (TStreamerInfo*)list->FindObject(cl->GetName());
+            if ( local )  {
+               UInt_t checksum = local->GetCheckSum();
+               TStreamerInfo *vinfo = (TStreamerInfo*)cl->FindStreamerInfo(checksum);
+               if (vinfo) {
+                  version = vinfo->GetClassVersion();
+               } else {
+                  Error("ReadVersion", "Could not find the StreamerInfo with a checksum of %d for the class \"%s\" in %s.",
+                        checksum, cl->GetName(), ((TFile*)fParent)->GetName());
+                  return;
+               }
+            }
+            else  {
+               Error("ReadVersion", "Class %s not known to file %s.",
+                     cl->GetName(), ((TFile*)fParent)->GetName());
+               version = 0;
+            }
+         }
+      }
+   }
+}
+
+//______________________________________________________________________________
 Version_t TBufferFile::ReadVersion(UInt_t *startpos, UInt_t *bcnt, const TClass *cl)
 {
    // Read class version from I/O buffer.
@@ -2604,15 +2685,15 @@
    } else {
 
       // not interested in byte count
-      *this >> version;
+      frombuf(this->fBufCur,&version);
 
       // if this is a byte count, then skip next short and read version
       if (version & kByteCountVMask) {
-         *this >> version;
-         *this >> version;
+         frombuf(this->fBufCur,&version);
+         frombuf(this->fBufCur,&version);
       }
    }
-   if (cl && cl->GetClassVersion() != 0) {
+   if (version<=1 && cl && cl->GetClassVersion() != 0) {
       if (version <= 0)  {
          UInt_t checksum = 0;
          //*this >> checksum;
@@ -3224,9 +3305,11 @@
    // Interface to TStreamerInfo::ReadBufferClones.
 
    char **arr = (char **)a->GetObjectRef(0);
+   char **end = arr + nobjects;
    //a->GetClass()->GetStreamerInfo()->ReadBufferClones(*this,a,nobjects,-1,0);
    TStreamerInfo *info = (TStreamerInfo*)a->GetClass()->GetStreamerInfo(objvers);
-   return info->ReadBuffer(*this,arr,-1,nobjects,0,1);
+   //return info->ReadBuffer(*this,arr,-1,nobjects,0,1);
+   return info->ReadBuffer(*this,arr,end);
 }
 
 //______________________________________________________________________________
@@ -3339,8 +3422,7 @@
    }
 
    // Deserialize the object.
-   void *ptr = &pointer;
-   sinfo->ReadBuffer(*this, (char**)ptr,-1);
+   sinfo->ReadBuffer(*this, (char*)pointer);
    if (sinfo->IsRecovered()) count=0;
 
    // Check that the buffer position corresponds to the byte count.
@@ -3436,8 +3518,7 @@
    }
 
    //deserialize the object
-   void *ptr = &pointer;
-   sinfo->ReadBuffer(*this, (char**)ptr,-1);
+   sinfo->ReadBuffer(*this, (char*)pointer );
    if (sinfo->TStreamerInfo::IsRecovered()) R__c=0; // 'TStreamerInfo::' avoids going via a virtual function.
 
    // Check that the buffer position corresponds to the byte count.
Index: io/io/src/TEmulatedCollectionProxy.cxx
===================================================================
--- io/io/src/TEmulatedCollectionProxy.cxx	(revision 35093)
+++ io/io/src/TEmulatedCollectionProxy.cxx	(working copy)
@@ -45,6 +45,7 @@
    : TGenCollectionProxy(copy)
 {
    // Build a Streamer for an emulated vector whose type is 'name'.
+   fProperties |= kIsEmulated;
 }
 
 TEmulatedCollectionProxy::TEmulatedCollectionProxy(const char* cl_name)
@@ -56,6 +57,7 @@
    if ( this->TEmulatedCollectionProxy::InitializeEx() ) {
       fCreateEnv = TGenCollectionProxy::Env_t::Create;
    }
+   fProperties |= kIsEmulated;
 }
 
 TEmulatedCollectionProxy::~TEmulatedCollectionProxy()
@@ -128,6 +130,9 @@
             inside[0].replace(0,16,"std::");
          }
          fSTL_type = TClassEdit::STLKind(inside[0].c_str());
+         // Note: an emulated collection proxy is never really associative
+         // since under-neath is actually an array.
+
          // std::cout << "Initialized " << typeid(*this).name() << ":" << fName << std::endl;
          int slong = sizeof(void*);
          switch ( fSTL_type )  {
@@ -431,7 +436,7 @@
    // Allocate the necessary space.
 
    Resize(n, forceDelete);
-   return fEnv;
+   return fEnv->fObject;
 }
 
 void TEmulatedCollectionProxy::Commit(void* /* env */ )
@@ -534,6 +539,29 @@
 #undef DOLOOP
 }
 
+void TEmulatedCollectionProxy::ReadBuffer(TBuffer &b, void *obj, const TClass *onfileClass)
+{
+   // Read portion of the streamer.
+   
+   SetOnFileClass((TClass*)onfileClass);
+   ReadBuffer(b,obj);
+}
+
+void TEmulatedCollectionProxy::ReadBuffer(TBuffer &b, void *obj)
+{
+   // Read portion of the streamer.
+
+   TPushPop env(this,obj);
+   int nElements = 0;
+   b >> nElements;
+   if ( fEnv->fObject )  {
+      Resize(nElements,true);
+   }
+   if ( nElements > 0 )  {
+      ReadItems(nElements, b);
+   }
+}
+
 void TEmulatedCollectionProxy::Streamer(TBuffer &b)
 {
    // TClassStreamer IO overload
Index: io/io/src/TStreamerInfoReadBuffer.cxx
===================================================================
--- io/io/src/TStreamerInfoReadBuffer.cxx	(revision 35093)
+++ io/io/src/TStreamerInfoReadBuffer.cxx	(working copy)
@@ -665,7 +665,10 @@
 
    TStreamerInfo *thisVar = this;
 #endif
-   b.IncrementLevel(thisVar);
+   Bool_t needIncrement = !( arrayMode & 2 );
+   arrayMode = arrayMode & (~2);
+   
+   if (needIncrement) b.IncrementLevel(thisVar);
 
    Int_t last;
 
@@ -691,7 +694,7 @@
    TMemberStreamer *pstreamer=0;
    Int_t isPreAlloc = 0;
    for (Int_t i=first;i<last;i++) {
-      b.SetStreamerElementNumber(i);
+      if (needIncrement) b.SetStreamerElementNumber(i);
       TStreamerElement * aElement  = (TStreamerElement*)fElem[i];
       fgElement = aElement;
 
@@ -1609,7 +1612,7 @@
          continue;
       }
    }
-   b.DecrementLevel(thisVar);
+   if (needIncrement) b.DecrementLevel(thisVar);
    return 0;
 }
 
Index: io/io/src/TGenCollectionProxy.cxx
===================================================================
--- io/io/src/TGenCollectionProxy.cxx	(revision 35093)
+++ io/io/src/TGenCollectionProxy.cxx	(working copy)
@@ -33,10 +33,13 @@
 #include "TInterpreter.h"
 #include "Riostream.h"
 #include "TVirtualMutex.h"
+#include "TStreamerInfoActions.h"
 #include <stdlib.h>
 
 #define MESSAGE(which,text)
 
+std::vector<TVirtualCollectionProxy*> gSlowIterator__Proxy;
+
 //////////////////////////////////////////////////////////////////////////
 //                                                                      //
 //  class TGenVectorProxy
@@ -507,10 +510,10 @@
    fNext.call      = copy.fNext.call;
    fFirst.call     = copy.fFirst.call;
    fClear.call     = copy.fClear.call;
-   fResize.call    = copy.fResize.call;
-   fDestruct.call  = copy.fDestruct.call;
-   fConstruct.call = copy.fConstruct.call;
-   fFeed.call      = copy.fFeed.call;
+   fResize         = copy.fResize;
+   fDestruct       = copy.fDestruct;
+   fConstruct      = copy.fConstruct;
+   fFeed           = copy.fFeed;
    fCollect.call   = copy.fCollect.call;
    fCreateEnv.call = copy.fCreateEnv.call;
    fValOffset      = copy.fValOffset;
@@ -519,6 +522,11 @@
    fVal            = copy.fVal   ? new Value(*copy.fVal)   : 0;
    fKey            = copy.fKey   ? new Value(*copy.fKey)   : 0;
    fOnFileClass    = copy.fOnFileClass;
+   fReadMemberWise = new TObjArray(TCollection::kInitCapacity,-1);
+   fConversionReadMemberWise = 0;
+   fProperties     = copy.fProperties;
+   fFunctionCreateIterators    = copy.fFunctionCreateIterators;
+   fFunctionDeleteTwoIterators = copy.fFunctionDeleteTwoIterators;
 }
 
 //______________________________________________________________________________
@@ -532,12 +540,12 @@
    fFirst.call      = 0;
    fNext.call       = 0;
    fClear.call      = 0;
-   fResize.call     = 0;
-   fDestruct.call   = 0;
-   fConstruct.call  = 0;
+   fResize          = 0;
+   fDestruct        = 0;
+   fConstruct       = 0;
    fCollect.call    = 0;
    fCreateEnv.call  = 0;
-   fFeed.call       = 0;
+   fFeed            = 0;
    fValue           = 0;
    fKey             = 0;
    fVal             = 0;
@@ -555,6 +563,10 @@
             (Long_t)iter_size,
             (Long_t)sizeof(e.fIterator));
    }
+   fReadMemberWise = new TObjArray(TCollection::kInitCapacity,-1);
+   fConversionReadMemberWise   = 0;
+   fFunctionCreateIterators    = 0;
+   fFunctionDeleteTwoIterators = 0;
 }
 
 //______________________________________________________________________________
@@ -567,13 +579,13 @@
    fValDiff        = info.fValueDiff;
    fValOffset      = info.fValueOffset;
    fSize.call      = info.fSizeFunc;
-   fResize.call    = info.fResizeFunc;
+   fResize         = info.fResizeFunc;
    fNext.call      = info.fNextFunc;
    fFirst.call     = info.fFirstFunc;
    fClear.call     = info.fClearFunc;
-   fConstruct.call = info.fConstructFunc;
-   fDestruct.call  = info.fDestructFunc;
-   fFeed.call      = info.fFeedFunc;
+   fConstruct      = info.fConstructFunc;
+   fDestruct       = info.fDestructFunc;
+   fFeed           = info.fFeedFunc;
    fCollect.call   = info.fCollectFunc;
    fCreateEnv.call = info.fCreateEnv;
    
@@ -597,18 +609,21 @@
             (Long_t)info.fIterSize,
             (Long_t)sizeof(e.fIterator));
    }
+   fReadMemberWise = new TObjArray(TCollection::kInitCapacity,-1);
+   fConversionReadMemberWise   = 0;
+   fFunctionCreateIterators    = 0;
+   fFunctionDeleteTwoIterators = 0;
 }
 
 namespace {
-   typedef std::vector<ROOT::TCollectionProxyInfo::EnvironBase* > Proxies_t;
-   void clearProxies(Proxies_t& v)
+   template <class vec> 
+   void clearVector(vec& v)
    {
       // Clear out the proxies.
 
-      for(Proxies_t::iterator i=v.begin(); i != v.end(); ++i) {
-         ROOT::TCollectionProxyInfo::EnvironBase *e = *i;
+      for(typename vec::iterator i=v.begin(); i != v.end(); ++i) {
+         typename vec::value_type e = *i;
          if ( e ) {
-            if ( e->fTemp ) ::free(e->fTemp);
             delete e;
          }
       }
@@ -619,12 +634,24 @@
 TGenCollectionProxy::~TGenCollectionProxy()
 {
    // Standard destructor
-   clearProxies(fProxyList);
-   clearProxies(fProxyKept);
+   clearVector(fProxyList);
+   clearVector(fProxyKept);
+   clearVector(fStaged);
 
    if ( fValue ) delete fValue;
    if ( fVal   ) delete fVal;
    if ( fKey   ) delete fKey;
+   
+   delete fReadMemberWise;
+   if (fConversionReadMemberWise) {
+      std::map<std::string, TObjArray*>::iterator it;
+      std::map<std::string, TObjArray*>::iterator end = fConversionReadMemberWise->end();
+      for( it = fConversionReadMemberWise->begin(); it != end; ++it ) {
+         delete it->second;
+      }
+      delete fConversionReadMemberWise;
+      fConversionReadMemberWise = 0;
+   }
 }
 
 //______________________________________________________________________________
@@ -666,6 +693,7 @@
    // Proxy initializer
    TGenCollectionProxy* p = const_cast<TGenCollectionProxy*>(this);
    if ( fValue ) return p;
+   const_cast<TGenCollectionProxy*>(this)->fProperties |= kIsInitialized;
    return p->InitializeEx();
 }
 
@@ -676,7 +704,7 @@
    if ( 0 == fSize.call ) {
       Fatal("TGenCollectionProxy","No 'size' function pointer for class %s present.",fName.c_str());
    }
-   if ( 0 == fResize.call ) {
+   if ( 0 == fResize ) {
       Fatal("TGenCollectionProxy","No 'resize' function for class %s present.",fName.c_str());
    }
    if ( 0 == fNext.call  ) {
@@ -688,13 +716,13 @@
    if ( 0 == fClear.call ) {
       Fatal("TGenCollectionProxy","No 'clear' function for class %s present.",fName.c_str());
    }
-   if ( 0 == fConstruct.call ) {
+   if ( 0 == fConstruct ) {
       Fatal("TGenCollectionProxy","No 'block constructor' function for class %s present.",fName.c_str());
    }
-   if ( 0 == fDestruct.call ) {
+   if ( 0 == fDestruct ) {
       Fatal("TGenCollectionProxy","No 'block destructor' function for class %s present.",fName.c_str());
    }
-   if ( 0 == fFeed.call ) {
+   if ( 0 == fFeed ) {
       Fatal("TGenCollectionProxy","No 'data feed' function for class %s present.",fName.c_str());
    }
    if ( 0 == fCollect.call ) {
@@ -738,39 +766,48 @@
          if ( inside[0].find("__gnu_cxx::hash_") != std::string::npos )
             inside[0].replace(0,16,"std::");
          fSTL_type = TClassEdit::STLKind(inside[0].c_str());
+         switch ( fSTL_type ) {
+            case TClassEdit::kMap:
+            case TClassEdit::kMultiMap:
+            case TClassEdit::kSet:
+            case TClassEdit::kMultiSet:
+               fProperties |= kIsAssociative;
+               break;
+         };
+               
          int slong = sizeof(void*);
          switch ( fSTL_type ) {
-         case TClassEdit::kMap:
-         case TClassEdit::kMultiMap:
-            nam = "pair<"+inside[1]+","+inside[2];
-            nam += (nam[nam.length()-1]=='>') ? " >" : ">";
-            fValue = R__CreateValue(nam);
-
-            fVal   = R__CreateValue(inside[2]);
-            fKey   = R__CreateValue(inside[1]);
-            fPointers = fPointers || (0 != (fKey->fCase&G__BIT_ISPOINTER));
-            if ( 0 == fValDiff ) {
-               fValDiff = fKey->fSize + fVal->fSize;
-               fValDiff += (slong - fKey->fSize%slong)%slong;
-               fValDiff += (slong - fValDiff%slong)%slong;
-            }
-            if ( 0 == fValOffset ) {
-               fValOffset = fKey->fSize;
-               fValOffset += (slong - fKey->fSize%slong)%slong;
-            }
-            break;
-         case TClassEdit::kBitSet:
-            inside[1] = "bool";
-            // Intentional fall through
-         default:
-            fValue = R__CreateValue(inside[1]);
-
-            fVal   = new Value(*fValue);
-            if ( 0 == fValDiff ) {
-               fValDiff = fVal->fSize;
-               fValDiff += (slong - fValDiff%slong)%slong;
-            }
-            break;
+            case TClassEdit::kMap:
+            case TClassEdit::kMultiMap:
+               nam = "pair<"+inside[1]+","+inside[2];
+               nam += (nam[nam.length()-1]=='>') ? " >" : ">";
+               fValue = R__CreateValue(nam);
+               
+               fVal   = R__CreateValue(inside[2]);
+               fKey   = R__CreateValue(inside[1]);
+               fPointers = fPointers || (0 != (fKey->fCase&G__BIT_ISPOINTER));
+               if ( 0 == fValDiff ) {
+                  fValDiff = fKey->fSize + fVal->fSize;
+                  fValDiff += (slong - fKey->fSize%slong)%slong;
+                  fValDiff += (slong - fValDiff%slong)%slong;
+               }
+               if ( 0 == fValOffset ) {
+                  fValOffset = fKey->fSize;
+                  fValOffset += (slong - fKey->fSize%slong)%slong;
+               }
+               break;
+            case TClassEdit::kBitSet:
+               inside[1] = "bool";
+               // Intentional fall through
+            default:
+               fValue = R__CreateValue(inside[1]);
+               
+               fVal   = new Value(*fValue);
+               if ( 0 == fValDiff ) {
+                  fValDiff = fVal->fSize;
+                  fValDiff += (slong - fValDiff%slong)%slong;
+               }
+               break;
          }
 
          fPointers = fPointers || (0 != (fVal->fCase&G__BIT_ISPOINTER));
@@ -791,6 +828,27 @@
 }
 
 //______________________________________________________________________________
+Int_t TGenCollectionProxy::GetCollectionType()
+{
+   // Return the type of collection see TClassEdit::ESTLType
+
+   if (!fClass) {
+      Initialize();
+   }
+   return fSTL_type;
+}
+
+//______________________________________________________________________________
+ULong_t TGenCollectionProxy::GetIncrement() {
+   // Return the offset between two consecutive value_types (memory layout).
+
+   if (!fValue) {
+      Initialize();
+   }
+   return fValDiff;
+}
+
+//______________________________________________________________________________
 UInt_t TGenCollectionProxy::Sizeof() const
 {
    // Return the sizeof the collection object.
@@ -902,7 +960,11 @@
 {
    // Return the current size of the container
    if ( fEnv && fEnv->fObject ) {
-      return *(size_t*)fSize.invoke(fEnv);
+      if (fEnv->fUseTemp) {
+         return fEnv->fSize;
+      } else {
+         return *(size_t*)fSize.invoke(fEnv);
+      }
    }
    Fatal("TGenCollectionProxy","Size> Logic error - no proxy object set.");
    return 0;
@@ -922,7 +984,7 @@
       }
       MESSAGE(3, "Resize(n)" );
       fEnv->fSize = n;
-      fResize.invoke(fEnv);
+      fResize(fEnv->fObject,fEnv->fSize);
       return;
    }
    Fatal("TGenCollectionProxy","Resize> Logic error - no proxy object set.");
@@ -932,73 +994,76 @@
 void* TGenCollectionProxy::Allocate(UInt_t n, Bool_t /* forceDelete */ )
 {
    // Allocate the needed space.
+   // For associative collection, this returns a TStaging object that
+   // need to be deleted manually __or__ returned by calling Commit(TStaging*)
 
    if ( fEnv && fEnv->fObject ) {
       switch ( fSTL_type ) {
-      case TClassEdit::kSet:
-      case TClassEdit::kMultiSet:
-      case TClassEdit::kMap:
-      case TClassEdit::kMultiMap:
-         if ( fPointers )
-            Clear("force");
-         else
-            fClear.invoke(fEnv);
-         ++fEnv->fRefCount;
-         fEnv->fSize  = n;
-         if ( fEnv->fSpace < fValDiff*n ) {
-            fEnv->fTemp = fEnv->fTemp ? ::realloc(fEnv->fTemp,fValDiff*n) : ::malloc(fValDiff*n);
-            fEnv->fSpace = fValDiff*n;
-         }
-         fEnv->fUseTemp = kTRUE;
-         fEnv->fStart = fEnv->fTemp;
-         fConstruct.invoke(fEnv);
-         return fEnv;
-      case TClassEdit::kVector:
-      case TClassEdit::kList:
-      case TClassEdit::kDeque:
-         if( fPointers ) {
-            Clear("force");
-         }
-         fEnv->fSize = n;
-         fResize.invoke(fEnv);
-         return fEnv;
+         case TClassEdit::kSet:
+         case TClassEdit::kMultiSet:
+         case TClassEdit::kMap:
+         case TClassEdit::kMultiMap:
+            if ( fPointers )
+               Clear("force");
+            else
+               fClear.invoke(fEnv);
+            ++fEnv->fRefCount;
+            fEnv->fSize  = n;
 
-      case TClassEdit::kBitSet:
-         // Nothing to do.
-         return fEnv;
+            TStaging *s;
+            if (fStaged.empty()) {
+               s = new TStaging(n,fValDiff);
+            } else {
+               s = fStaged.back();
+               fStaged.pop_back();
+               s->Resize(n);
+            }
+            fConstruct(s->GetContent(),s->GetSize());
+            
+            s->SetTarget(fEnv->fObject);
+
+            fEnv->fTemp = s->GetContent();
+            fEnv->fUseTemp = kTRUE;
+            fEnv->fStart = fEnv->fTemp;
+
+            return s;
+         case TClassEdit::kVector:
+         case TClassEdit::kList:
+         case TClassEdit::kDeque:
+            if( fPointers ) {
+               Clear("force");
+            }
+            fEnv->fSize = n;
+            fResize(fEnv->fObject,n);
+            return fEnv->fObject;
+            
+         case TClassEdit::kBitSet:
+            // Nothing to do.
+            return fEnv->fObject;
       }
    }
    return 0;
 }
 
 //______________________________________________________________________________
-void TGenCollectionProxy::Commit(void* env)
+void TGenCollectionProxy::Commit(void* from)
 {
    // Commit the change.
 
-   switch (fSTL_type) {
-   case TClassEdit::kVector:
-   case TClassEdit::kList:
-   case TClassEdit::kDeque:
-   case TClassEdit::kBitSet:
-      return;
-   case TClassEdit::kMap:
-   case TClassEdit::kMultiMap:
-   case TClassEdit::kSet:
-   case TClassEdit::kMultiSet:
-      if ( env ) {
-         EnvironBase_t* e = (EnvironBase_t*)env;
-         if ( e->fObject ) {
-            e->fStart = e->fTemp;
-            fFeed.invoke(e);
+   if (fProperties & kIsAssociative) {
+//      case TClassEdit::kMap:
+//      case TClassEdit::kMultiMap:
+//      case TClassEdit::kSet:
+//      case TClassEdit::kMultiSet:
+      if ( from ) {
+         TStaging *s = (TStaging*) from;
+         if ( s->GetTarget() ) {
+            fFeed(s->GetContent(),s->GetTarget(),s->GetSize());
          }
-         fDestruct.invoke(e);
-         e->fStart = 0;
-         --e->fRefCount;
+         fDestruct(s->GetContent(),s->GetSize());
+         s->SetTarget(0);
+         fStaged.push_back(s);
       }
-      return;
-   default:
-      return;
    }
 }
 
@@ -1007,6 +1072,8 @@
 {
    // Add an object.
 
+   gSlowIterator__Proxy.push_back(this);
+
    if ( !fValue ) Initialize();
    if ( !fProxyList.empty() ) {
       EnvironBase_t* back = fProxyList.back();
@@ -1020,7 +1087,6 @@
    EnvironBase_t* e    = 0;
    if ( fProxyKept.empty() ) {
       e = (EnvironBase_t*)fCreateEnv.invoke();
-      e->fSpace = 0;
       e->fTemp  = 0;
       e->fUseTemp = kFALSE;
    }
@@ -1043,6 +1109,8 @@
 {
    // Remove the last object.
 
+   gSlowIterator__Proxy.pop_back();
+   
    if ( !fProxyList.empty() ) {
       EnvironBase_t* e = fProxyList.back();
       if ( --e->fRefCount <= 0 ) {
@@ -1080,6 +1148,18 @@
 }
 
 //______________________________________________________________________________
+void TGenCollectionProxy::ReadBuffer(TBuffer & /* b */, void * /* obj */, const TClass * /* onfileClass */)
+{
+   MayNotUse("TGenCollectionProxy::ReadBuffer(TBuffer &, void *, const TClass *)");
+}
+
+//______________________________________________________________________________
+void TGenCollectionProxy::ReadBuffer(TBuffer & /* b */, void * /* obj */)
+{
+   MayNotUse("TGenCollectionProxy::ReadBuffer(TBuffer &, void *)");
+}
+
+//______________________________________________________________________________
 void TGenCollectionProxy::Streamer(TBuffer &buff)
 {
    // Streamer Function.
@@ -1105,3 +1185,334 @@
    Streamer(b, objp, 0);
 }
 
+
+struct TGenCollectionProxy__SlowIterator {
+   TVirtualCollectionProxy *fProxy;
+   UInt_t fIndex;
+   TGenCollectionProxy__SlowIterator(TVirtualCollectionProxy *proxy) : fProxy(proxy), fIndex(0) {}
+};
+
+//______________________________________________________________________________
+void TGenCollectionProxy__SlowCreateIterators(void * /* collection */, void **begin_arena, void **end_arena) 
+{
+   new (*begin_arena) TGenCollectionProxy__SlowIterator(gSlowIterator__Proxy.back());
+   *(UInt_t*)*end_arena = gSlowIterator__Proxy.back()->Size();
+}
+
+//______________________________________________________________________________
+void *TGenCollectionProxy__SlowNext(void *iter, const void *end) 
+{
+   TGenCollectionProxy__SlowIterator *iterator = (TGenCollectionProxy__SlowIterator*)iter;
+   if (iterator->fIndex != *(UInt_t*)end) {
+      void *result = iterator->fProxy->At(iterator->fIndex);
+      ++(iterator->fIndex);
+      return result;
+   } else {
+      return 0;
+   }
+}
+
+//______________________________________________________________________________
+void * TGenCollectionProxy__SlowCopyIterator(void *dest, const void *source) 
+{
+   *(TGenCollectionProxy__SlowIterator*)dest = *(TGenCollectionProxy__SlowIterator*)source;
+   return dest;
+}
+
+//______________________________________________________________________________
+void TGenCollectionProxy__SlowDeleteSingleIterators(void *) 
+{
+   // Nothing to do
+}
+
+//______________________________________________________________________________
+void TGenCollectionProxy__SlowDeleteTwoIterators(void *, void *) 
+{
+   // Nothing to do
+}
+
+
+//______________________________________________________________________________
+void TGenCollectionProxy__VectorCreateIterators(void *obj, void **begin_arena, void **end_arena) 
+{
+   // We can safely assume that the std::vector layout does not really depend on
+   // the content!
+   std::vector<char> *vec = (std::vector<char>*)obj;
+#ifdef R__VISUAL_CPLUSPLUS
+   if (vec->empty()) {
+      *begin_arena = 0;
+      *end_arena = 0;
+      return;
+   }
+   *begin_arena = &(*vec->begin());
+   *end_arena = &(*(vec->end()-1)) + 1; // On windows we can not dererence the end iterator at all.
+#else
+   *begin_arena = &(*vec->begin());
+   *end_arena = &(*vec->end());
+#endif
+   
+   // The following is a safer way but require the caller to have called TPushPop
+   //   TVirtualCollectionProxy *proxy = gSlowIterator__Proxy.back();
+   //   void *good_begin_arena = proxy->At(0);
+   //   void *good_end_arena = ((char*)proxy->At(0)) + proxy->Size() * proxy->GetIncrement();
+}
+
+//______________________________________________________________________________
+void *TGenCollectionProxy__VectorNext(void *, const void *) 
+{
+   // Should not be used.
+   R__ASSERT(0);
+   return 0;
+}
+
+//______________________________________________________________________________
+void *TGenCollectionProxy__VectorCopyIterator(void *dest, const void *source) 
+{
+   *(void**)dest = *(void**)source;
+   return dest;
+}
+
+//______________________________________________________________________________
+void TGenCollectionProxy__VectorDeleteSingleIterators(void *) 
+{
+   // Nothing to do
+}
+
+//______________________________________________________________________________
+void TGenCollectionProxy__VectorDeleteTwoIterators(void *, void *) 
+{
+   // Nothing to do
+}
+
+
+
+//______________________________________________________________________________
+void TGenCollectionProxy__StagingCreateIterators(void *obj, void **begin_arena, void **end_arena) 
+{
+   TGenCollectionProxy::TStaging * s = (TGenCollectionProxy::TStaging*)obj;
+   *begin_arena = s->GetContent();
+   *end_arena = s->GetEnd();
+}
+
+//______________________________________________________________________________
+void *TGenCollectionProxy__StagingNext(void *, const void *) 
+{
+   // Should not be used.
+   R__ASSERT(0);
+   return 0;
+}
+
+//______________________________________________________________________________
+void *TGenCollectionProxy__StagingCopyIterator(void *dest, const void *source) 
+{
+   *(void**)dest = *(void**)source;
+   return dest;
+}
+
+//______________________________________________________________________________
+void TGenCollectionProxy__StagingDeleteSingleIterators(void *) 
+{
+   // Nothing to do
+}
+
+//______________________________________________________________________________
+void TGenCollectionProxy__StagingDeleteTwoIterators(void *, void *) 
+{
+   // Nothing to do
+}
+
+
+//______________________________________________________________________________
+TVirtualCollectionProxy::CreateIterators_t TGenCollectionProxy::GetFunctionCreateIterators(Bool_t read) 
+{
+   // See typedef void (*CreateIterators_t)(void *collection, void *&begin_arena, void *&end_arena);
+   // begin_arena and end_arena should contain the location of memory arena  of size fgIteratorSize. 
+   // If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement)
+   // Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena.
+   
+   if ( fFunctionCreateIterators ) return fFunctionCreateIterators;
+   
+   if ( !fValue ) InitializeEx();
+
+//   fprintf(stderr,"GetFunctinCreateIterator for %s will give: ",fClass.GetClassName());
+//   if (fSTL_type==TClassEdit::kVector || (fProperties & kIsEmulated)) 
+//      fprintf(stderr,"vector/emulated iterator\n");
+//   else if ( (fProperties & kIsAssociative) && read)
+//      fprintf(stderr,"an associative read iterator\n");
+//   else 
+//      fprintf(stderr,"a generic iterator\n");
+      
+   if (fSTL_type==TClassEdit::kVector || (fProperties & kIsEmulated)) 
+      fFunctionCreateIterators = TGenCollectionProxy__VectorCreateIterators;
+   else if ( (fProperties & kIsAssociative) && read)
+      fFunctionCreateIterators = TGenCollectionProxy__StagingCreateIterators;
+   else 
+      fFunctionCreateIterators = TGenCollectionProxy__SlowCreateIterators;
+   return fFunctionCreateIterators;
+}
+
+//______________________________________________________________________________
+TVirtualCollectionProxy::CopyIterator_t TGenCollectionProxy::GetFunctionCopyIterator(Bool_t read)
+{
+   // See typedef void (*CopyIterator_t)(void *&dest, const void *source);
+   // Copy the iterator source, into dest.   dest should contain should contain the location of memory arena  of size fgIteratorSize.
+   // If the collection iterator are of that size or less, the iterator will be constructed in place in this location (new with placement)
+   // Otherwise the iterator will be allocated via a regular new and its address returned by modifying the value of dest.
+   
+   if ( !fValue ) InitializeEx();
+
+   if (fSTL_type==TClassEdit::kVector || (fProperties & kIsEmulated)) 
+      return TGenCollectionProxy__VectorCopyIterator;
+   else if ( (fProperties & kIsAssociative) && read)
+      return TGenCollectionProxy__StagingCopyIterator;
+   else 
+      return TGenCollectionProxy__SlowCopyIterator;
+}
+
+//______________________________________________________________________________
+TVirtualCollectionProxy::Next_t TGenCollectionProxy::GetFunctionNext(Bool_t read)
+{
+   // See typedef void* (*Next_t)(void *iter, void *end);
+   // iter and end should be pointer to respectively an iterator to be incremented and the result of colleciton.end()
+   // 'Next' will increment the iterator 'iter' and return 0 if the iterator reached the end.
+   // If the end is not reached, 'Next' will return the address of the content unless the collection contains pointers in
+   // which case 'Next' will return the value of the pointer.
+   
+   if ( !fValue ) InitializeEx();
+
+//   fprintf(stderr,"GetFunctionNext for %s will give: ",fClass.GetClassName());
+//   if (fSTL_type==TClassEdit::kVector || (fProperties & kIsEmulated)) 
+//      fprintf(stderr,"vector/emulated iterator\n");
+//   else if ( (fProperties & kIsAssociative) && read)
+//      fprintf(stderr,"an associative read iterator\n");
+//   else 
+//      fprintf(stderr,"a generic iterator\n");
+
+   if (fSTL_type==TClassEdit::kVector || (fProperties & kIsEmulated)) 
+      return TGenCollectionProxy__VectorNext;
+   else if ( (fProperties & kIsAssociative) && read)
+      return TGenCollectionProxy__StagingNext;
+   else 
+      return TGenCollectionProxy__SlowNext;
+}
+
+//______________________________________________________________________________
+TVirtualCollectionProxy::DeleteIterator_t TGenCollectionProxy::GetFunctionDeleteIterator(Bool_t read)
+{
+   // See typedef void (*DeleteIterator_t)(void *iter);
+   // If the sizeof iterator is greater than fgIteratorArenaSize, call delete on the addresses,
+   // Otherwise just call the iterator's destructor.
+
+   if ( !fValue ) InitializeEx();
+
+   if (fSTL_type==TClassEdit::kVector || (fProperties & kIsEmulated)) 
+      return TGenCollectionProxy__VectorDeleteSingleIterators;
+   else if ( (fProperties & kIsAssociative) && read)
+      return TGenCollectionProxy__StagingDeleteSingleIterators;
+   else 
+      return TGenCollectionProxy__SlowDeleteSingleIterators;
+}
+
+//______________________________________________________________________________
+TVirtualCollectionProxy::DeleteTwoIterators_t TGenCollectionProxy::GetFunctionDeleteTwoIterators(Bool_t read) 
+{
+   // See typedef void (*DeleteTwoIterators_t)(void *begin, void *end);
+   // If the sizeof iterator is greater than fgIteratorArenaSize, call delete on the addresses,
+   // Otherwise just call the iterator's destructor.
+
+   if ( fFunctionDeleteTwoIterators ) return fFunctionDeleteTwoIterators;
+   
+   if ( !fValue ) InitializeEx();
+   
+   if (fSTL_type==TClassEdit::kVector || (fProperties & kIsEmulated)) 
+      fFunctionDeleteTwoIterators = TGenCollectionProxy__VectorDeleteTwoIterators;
+   else if ( (fProperties & kIsAssociative) && read)
+      fFunctionDeleteTwoIterators = TGenCollectionProxy__StagingDeleteTwoIterators;
+   else 
+      fFunctionDeleteTwoIterators = TGenCollectionProxy__SlowDeleteTwoIterators;
+   return fFunctionDeleteTwoIterators;
+}
+
+//______________________________________________________________________________
+TStreamerInfoActions::TActionSequence *TGenCollectionProxy::GetConversionReadMemberWiseActions(TClass *oldClass, Int_t version)
+{
+   // Return the set of action necessary to stream in this collection member-wise coming from
+   // the old value class layout refered to by 'version'.
+   
+   TObjArray* arr = 0;
+   TStreamerInfoActions::TActionSequence *result = 0;
+   if (fConversionReadMemberWise) {
+      std::map<std::string, TObjArray*>::iterator it;
+      
+      it = fConversionReadMemberWise->find( oldClass->GetName() );
+      
+      if( it != fConversionReadMemberWise->end() ) {
+         arr = it->second;
+      }
+      
+      if (arr) {
+         result = (TStreamerInfoActions::TActionSequence *)arr->At(version);
+         if (result) {
+            return result;
+         }
+      }
+   }
+   
+   // Need to create it.
+   TClass *valueClass = GetValueClass();
+   if (valueClass == 0) {
+      return 0;
+   }
+   TVirtualStreamerInfo *info = valueClass->GetConversionStreamerInfo(oldClass,version);
+   if (info == 0) {
+      return 0;
+   }
+   result = TStreamerInfoActions::TActionSequence::CreateReadMemberWiseActions(info,this);
+
+   if (!arr) {
+      arr = new TObjArray(version+10, -1);
+      if (!fConversionReadMemberWise) {
+         fConversionReadMemberWise = new std::map<std::string, TObjArray*>();
+      }
+      (*fConversionReadMemberWise)[oldClass->GetName()] = arr;
+   }
+   arr->AddAtAndExpand( result, version );
+   
+   return result;
+}
+
+//______________________________________________________________________________
+TStreamerInfoActions::TActionSequence *TGenCollectionProxy::GetReadMemberWiseActions(Int_t version)
+{
+   // Return the set of action necessary to stream in this collection member-wise coming from
+   // the old value class layout refered to by 'version'.
+   
+   TStreamerInfoActions::TActionSequence *result = 0;
+   if (version <= fReadMemberWise->GetSize()) {
+      result = (TStreamerInfoActions::TActionSequence *)fReadMemberWise->At(version);
+   }
+   if (result == 0) {
+      // Need to create it.
+      TClass *valueClass = GetValueClass();
+      if (valueClass == 0) {
+         return 0;
+      }
+      TVirtualStreamerInfo *info = valueClass->GetStreamerInfo(version);
+      if (info == 0) {
+         return 0;
+      }
+      result = TStreamerInfoActions::TActionSequence::CreateReadMemberWiseActions(info,this);
+      fReadMemberWise->AddAtAndExpand(result,version);
+   }
+   return result;
+}
+
+//______________________________________________________________________________
+TStreamerInfoActions::TActionSequence *TGenCollectionProxy::GetWriteMemberWiseActions()
+{
+   // Return the set of action necessary to stream out this collection member-wise.
+ 
+   R__ASSERT(0 /* Not Implemented yet */);
+   return 0;
+}
+
Index: io/io/src/TGenCollectionStreamer.cxx
===================================================================
--- io/io/src/TGenCollectionStreamer.cxx	(revision 35093)
+++ io/io/src/TGenCollectionStreamer.cxx	(working copy)
@@ -30,21 +30,22 @@
 #include "TStreamerInfo.h"
 #include "TStreamerElement.h"
 #include "Riostream.h"
+#include "TVirtualCollectionIterators.h"
 
 TGenCollectionStreamer::TGenCollectionStreamer(const TGenCollectionStreamer& copy)
-      : TGenCollectionProxy(copy)
+      : TGenCollectionProxy(copy), fReadBufferFunc(&TGenCollectionStreamer::ReadBufferDefault)
 {
    // Build a Streamer for an emulated vector whose type is 'name'.
 }
 
 TGenCollectionStreamer::TGenCollectionStreamer(Info_t info, size_t iter_size)
-      : TGenCollectionProxy(info, iter_size)
+      : TGenCollectionProxy(info, iter_size), fReadBufferFunc(&TGenCollectionStreamer::ReadBufferDefault)
 {
    // Build a Streamer for a collection whose type is described by 'collectionClass'.
 }
 
 TGenCollectionStreamer::TGenCollectionStreamer(const ::ROOT::TCollectionProxyInfo &info, TClass *cl)
-      : TGenCollectionProxy(info, cl)
+      : TGenCollectionProxy(info, cl), fReadBufferFunc(&TGenCollectionStreamer::ReadBufferDefault)
 {
    // Build a Streamer for a collection whose type is described by 'collectionClass'.
 }
@@ -61,6 +62,7 @@
    return new TGenCollectionStreamer(*this);
 }
 
+
 void TGenCollectionStreamer::ReadPrimitives(int nElements, TBuffer &b)
 {
    // Primitive input streamer.
@@ -73,7 +75,13 @@
    switch (fSTL_type)  {
       case TClassEdit::kVector:
          if (fVal->fKind != EDataType(kBOOL_t))  {
-            itm = (StreamHelper*)fResize.invoke(fEnv);
+            fResize(fEnv->fObject,fEnv->fSize);
+            fEnv->fIdx = 0;
+            
+            TVirtualVectorIterators iterators(fFunctionCreateIterators);
+            iterators.CreateIterators(fEnv->fObject);
+            itm = (StreamHelper*)iterators.fBegin;
+            fEnv->fStart = itm;
             break;
          }
       default:
@@ -137,7 +145,7 @@
          Error("TGenCollectionStreamer", "fType %d is not supported yet!\n", fVal->fKind);
    }
    if (feed)  {      // need to feed in data...
-      fEnv->fStart = fFeed.invoke(fEnv);
+      fEnv->fStart = fFeed(fEnv->fStart,fEnv->fObject,fEnv->fSize);
       if (memory)  {
          ::operator delete(memory);
       }
@@ -160,7 +168,15 @@
          // Simple case: contiguous memory. get address of first, then jump.
       case TClassEdit::kVector:
 #define DOLOOP(x) {int idx=0; while(idx<nElements) {StreamHelper* i=(StreamHelper*)(((char*)itm) + fValDiff*idx); { x ;} ++idx;} break;}
-         itm = (StreamHelper*)fResize.invoke(fEnv);
+         fResize(fEnv->fObject,fEnv->fSize);
+         fEnv->fIdx = 0;
+         
+         {
+            TVirtualVectorIterators iterators(fFunctionCreateIterators);
+            iterators.CreateIterators(fEnv->fObject);
+            itm = (StreamHelper*)iterators.fBegin;
+         }
+         fEnv->fStart = itm;
          switch (fVal->fCase) {
             case G__BIT_ISCLASS:
                DOLOOP(b.StreamObject(i, fVal->fType, onFileValClass ));
@@ -181,7 +197,9 @@
       case TClassEdit::kList:
       case TClassEdit::kDeque:
 #define DOLOOP(x) {int idx=0; while(idx<nElements) {StreamHelper* i=(StreamHelper*)TGenCollectionProxy::At(idx); { x ;} ++idx;} break;}
-         fResize.invoke(fEnv);
+         fResize(fEnv->fObject,fEnv->fSize);
+         fEnv->fIdx = 0;
+         fEnv->fStart = 0;
          switch (fVal->fCase) {
             case G__BIT_ISCLASS:
                DOLOOP(b.StreamObject(i, fVal->fType, onFileValClass));
@@ -203,29 +221,29 @@
       case TClassEdit::kSet:
 #define DOLOOP(x) {int idx=0; while(idx<nElements) {StreamHelper* i=(StreamHelper*)(((char*)itm) + fValDiff*idx); { x ;} ++idx;}}
          fEnv->fStart = itm = (StreamHelper*)(len < sizeof(buffer) ? buffer : memory =::operator new(len));
-         fConstruct.invoke(fEnv);
+         fConstruct(itm,nElements);
          switch (fVal->fCase) {
             case G__BIT_ISCLASS:
                DOLOOP(b.StreamObject(i, fVal->fType, onFileValClass));
-               fFeed.invoke(fEnv);
-               fDestruct.invoke(fEnv);
+               fFeed(fEnv->fStart,fEnv->fObject,fEnv->fSize);
+               fDestruct(fEnv->fStart,fEnv->fSize);
                break;
             case kBIT_ISSTRING:
                DOLOOP(i->read_std_string(b))
-               fFeed.invoke(fEnv);
-               fDestruct.invoke(fEnv);
+               fFeed(fEnv->fStart,fEnv->fObject,fEnv->fSize);
+               fDestruct(fEnv->fStart,fEnv->fSize);
                break;
             case G__BIT_ISPOINTER | G__BIT_ISCLASS:
                DOLOOP(i->set(b.ReadObjectAny(fVal->fType)));
-               fFeed.invoke(fEnv);
+               fFeed(fEnv->fStart,fEnv->fObject,fEnv->fSize);
                break;
             case G__BIT_ISPOINTER | kBIT_ISSTRING:
                DOLOOP(i->read_std_string_pointer(b))
-               fFeed.invoke(fEnv);
+               fFeed(fEnv->fStart,fEnv->fObject,fEnv->fSize);
                break;
             case G__BIT_ISPOINTER | kBIT_ISTSTRING | G__BIT_ISCLASS:
                DOLOOP(i->read_tstring_pointer(vsn3, b));
-               fFeed.invoke(fEnv);
+               fFeed(fEnv->fStart,fEnv->fObject,fEnv->fSize);
                break;
          }
 #undef DOLOOP
@@ -264,7 +282,15 @@
          // Simple case: contiguous memory. get address of first, then jump.
       case TClassEdit::kVector:
 #define DOLOOP(x) {int idx=0; while(idx<nElements) {StreamHelper* i=(StreamHelper*)(((char*)itm) + fValDiff*idx); { x ;} ++idx;} break;}
-         itm = (StreamHelper*)fResize.invoke(fEnv);
+         fResize(fEnv->fObject,fEnv->fSize);
+         fEnv->fIdx = 0;
+         
+         {
+            TVirtualVectorIterators iterators(fFunctionCreateIterators);
+            iterators.CreateIterators(fEnv->fObject);
+            itm = (StreamHelper*)iterators.fBegin;
+         }
+         fEnv->fStart = itm;
          switch (fVal->fCase) {
             case G__BIT_ISCLASS:
                DOLOOP(
@@ -280,7 +306,13 @@
       case TClassEdit::kList:
       case TClassEdit::kDeque:
 #define DOLOOP(x) {int idx=0; while(idx<nElements) {StreamHelper* i=(StreamHelper*)TGenCollectionProxy::At(idx); { x ;} ++idx;} break;}
-         fResize.invoke(fEnv);
+         fResize(fEnv->fObject,fEnv->fSize);
+         fEnv->fIdx = 0;
+         {
+            TVirtualVectorIterators iterators(fFunctionCreateIterators);
+            iterators.CreateIterators(fEnv->fObject);
+            fEnv->fStart = iterators.fBegin;
+         }
          switch (fVal->fCase) {
             case G__BIT_ISCLASS:
                DOLOOP(
@@ -297,15 +329,15 @@
       case TClassEdit::kSet:
 #define DOLOOP(x) {int idx=0; while(idx<nElements) {StreamHelper* i=(StreamHelper*)(((char*)itm) + fValDiff*idx); { x ;} ++idx;}}
          fEnv->fStart = itm = (StreamHelper*)(len < sizeof(buffer) ? buffer : memory =::operator new(len));
-         fConstruct.invoke(fEnv);
+         fConstruct(itm,nElements);
          switch (fVal->fCase) {
             case G__BIT_ISCLASS:
                DOLOOP(
                   char **where = (char**)(void*) & i;
                   pinfo->ReadBuffer(b, where, -1);
                );
-               fFeed.invoke(fEnv);
-               fDestruct.invoke(fEnv);
+               fFeed(fEnv->fStart,fEnv->fObject,fEnv->fSize);
+               fDestruct(fEnv->fStart,fEnv->fSize);
                break;
          }
 #undef DOLOOP
@@ -416,7 +448,7 @@
    fEnv->fSize  = nElements;
    fEnv->fStart = (len < sizeof(buffer) ? buffer : memory =::operator new(len));
    addr = temp = (char*)fEnv->fStart;
-   fConstruct.invoke(fEnv);
+   fConstruct(addr,nElements);
    for (int loop, idx = 0; idx < nElements; ++idx)  {
       addr = temp + fValDiff * idx;
       v = fKey;
@@ -502,8 +534,8 @@
          addr += fValOffset;
       }
    }
-   fFeed.invoke(fEnv);
-   fDestruct.invoke(fEnv);
+   fFeed(fEnv->fStart,fEnv->fObject,fEnv->fSize);
+   fDestruct(fEnv->fStart,fEnv->fSize);
    if (memory) {
       ::operator delete(memory);
    }
@@ -732,6 +764,207 @@
    }
 }
 
+template <typename basictype>
+void TGenCollectionStreamer::ReadBufferVectorPrimitives(TBuffer &b, void *obj)
+{
+   int nElements = 0;
+   b >> nElements;
+   fResize(obj,nElements);
+   
+   TVirtualVectorIterators iterators(fFunctionCreateIterators);
+   iterators.CreateIterators(obj);
+   b.ReadFastArray((basictype*)iterators.fBegin, nElements);
+}
+
+void TGenCollectionStreamer::ReadBufferVectorPrimitivesFloat16(TBuffer &b, void *obj)
+{
+   int nElements = 0;
+   b >> nElements;
+   fResize(obj,nElements);
+   
+   TVirtualVectorIterators iterators(fFunctionCreateIterators);
+   iterators.CreateIterators(obj);
+   b.ReadFastArrayFloat16((Float16_t*)iterators.fBegin, nElements);
+}
+
+void TGenCollectionStreamer::ReadBufferVectorPrimitivesDouble32(TBuffer &b, void *obj)
+{
+   int nElements = 0;
+   b >> nElements;
+   fResize(obj,nElements);
+   
+   TVirtualVectorIterators iterators(fFunctionCreateIterators);
+   iterators.CreateIterators(obj);
+   b.ReadFastArrayDouble32((Double32_t*)iterators.fBegin, nElements);
+}
+
+
+
+void TGenCollectionStreamer::ReadBuffer(TBuffer &b, void *obj, const TClass *onFileClass)
+{
+   // Call the specialized function.  The first time this call ReadBufferDefault which
+   // actually set to fReadBufferFunc to the 'right' specialized version.
+   
+   SetOnFileClass((TClass*)onFileClass);
+   (this->*fReadBufferFunc)(b,obj);
+}
+
+void TGenCollectionStreamer::ReadBuffer(TBuffer &b, void *obj)
+{
+   // Call the specialized function.  The first time this call ReadBufferDefault which
+   // actually set to fReadBufferFunc to the 'right' specialized version.
+   
+   (this->*fReadBufferFunc)(b,obj);
+}
+
+void TGenCollectionStreamer::ReadBufferDefault(TBuffer &b, void *obj)
+{
+ 
+   fReadBufferFunc = &TGenCollectionStreamer::ReadBufferGeneric;
+   // We will need this later, so let's make sure it is initialized.
+   if (!GetFunctionCreateIterators()) {
+      Fatal("TGenCollectionStreamer::ReadBufferDefault","No CreateIterators function for %s",fName.c_str());
+   }
+   if (fSTL_type == TClassEdit::kVector && ( fVal->fCase == G__BIT_ISFUNDAMENTAL || fVal->fCase == G__BIT_ISENUM ) )
+   {
+      // Only handle primitives this way
+      switch (int(fVal->fKind))   {
+         case kBool_t:
+            // Nothing use generic for now
+            break;
+         case kChar_t:
+            fReadBufferFunc = &TGenCollectionStreamer::ReadBufferVectorPrimitives<Char_t>;
+            break;
+         case kShort_t:
+            fReadBufferFunc = &TGenCollectionStreamer::ReadBufferVectorPrimitives<Short_t>;
+            break;
+         case kInt_t:
+            fReadBufferFunc = &TGenCollectionStreamer::ReadBufferVectorPrimitives<Int_t>;
+            break;
+         case kLong_t:
+            fReadBufferFunc = &TGenCollectionStreamer::ReadBufferVectorPrimitives<Long_t>;
+            break;
+         case kLong64_t:
+            fReadBufferFunc = &TGenCollectionStreamer::ReadBufferVectorPrimitives<Long64_t>;
+            break;
+         case kFloat_t:
+            fReadBufferFunc = &TGenCollectionStreamer::ReadBufferVectorPrimitives<Float_t>;
+            break;
+         case kFloat16_t:
+            fReadBufferFunc = &TGenCollectionStreamer::ReadBufferVectorPrimitivesFloat16;
+            break;
+         case kDouble_t:
+            fReadBufferFunc = &TGenCollectionStreamer::ReadBufferVectorPrimitives<Double_t>;
+            break;
+//         case kBOOL_t:
+//            fReadBufferFunc = &ReadBufferVectorPrimitives<>;
+//            break;
+         case kUChar_t:
+            fReadBufferFunc = &TGenCollectionStreamer::ReadBufferVectorPrimitives<UChar_t>;
+            break;
+         case kUShort_t:
+            fReadBufferFunc = &TGenCollectionStreamer::ReadBufferVectorPrimitives<UShort_t>;
+            break;
+         case kUInt_t:
+            fReadBufferFunc = &TGenCollectionStreamer::ReadBufferVectorPrimitives<UInt_t>;
+            break;
+         case kULong_t:
+            fReadBufferFunc = &TGenCollectionStreamer::ReadBufferVectorPrimitives<ULong_t>;
+            break;
+         case kULong64_t:
+            fReadBufferFunc = &TGenCollectionStreamer::ReadBufferVectorPrimitives<ULong64_t>;
+            break;
+         case kDouble32_t:
+            fReadBufferFunc = &TGenCollectionStreamer::ReadBufferVectorPrimitivesDouble32;
+            break;
+         case kchar:
+         case kNoType_t:
+         case kOther_t:
+            // Nothing use the generic for now
+            break;
+      }
+   }
+   (this->*fReadBufferFunc)(b,obj);
+}
+
+void TGenCollectionStreamer::ReadBufferGeneric(TBuffer &b, void *obj)
+{
+   TVirtualCollectionProxy::TPushPop env(this, obj);
+
+   int nElements = 0;
+   b >> nElements;
+
+   if (nElements == 0) {
+      if (obj) {
+         TGenCollectionProxy::Clear("force");
+      }
+   } else if (nElements > 0)  {
+      switch (fSTL_type)  {
+         case TClassEdit::kBitSet:
+            if (obj) {
+               if (fPointers)   {
+                  TGenCollectionProxy::Clear("force");
+               }  else {
+                  fClear.invoke(fEnv);
+               }
+            }
+            ReadPrimitives(nElements, b);
+            return;
+         case TClassEdit::kVector:
+            if (obj) {
+               if (fPointers)   {
+                  TGenCollectionProxy::Clear("force");
+               } // a resize will be called in ReadPrimitives/ReadObjects.
+               else if (fVal->fKind == EDataType(kBOOL_t)) {
+                  fClear.invoke(fEnv);                  
+               }
+            }
+            switch (fVal->fCase) {
+               case G__BIT_ISFUNDAMENTAL:  // Only handle primitives this way
+               case G__BIT_ISENUM:
+                  ReadPrimitives(nElements, b);
+                  return;
+               default:
+                  ReadObjects(nElements, b);
+                  return;
+            }
+            break;
+         case TClassEdit::kList:
+         case TClassEdit::kDeque:
+         case TClassEdit::kMultiSet:
+         case TClassEdit::kSet:
+            if (obj) {
+               if (fPointers)   {
+                  TGenCollectionProxy::Clear("force");
+               }  else {
+                  fClear.invoke(fEnv);
+               }
+            }
+            switch (fVal->fCase) {
+               case G__BIT_ISFUNDAMENTAL:  // Only handle primitives this way
+               case G__BIT_ISENUM:
+                  ReadPrimitives(nElements, b);
+                  return;
+               default:
+                  ReadObjects(nElements, b);
+                  return;
+            }
+            break;
+         case TClassEdit::kMap:
+         case TClassEdit::kMultiMap:
+            if (obj) {
+               if (fPointers)   {
+                  TGenCollectionProxy::Clear("force");
+               }  else {
+                  fClear.invoke(fEnv);
+               }
+            }
+            ReadMap(nElements, b);
+            break;
+      }
+   }
+}
+
 void TGenCollectionStreamer::Streamer(TBuffer &b)
 {
    // TClassStreamer IO overload.
Index: io/io/inc/TBufferFile.h
===================================================================
--- io/io/inc/TBufferFile.h	(revision 35093)
+++ io/io/inc/TBufferFile.h	(working copy)
@@ -49,7 +49,6 @@
 
 protected:
    typedef std::vector<TStreamerInfo*> InfoList_t;
-   typedef std::vector<TVirtualArray*> CacheList_t;
 
    Int_t           fMapCount;      //Number of objects or classes in map
    Int_t           fMapSize;       //Default size of map
@@ -59,14 +58,13 @@
    TExMap         *fClassMap;      //Map containing object,class pairs for reading
    TStreamerInfo  *fInfo;          //Pointer to TStreamerInfo object writing/reading the buffer
    InfoList_t      fInfoStack;     //Stack of pointers to the TStreamerInfos
-   CacheList_t     fCacheStack;    //Stack of pointers to the cache where to temporarily store the value of 'missing' data members
 
    static Int_t    fgMapSize;      //Default map size for all TBuffer objects
 
    // Default ctor
    TBufferFile() : TBuffer(), fMapCount(0), fMapSize(0),
                fDisplacement(0),fPidOffset(0), fMap(0), fClassMap(0),
-     fInfo(0), fInfoStack(), fCacheStack() {}
+     fInfo(0), fInfoStack() {}
 
    // TBuffer objects cannot be copied or assigned
    TBufferFile(const TBufferFile &);       // not implemented
@@ -108,6 +106,7 @@
    virtual Int_t      CheckByteCount(UInt_t startpos, UInt_t bcnt, const char *classname);
    virtual void       SetByteCount(UInt_t cntpos, Bool_t packInVersion = kFALSE);
 
+   virtual void       SkipVersion(const TClass *cl = 0);
    virtual Version_t  ReadVersion(UInt_t *start = 0, UInt_t *bcnt = 0, const TClass *cl = 0);
    virtual UInt_t     WriteVersion(const TClass *cl, Bool_t useBcnt = kFALSE);
    virtual UInt_t     WriteVersionMemberWise(const TClass *cl, Bool_t useBcnt = kFALSE);
@@ -123,10 +122,6 @@
    virtual void       ClassEnd(const TClass*) {}
    virtual void       ClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1) {}
 
-   virtual TVirtualArray *PeekDataCache() const;
-   virtual TVirtualArray *PopDataCache();
-   virtual void           PushDataCache(TVirtualArray *);
-
    virtual Int_t      ReadBuf(void *buf, Int_t max);
    virtual void       WriteBuf(const void *buf, Int_t max);
 
@@ -156,7 +151,11 @@
    virtual   void     WriteFloat16(Float_t *f, TStreamerElement *ele=0);
    virtual   void     ReadDouble32 (Double_t *d, TStreamerElement *ele=0);
    virtual   void     WriteDouble32(Double_t *d, TStreamerElement *ele=0);
-
+   virtual   void     ReadWithFactor(Float_t *ptr, Double_t factor, Double_t minvalue);
+   virtual   void     ReadWithNbits(Float_t *ptr, Int_t nbits);
+   virtual   void     ReadWithFactor(Double_t *ptr, Double_t factor, Double_t minvalue);
+   virtual   void     ReadWithNbits(Double_t *ptr, Int_t nbits);
+   
    virtual   Int_t    ReadArray(Bool_t    *&b);
    virtual   Int_t    ReadArray(Char_t    *&c);
    virtual   Int_t    ReadArray(UChar_t   *&c);
Index: io/io/inc/TEmulatedCollectionProxy.h
===================================================================
--- io/io/inc/TEmulatedCollectionProxy.h	(revision 35093)
+++ io/io/inc/TEmulatedCollectionProxy.h	(working copy)
@@ -107,6 +107,10 @@
    // Block commit of containees
    virtual void Commit(void* env);
 
+   // Read portion of the streamer
+   virtual void ReadBuffer(TBuffer &buff, void *pObj);
+   virtual void ReadBuffer(TBuffer &buff, void *pObj, const TClass *onfile);
+
    // Streamer for I/O handling
    virtual void Streamer(TBuffer &refBuffer);
 
Index: io/io/inc/TCollectionProxyFactory.h
===================================================================
--- io/io/inc/TCollectionProxyFactory.h	(revision 35093)
+++ io/io/inc/TCollectionProxyFactory.h	(working copy)
@@ -28,10 +28,15 @@
 #ifndef ROOT_TClassStreamer
 #include "TClassStreamer.h"
 #endif
+
 #ifndef ROOT_TMemberStreamer
 #include "TMemberStreamer.h"
 #endif
 
+#ifndef ROOT_TGenCollectionProxy
+#include "TGenCollectionProxy.h"
+#endif
+
 // Forward declarations
 class TBuffer;
 class TGenCollectionProxy;
@@ -154,7 +159,7 @@
    /// Attach worker proxy
    void AdoptStreamer(TGenCollectionProxy* streamer);
    /// Streamer for I/O handling
-   void Streamer(TBuffer &refBuffer, void *pObject, int siz, TClass *onFileClass );
+   void Streamer(TBuffer &refBuffer, void *obj, int siz, TClass *onFileClass );
 };
 
 /** @class TEmulatedClassStreamer TCollectionProxy.h cont/TCollectionProxy.h
@@ -177,10 +182,25 @@
    /// Standard destructor
    virtual ~TCollectionClassStreamer()                {                        }
    /// Streamer for I/O handling
-   virtual void operator()(TBuffer &buff, void *pObj ) { Streamer(buff,pObj,0,fOnFileClass); }
+   virtual void operator()(TBuffer &buff, void *obj ) { Streamer(buff,obj,0,fOnFileClass); }
 
+   virtual void Stream(TBuffer &b, void *obj, const TClass *onfileClass)
+   {
+      if (b.IsReading()) {
+         TGenCollectionProxy *proxy = TCollectionStreamer::fStreamer;
+         if (onfileClass==0 || onfileClass == proxy->GetCollectionClass()) {
+            proxy->ReadBuffer(b,obj);
+         } else {
+            proxy->ReadBuffer(b,obj,onfileClass);
+         }
+      } else {
+         // fStreamer->WriteBuffer(b,objp,onfileClass);
+         Streamer(b,obj,0,(TClass*)onfileClass);
+      }
+   }
+   
    /// Virtual copy constructor.
-   virtual TClassStreamer *Generate() {
+   virtual TClassStreamer *Generate() const {
       return new TCollectionClassStreamer(*this);
    }
 
@@ -208,8 +228,8 @@
    /// Standard destructor
    virtual ~TCollectionMemberStreamer()             { }
    /// Streamer for I/O handling
-   virtual void operator()(TBuffer &buff,void *pObj,Int_t siz=0)
-   { Streamer(buff, pObj, siz, 0); /* FIXME */ }
+   virtual void operator()(TBuffer &buff,void *obj,Int_t siz=0)
+   { Streamer(buff, obj, siz, 0); /* FIXME */ }   
 };
 
 #endif
Index: io/io/inc/TGenCollectionProxy.h
===================================================================
--- io/io/inc/TGenCollectionProxy.h	(revision 35093)
+++ io/io/inc/TGenCollectionProxy.h	(working copy)
@@ -25,10 +25,26 @@
 //
 //////////////////////////////////////////////////////////////////////////
 
+#ifndef ROOT_TVirtualCollectionProxy
 #include "TVirtualCollectionProxy.h"
-#include "TCollectionProxyFactory.h"
+#endif
+
+#ifndef ROOT_TCollectionProxyInfo
+#include "TCollectionProxyInfo.h"
+#endif
+
 #include <typeinfo>
 #include <string>
+#include <map>
+#ifndef __CINT__
+#if defined(__APPLE__)
+#include <stdlib.h>
+#else
+#include <malloc.h>
+#endif
+#endif
+class TObjArray;
+class TCollectionProxyFactory;
 
 class TGenCollectionProxy
    : public TVirtualCollectionProxy
@@ -53,7 +69,6 @@
       kBOOL_t = 21
    };
 
-
    /** @class TGenCollectionProxy::Value TGenCollectionProxy.h TGenCollectionProxy.h
     *
     * Small helper to describe the Value_type or the key_type
@@ -223,22 +238,86 @@
       Method0(const Method0& m) : call(m.call)   {      }
       void* invoke() const { return (*call)(); }
    };
+ 
+   /** @class TGenCollectionProxy::TStaging
+    *
+    * Small helper to stage the content of an associative
+    * container when reading and before inserting it in the 
+    * actual collection.
+    *
+    * @author  Ph.Canal
+    * @version 1.0
+    * @date    20/08/2010
+    */
+   class TStaging  {
+      void   *fTarget;   // Pointer to the collection we are staging for.
+      void   *fContent;  // Pointer to the content
+      size_t  fReserved; // Amount of space already reserved.
+      size_t  fSize;     // Number of elements
+      size_t  fSizeOf;   // size of each elements
+   public:
+      TStaging(size_t size, size_t size_of) : fTarget(0), fContent(0), fReserved(0), fSize(size), fSizeOf(size_of)
+      {
+         // Usual constructor.  Reserves the required number of elements.
+         fReserved = fSize;
+         fContent = ::malloc(fReserved * fSizeOf);
+      }
+      
+      ~TStaging() {
+         // Usual destructor
+         ::free(fContent);
+      }
+      
+      void   *GetContent() {
+         // Return the location of the array of content.
+         return fContent;
+      }
+      void   *GetEnd() {
+         // Return the 'end' of the array of content.
+         return ((char*)fContent) + fSize*fSizeOf;
+      }
+      size_t  GetSize() {
+         // Return the number of elements. 
+         return fSize;
+      }
+      void   *GetTarget() {
+         // Get the address of the collection we are staging for.
+         return fTarget;
+      }
+      void    Resize(size_t nelement) {
+         if (fReserved < nelement) {
+            fReserved = nelement;
+            fContent = ::realloc(fContent,fReserved * fSizeOf);
+         }
+         fSize = nelement;
+      }
+      void SetTarget(void *target) {
+         // Set the collection we are staging for.
+         fTarget = target;
+      }
+   };
    
 protected:
    typedef ROOT::TCollectionProxyInfo::Environ<char[64]> Env_t;
    typedef ROOT::TCollectionProxyInfo::EnvironBase EnvironBase_t;
+   typedef std::vector<TStaging*>          Staged_t;  // Collection of pre-allocated staged array for associative containers.
    typedef std::vector<EnvironBase_t*>     Proxies_t;
+   mutable TObjArray *fReadMemberWise;                                   //Array of bundle of TStreamerInfoActions to stream out (read)
+   mutable std::map<std::string, TObjArray*> *fConversionReadMemberWise; //Array of bundle of TStreamerInfoActions to stream out (read) derived from another class.
+   typedef void (*Sizing_t)(void *obj, size_t size);
+   typedef void* (*Feedfunc_t)(void *from, void *to, size_t size);
+   typedef void* (*ArrIterfunc_t)(void *from, size_t size);
 
    std::string   fName;      // Name of the class being proxied.
    Bool_t        fPointers;  // Flag to indicate if containee has pointers (key or value)
    Method        fClear;     // Method cache for container accessors: clear container
    Method        fSize;      // Container accessors: size of container
-   Method        fResize;    // Container accessors: resize container
+   Sizing_t      fResize;    // Container accessors: resize container
    Method        fFirst;     // Container accessors: generic iteration: first
    Method        fNext;      // Container accessors: generic iteration: next
-   Method        fConstruct; // Container accessors: block construct
-   Method        fDestruct;  // Container accessors: block destruct
-   Method        fFeed;      // Container accessors: block feed
+   ArrIterfunc_t fConstruct; // Container accessors: block construct
+   Sizing_t      fDestruct;  // Container accessors: block destruct
+   Feedfunc_t    fFeed;      // Container accessors: block feed
    Method        fCollect;   // Method to collect objects from container
    Method0       fCreateEnv; // Method to allocate an Environment holder.
    Value*        fValue;     // Descriptor of the container value type
@@ -249,9 +328,13 @@
    int           fValDiff;   // Offset between two consecutive value_types (memory layout).
    Proxies_t     fProxyList; // Stack of recursive proxies
    Proxies_t     fProxyKept; // Optimization: Keep proxies once they were created
+   Staged_t      fStaged;    // Optimization: Keep staged array once they were created
    int           fSTL_type;  // STL container type
    Info_t        fTypeinfo;  // Type information
    TClass*       fOnFileClass; // On file class
+   
+   CreateIterators_t    fFunctionCreateIterators;
+   DeleteTwoIterators_t fFunctionDeleteTwoIterators;
 
    // Late initialization of collection proxy
    TGenCollectionProxy* Initialize() const;
@@ -261,7 +344,9 @@
    virtual void DeleteItem(Bool_t force, void* ptr) const;
    // Allow to check function pointers.
    void CheckFunctions()  const;
-
+private:
+   TGenCollectionProxy(); // not implemented on purpose.
+   
 public:
 
    // Virtual copy constructor.
@@ -280,6 +365,12 @@
    // Return a pointer to the TClass representing the container.
    virtual TClass *GetCollectionClass();
 
+   // Return the type of collection see TClassEdit::ESTLType
+   virtual Int_t   GetCollectionType();
+
+   // Return the offset between two consecutive value_types (memory layout).
+   virtual ULong_t   GetIncrement();
+
    // Return the sizeof the collection object.
    virtual UInt_t Sizeof() const;
 
@@ -327,9 +418,48 @@
 
    // TClassStreamer I/O overload.
    virtual void operator()(TBuffer &refBuffer, void *pObject);
+   
+   // Routine to read the content of the buffer into 'obj'.
+   virtual void ReadBuffer(TBuffer &b, void *obj);
+   virtual void ReadBuffer(TBuffer &b, void *obj, const TClass *onfileClass);
 
    virtual void SetOnFileClass( TClass* cl ) { fOnFileClass = cl; }
    virtual TClass* GetOnFileClass() const { return fOnFileClass; }
+
+   // MemberWise actions
+   virtual TStreamerInfoActions::TActionSequence *GetConversionReadMemberWiseActions(TClass *oldClass, Int_t version);
+   virtual TStreamerInfoActions::TActionSequence *GetReadMemberWiseActions(Int_t version);
+   virtual TStreamerInfoActions::TActionSequence *GetWriteMemberWiseActions();
+
+   // Set of functions to iterate easily throught the collection
+   
+   virtual CreateIterators_t GetFunctionCreateIterators(Bool_t read = kTRUE); 
+   // typedef void (*CreateIterators_t)(void *collection, void **begin_arena, void **end_arena);
+   // begin_arena and end_arena should contain the location of memory arena  of size fgIteratorSize. 
+   // If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement)
+   // Otherwise the iterators will be allocated via a regular new and their address returned by modifying the value of begin_arena and end_arena.
+   
+   virtual CopyIterator_t GetFunctionCopyIterator(Bool_t read = kTRUE);
+   // typedef void* (*CopyIterator_t)(void *dest, const void *source);
+   // Copy the iterator source, into dest.   dest should contain should contain the location of memory arena  of size fgIteratorSize.
+   // If the collection iterator are of that size or less, the iterator will be constructed in place in this location (new with placement)
+   // Otherwise the iterator will be allocated via a regular new and its address returned by modifying the value of dest.
+   
+   virtual Next_t GetFunctionNext(Bool_t read = kTRUE);
+   // typedef void* (*Next_t)(void *iter, const void *end);
+   // iter and end should be pointer to respectively an iterator to be incremented and the result of collection.end()
+   // If the iterator has not reached the end of the collection, 'Next' increment the iterator 'iter' and return 0 if 
+   // the iterator reached the end.
+   // If the end was not reached, 'Next' returns the address of the content pointed to by the iterator before the 
+   // incrementation ; if the collection contains pointers 'Next' will return the value of the pointer.   
+
+   virtual DeleteIterator_t GetFunctionDeleteIterator(Bool_t read = kTRUE);
+   virtual DeleteTwoIterators_t GetFunctionDeleteTwoIterators(Bool_t read = kTRUE);
+   // typedef void (*DeleteIterator_t)(void *iter);
+   // typedef void (*DeleteTwoIterators_t)(void *begin, void *end);
+   // If the sizeof iterator is greater than fgIteratorArenaSize, call delete on the addresses,
+   // Otherwise just call the iterator's destructor.
+   
 };
 
 template <typename T>
@@ -341,13 +471,13 @@
       fValDiff        = sizeof(T::Value_t);
       fValOffset      = T::value_offset();
       fSize.call      = T::size;
-      fResize.call    = T::resize;
+      fResize         = T::resize;
       fNext.call      = T::next;
       fFirst.call     = T::first;
       fClear.call     = T::clear;
-      fConstruct.call = T::construct;
-      fDestruct.call  = T::destruct;
-      fFeed.call      = T::feed;
+      fConstruct      = T::construct;
+      fDestruct       = T::destruct;
+      fFeed           = T::feed;
       CheckFunctions();
    }
    virtual ~AnyCollectionProxy() {  }
Index: io/io/inc/TGenCollectionStreamer.h
===================================================================
--- io/io/inc/TGenCollectionStreamer.h	(revision 35093)
+++ io/io/inc/TGenCollectionStreamer.h	(working copy)
@@ -21,6 +21,7 @@
 //////////////////////////////////////////////////////////////////////////
 
 #include "TGenCollectionProxy.h"
+#include "TCollectionProxyFactory.h"
 
 class TGenCollectionStreamer : public TGenCollectionProxy {
 
@@ -34,6 +35,18 @@
    void WriteObjects(int nElements, TBuffer &b);
    void WritePrimitives(int nElements, TBuffer &b);
 
+//   typedef void (TGenCollectionStreamer::*ReadBufferConv_t)(TBuffer &b, void *obj, const TClass *onfileClass);
+//   ReadBufferConv_t fReadBufferConvFunc;
+   
+   typedef void (TGenCollectionStreamer::*ReadBuffer_t)(TBuffer &b, void *obj);
+   ReadBuffer_t fReadBufferFunc;
+   
+   template <typename basictype> void ReadBufferVectorPrimitives(TBuffer &b, void *obj);
+   void ReadBufferVectorPrimitivesFloat16(TBuffer &b, void *obj);
+   void ReadBufferVectorPrimitivesDouble32(TBuffer &b, void *obj);
+   void ReadBufferDefault(TBuffer &b, void *obj);
+   void ReadBufferGeneric(TBuffer &b, void *obj);
+      
 public:
    // Virtual copy constructor
    virtual TVirtualCollectionProxy* Generate() const;
@@ -58,6 +71,12 @@
    virtual void Streamer(TBuffer &buff, void *pObj, int siz)  {
       TGenCollectionProxy::Streamer(buff, pObj, siz);
    }
+
+   // Routine to read the content of the buffer into 'obj'.
+   virtual void ReadBuffer(TBuffer &b, void *obj, const TClass *onfileClass);
+
+   // Routine to read the content of the buffer into 'obj'.
+   virtual void ReadBuffer(TBuffer &b, void *obj);
 };
 
 template <typename T>
@@ -70,11 +89,11 @@
       fFirst.call     = T::first;
       fNext.call      = T::next;
       fClear.call     = T::clear;
-      fResize.call    = T::resize;
+      fResize         = T::resize;
       fCollect.call   = T::collect;
-      fConstruct.call = T::construct;
-      fDestruct.call  = T::destruct;
-      fFeed.call      = T::feed;
+      fConstruct      = T::construct;
+      fDestruct       = T::destruct;
+      fFeed           = T::feed;
       CheckFunctions();
    }
    virtual ~AnyCollectionStreamer() {  }
Index: io/io/inc/LinkDef.h
===================================================================
--- io/io/inc/LinkDef.h	(revision 35093)
+++ io/io/inc/LinkDef.h	(working copy)
@@ -43,4 +43,9 @@
 #pragma link C++ options=version(0) class TVirtualObject-;
 #pragma link C++ options=version(0) class TVirtualArray-;
 
+#pragma link C++ namespace TStreamerInfoActions;
+#pragma link C++ class TStreamerInfoActions::TConfiguredAction+;
+#pragma link C++ class TStreamerInfoActions::TActionSequence+;
+#pragma link C++ class TStreamerInfoActions::TConfiguration-;
+
 #endif
Index: io/io/inc/TStreamerInfo.h
===================================================================
--- io/io/inc/TStreamerInfo.h	(revision 35093)
+++ io/io/inc/TStreamerInfo.h	(working copy)
@@ -44,6 +44,8 @@
 class TVirtualArray;
 namespace ROOT { class TCollectionProxyInfo; }
 
+namespace TStreamerInfoActions { class TActionSequence; }
+
 class TStreamerInfo : public TVirtualStreamerInfo {
 
 #ifdef R__BROKEN_FUNCTION_TEMPLATES
@@ -80,7 +82,7 @@
          return *el;
       }
    private:
-     TVirtualCollectionProxy *fProxy;
+      TVirtualCollectionProxy *fProxy;
    };
 
 private:
@@ -104,6 +106,9 @@
    ULong_t          *fVirtualInfoLoc;    //![fNVirtualInfoLoc] Location of the pointer to the TStreamerInfo inside the object (when emulated)
    ULong_t           fLiveCount;         //! Number of outstanding pointer to this StreamerInfo.
 
+   TStreamerInfoActions::TActionSequence *fReadObjectWise;      //! List of action resulting from the compilation.
+   TStreamerInfoActions::TActionSequence *fReadMemberWise;      //! List of action resulting from the compilation for use in member wise streaming.
+   
    static  Int_t     fgCount;            //Number of TStreamerInfo instances
    static TStreamerElement *fgElement;   //Pointer to current TStreamerElement
    static Double_t   GetValueAux(Int_t type, void *ladd, int k, Int_t len);
@@ -193,6 +198,8 @@
    Int_t               GetDataMemberOffset(TDataMember *dm, TMemberStreamer *&streamer) const;
    TObjArray          *GetElements() const {return fElements;}
    ULong_t            *GetElems()   const {return fElem;}
+   TStreamerInfoActions::TActionSequence *GetReadMemberWiseActions(Bool_t forCollection) { return forCollection ? fReadMemberWise : fReadObjectWise; }
+   TStreamerInfoActions::TActionSequence *GetReadObjectWiseActions() { return fReadObjectWise; }
    Int_t               GetNdata()   const {return fNdata;}
    Int_t               GetNumber()  const {return fNumber;}
    Int_t              *GetLengths() const {return fLength;}
@@ -221,6 +228,8 @@
    void                PrintValueClones(const char *name, TClonesArray *clones, Int_t i, Int_t eoffset, Int_t lenmax=1000) const;
    void                PrintValueSTL(const char *name, TVirtualCollectionProxy *cont, Int_t i, Int_t eoffset, Int_t lenmax=1000) const;
 
+   Int_t               ReadBuffer(TBuffer &b,  char* const &ptr);
+   Int_t               ReadBuffer(TBuffer &b,  void *iter, void *end);
 #ifdef R__BROKEN_FUNCTION_TEMPLATES
    // Support for non standard compilers
    Int_t               ReadBuffer(TBuffer &b,  char** const &arrptr, Int_t first,Int_t narr=1,Int_t eoffset=0,Int_t mode=0);
Index: io/io/inc/TEmulatedMapProxy.h
===================================================================
--- io/io/inc/TEmulatedMapProxy.h	(revision 35093)
+++ io/io/inc/TEmulatedMapProxy.h	(working copy)
@@ -50,6 +50,10 @@
    // Return the current size of the container
    virtual UInt_t Size() const;
 
+   // Read portion of the streamer
+   virtual void ReadBuffer(TBuffer &buff, void *pObj);
+   virtual void ReadBuffer(TBuffer &buff, void *pObj, const TClass *onfile);
+
    // Streamer for I/O handling
    virtual void Streamer(TBuffer &refBuffer);
 
