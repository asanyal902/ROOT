<?xml version='1.0'?>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0">
	<title>Histograms</title>
	<para>This chapter covers the functionality of the histogram classes. We begin with an overview of
		the histogram classes, after which we provide instructions and examples on the histogram
		features.</para>
	<para>We have put this chapter ahead of the graphics chapter so that
		you can begin working with histograms as soon as possible. Some of the
		examples have graphics commands that may look unfamiliar to you. These
		are covered in the chapter “Input/Output”.</para>
	<sect1>
		<title>The Histogram Classes</title>
		<para>ROOT supports histograms up to three dimensions. Separate concrete classes are provided for
			one-dimensional, two-dimensional and three-dimensional classes. The histogram classes
			are split into further categories, depending on the set of possible bin values:</para>
		<itemizedlist>
			<listitem>
				<para>
					<emphasis role="bold"><code>TH1C, TH2C and TH3C</code></emphasis> contain one
					byte per bin (maximum bin content = 255)</para>
			</listitem>
			<listitem>
				<para>
					<emphasis role="bold"><code>TH1S, TH2S and TH3S</code></emphasis> contain one
					short per bin (maximum bin content = 65 535).</para>
			</listitem>
			<listitem>
				<para>
					<emphasis role="bold"><code>TH1I, TH2I and TH3I</code></emphasis> contain one
					integer per bin (maximum bin content = 2 147 483 647).</para>
			</listitem>
			<listitem>
				<para>
					<emphasis role="bold"><code>TH1F, TH2F and TH3F</code></emphasis> contain one
					float per bin (maximum precision = 7 digits).</para>
			</listitem>
			<listitem>
				<para>
					<emphasis role="bold"><code>TH1D, TH2D and TH3D</code></emphasis> contain one
					double per bin (maximum precision = 14 digits).</para>
			</listitem>
		</itemizedlist>
		<para>ROOT also supports profile histograms, which constitute an elegant replacement of
			two-dimensional histograms in many cases. The inter-relation of two measured quantities
			X and Y can always be visualized with a two-dimensional histogram or scatter-plot.
			Profile histograms, on the other hand, are used to display the mean value of Y and its
			RMS for each bin in X. If Y is an unknown but single-valued approximate function of X,
			it will have greater precision in a profile histogram than in a scatter plot.</para>
		<itemizedlist>
			<listitem>
				<para>
					<emphasis role="bold"><code>TProfile</code></emphasis> : one dimensional
					profiles </para>
			</listitem>
			<listitem>
				<para>
					<emphasis role="bold"><code>TProfile2D</code></emphasis> : two dimensional
					profiles </para>
			</listitem>
		</itemizedlist>
		<figure>
			<title>The class hierarchy of histogram classes</title>
			<para>
				<inlinemediaobject>
					<imageobject>
						<imagedata fileref="pictures/0600002E.png" width="400.00pt" />
					</imageobject>
				</inlinemediaobject>
			</para>
		</figure>
		<para>All ROOT histogram classes are derived from the base class <emphasis role="bold"
					><code>TH1</code></emphasis> (see figure above). This means that two-dimensional
			and three-dimensional histograms are seen as a type of a one-dimensional histogram, in
			the same way in which multidimensional C arrays are just an abstraction of a
			one-dimensional contiguous block of memory.</para>
	</sect1>
	<sect1>
		<title>Creating Histograms</title>
		<para>There are several ways in which you can create a histogram object in ROOT. The
			straightforward method is to use one of the several constructors provided for each
			concrete class in the histogram hierarchy. For more details on the constructor
			parameters, see the subsection <link xmlns:xlink="http://www.w3.org/1999/xlink"
				linkend="Fixed.or.Variable.Bin.Width">"Constant or Variable Bin Width"</link> below.
			Histograms may also be created by: </para>
		<itemizedlist>
			<listitem>
				<para>Calling the Clone() method of an existing histogram</para>
			</listitem>
			<listitem>
				<para>Making a projection from a 2-D or 3-D histogram</para>
			</listitem>
			<listitem>
				<para>Reading a histogram from a file (see Input/Output chapter)</para>
			</listitem>
		</itemizedlist>
		<programlisting language="c++"><emphasis role="italic">// using various constructors</emphasis>
TH1* h1 = new TH1I("h1", "h1 title", 100, 0.0, 4.0); 
TH2* h2 = new TH2F("h2", "h2 title", 40, 0.0, 2.0, 30, -1.5, 3.5);
TH3* h3 = new TH3D("h3", "h3 title", 80, 0.0, 1.0, 100, -2.0, 2.0,
					50, 0.0, 3.0);

<emphasis role="italic">// cloning a histogram</emphasis>
TH1* hc = (TH1*)h1->Clone();

<emphasis role="italic">// projecting histograms - the projections always contain double values !</emphasis>
TH1* hx = h2->ProjectionX(); // ! TH1D, not TH1F
TH1* hy = h2->ProjectionY(); // ! TH1D, not TH1F</programlisting>
<!-- TODO: check if this is still true;
		<para>When a histogram is created, a reference to it is automatically added to the list of
			in-memory objects for the current file or directory. This default behavior can be
			disabled for an individual histogram or for all histograms by setting a global switch.
			Here is the syntax to set the directory of the histogram <code>h</code> : </para>
		<programlisting language="c++"><emphasis role="italic">// to set the in-memory directory for the current histogram h</emphasis>
h-&gt;SetDirectory(0); 
<emphasis role="italic">// global switch to disable</emphasis>
TH1::AddDirectory(kFALSE);</programlisting>
		<para>When the histogram is deleted, the reference to it is removed
			from the list of objects in memory. In addition, when a file is
			closed, all histograms in memory associated with this file are
			automatically deleted. See the chapter “Input/Output”.</para>
-->
		<sect2 xml:id="Fixed.or.Variable.Bin.Width">
			<title>Constant or Variable Bin Width</title>
			<para>The histogram classes provide a variety of ways to construct a histogram, but the
				most common way is to provide the name and title of histogram and for each
				dimension: the number of bins, the minimum x (lower edge of the first bin) and the
				maximum x (upper edge of the last bin).</para>
			<programlisting>TH2* h = new TH2D(
	/* name */ "h2",  /* title */ "Hist with constant bin width", 
	/* X-dimension */ 100, 0.0, 4.0, 
	/* Y-dimension */ 200, -3.0, 1.5
); </programlisting>
			<para>When employing his constructor, you will create a histogram with constant (fixed) bin width
				on each axis. For the example above, the interval [0.0, 4.0] is divided into 100
				bins of the same width
				<inlineequation>
					<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML">
						<mml:mrow>
							<mml:msub>
								<mml:mi>w</mml:mi>
								<mml:mi>X</mml:mi>
							</mml:msub>
							<mml:mo>=</mml:mo>
							<mml:mfrac>
								<mml:mn>4.0 - 0.0</mml:mn>
								<mml:mn>100</mml:mn>
							</mml:mfrac>
							<mml:mo>=</mml:mo>
							<mml:mn>0.04</mml:mn>
						</mml:mrow>
					</mml:math>
				</inlineequation> for the X axis (dimension). Likewise, for the Y axis (dimension),
				we have bins of equal width <inlineequation>
					<mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML">
						<mml:mrow>
							<mml:msub>
								<mml:mi>w</mml:mi>
								<mml:mi>Y</mml:mi>
							</mml:msub>
							<mml:mo>=</mml:mo>
							<mml:mfrac>
								<mml:mn>1.5 - (-3.0)</mml:mn>
								<mml:mn>200</mml:mn>
							</mml:mfrac>
							<mml:mo>=</mml:mo>
							<mml:mn>0.0225</mml:mn>
						</mml:mrow>
					</mml:math>
				</inlineequation>. </para>
			<para>If you want to create histograms with variable bin widths, ROOT provides another
				constructor suited for this purpose. Instead of passing the data interval and the
				number of bins, you have to pass an array (single or double precision) of bin edges.
				When the histogram has <code>n</code> bins, then there are <code>n+1</code> distinct
				edges, so the array you pass must be of size <code>n+1</code>.</para>
			<para>
				<programlisting>const Int_t NBINS = 5;
Double_t edges[NBINS + 1] = {0.0, 0.2, 0.3, 0.6, 0.8, 1.0}; 
// Bin 1 corresponds to range [0.0, 0.2]
// Bin 2 corresponds to range [0.2, 0.3] etc...

TH1* h = new TH1D(
	/* name */ "h1", /* title */ "Hist with variable bin width",
	/* number of bins */ NBINS, 
	/* edge array */ edges
);</programlisting>
			</para>
			<para>Each histogram object contains three <emphasis role="bold"><code>TAxis</code></emphasis>
				objects: <code>fXaxis</code> , <code>fYaxis,</code> and <code>fZaxis</code>, but for
				one-dimensional histograms only the X-axis is relevant, while for two-dimensional
				histograms the X-axis and Y-axis are relevant.  See the class <emphasis role="bold">
					<code> TAxis</code>
				</emphasis> for a description of all the access methods. The bin edges are always
				stored internally in double precision.  </para>
			<para>You can examine the actual edges / limits of the histogram bins by accessing the
				axis parameters, like in the example below:</para>
			<programlisting language="c++">const Int_t XBINS = 5; const Int_t YBINS = 5;
Double_t xEdges[XBINS + 1] = {0.0, 0.2, 0.3, 0.6, 0.8, 1.0}; 
Double_t yEdges[YBINS + 1] = {-1.0, -0.4, -0.2, 0.5, 0.7, 1.0};

TH2* h = new TH2D("h2", "h2", XBINS, xEdges, YBINS, yEdges);
TAxis* xAxis = h->GetXaxis(); TAxis* yAxis = h->GetYaxis();

std::cout &lt;&lt; "Third bin on Y-dimension: " &lt;&lt; std::endl; // corresponds to [-0.2, 0.5]
std::cout &lt;&lt; "\tLower edge: " &lt;&lt; yAxis->GetBinLowEdge(3) &lt;&lt; std::endl; 
std::cout &lt;&lt; "\tCenter: " &lt;&lt; yAxis->GetBinCenter(3) &lt;&lt; std::endl;
std::cout &lt;&lt; "\tUpper edge: " &lt;&lt; yAxis->GetBinUpEdge(3) &lt;&lt; std::endl;</programlisting>
		</sect2>
	</sect1>
	<sect1>
		<title>Bin Numbering</title>
		<para> All histogram types support fixed or variable bin sizes. 2-D histograms may have fixed size
			bins along X and variable size bins along Y or vice-versa. The functions to fill,
			manipulate, draw, or access histograms are identical in both cases.</para>
		<sect2>
			<title> Convention</title>
			<para>
				For all histogram types:
				<code>nbins</code>
				,
				<code>
					xlow</code>
				,
				<code>xup</code>
			</para>
			<para>Bin# 0 contains the underflow.</para>
			<para>
				Bin# 1 contains the first bin with low-edge (
				<code>
					xlow</code>
				INCLUDED).
			</para>
			<para>
				The second to last bin (bin#
				<code>nbins</code>
				) contains the
				upper-edge (
				<code>xup</code>
				EXCLUDED).
			</para>
			<para>
				The Last bin (bin#
				<code>nbins+1)</code>
				contains the
				overflow.
			</para>
			<para>In
				case of 2-D or 3-D histograms, a &quot;global bin&quot;
				number is defined. For example, assuming a 3-D histogram
				<code>
					h</code>
				with
				<code>binx</code>
				,
				<code>biny</code>
				,
				<code>
					binz</code>
				, the function returns a global/linear bin number.
			</para>
			<programlisting language="c++">Int_t bin =
				h-&gt;GetBin(binx,biny,binz);</programlisting>
			<para>This global bin is useful to access the bin information
				independently of the dimension.</para>
		</sect2>
		<sect2>
			<title>Re-binning</title>
			<para>
				At any time, a histogram can be re-binned via the
				<emphasis role="bold">
					<code>TH1</code>
				</emphasis>
				<code>
					::Rebin()</code>
				method. It returns a new histogram with the
				re-binned contents. If bin errors were stored, they are recomputed
				during the re-binning.
			</para>
		</sect2>
	</sect1>
	<sect1>
		<title>Filling Histograms</title>
		<para>A histogram is typically filled with statements like:</para>
		<programlisting language="c++">h1-&gt;Fill(x);
			h1-&gt;Fill(x,w);
			<emphasis role="italic">
				<code>//with weight</code>
			</emphasis>h2-&gt;Fill(x,y);
			h2-&gt;Fill(x,y,w); h3-&gt;Fill(x,y,z); h3-&gt;Fill(x,y,z,w);
		</programlisting>
		<para>
			The
			<code>Fill</code>
			method computes the bin number
			corresponding to the given x, y or z argument and increments this bin
			by the given weight. The
			<code>Fill()</code>
			method returns the bin
			number for 1-D histograms or global bin number for 2-D and 3-D
			histograms. If
			<emphasis role="bold">
				<code>TH1</code>
			</emphasis>
			<code>::Sumw2()</code>
			has been called before filling, the sum of
			squares is also stored. One can increment a bin number directly by
			calling
			<emphasis role="bold">
				<code>TH1</code>
			</emphasis>
			<code>
				::AddBinContent()</code>
			, replace the existing content via
			<emphasis role="bold">
				<code>TH1</code>
			</emphasis>
			<code>
				::SetBinContent()</code>
			, and access the bin content of a given bin
			via
			<emphasis role="bold">
				<code>TH1</code>
			</emphasis>
			<code>
				::GetBinContent()</code>
			.
		</para>
		<programlisting language="c++">Double_t binContent =
			h-&gt;GetBinContent(bin);</programlisting>
		<sect2>
			<title>Automatic Re-binning Option</title>
			<para>By default, the number of bins is computed using the range of
				the axis. You can change this to re-bin automatically by setting the
				automatic re-binning option:</para>
			<programlisting language="c++">
				<code>h-&gt;SetBit(TH1::kCanRebin);</code>
			</programlisting>
			<para>
				Once this is set, the
				<code>Fill()</code>
				method will
				automatically extend the axis range to accommodate the new value
				specified in the
				<code>Fill()</code>
				argument. The used method is to
				double the bin size until the new value fits in the range, merging
				bins two by two. The
				<emphasis role="bold">
					<code>
						TTree</code>
				</emphasis>
				<code>::Draw()</code>
				method extensively uses
				this automatic binning option when drawing histograms of variables
				in
				<emphasis role="bold">
					<code>TTree</code>
				</emphasis>
				with an
				unknown range. The automatic binning option is supported for 1-D,
				2-D and 3-D histograms. During filling, some statistics parameters
				are incremented to compute the mean value and root mean square with
				the maximum precision. In case of histograms of type
				<emphasis role="bold">
					<code>TH1C</code>
				</emphasis>
				,
				<emphasis role="bold">
					<code>TH1S</code>
				</emphasis>
				,
				<emphasis role="bold">
					<code>TH2C</code>
				</emphasis>
				,
				<emphasis role="bold">
					<code>TH2S</code>
				</emphasis>
				,
				<emphasis role="bold">
					<code>TH3C</code>
				</emphasis>
				,
				<emphasis role="bold">
					<code>TH3S</code>
				</emphasis>
				a check is made
				that the bin contents do not exceed the maximum positive capacity
				(127 or 65 535). Histograms of all types may have positive or/and
				negative bin contents.
			</para>
		</sect2>
	</sect1>
	<sect1>
		<title>Random Numbers and Histograms</title>
		<para>
			<emphasis role="bold">
				<code>TH1</code>
			</emphasis>
			<code>
				::FillRandom()</code>
			can be used to randomly fill a histogram using
			the contents of an existing
			<emphasis role="bold">
				<code>
					TF1</code>
			</emphasis>
			function or another
			<emphasis role="bold">
				<code>
					TH1</code>
			</emphasis>
			histogram (for all dimensions). For example, the
			following two statements create and fill a histogram 10 000 times
			with a default Gaussian distribution of
			<code>mean</code>
			<code>
				0</code>
			and
			<code>sigma</code>
			<code>1</code>
			:
		</para>
		<programlisting language="c++">
			root[]
			<emphasis role="bold">
				<code>TH1F</code>
			</emphasis>
			<emphasis role="bold">
				<code>h1(&quot;h1&quot;,&quot;Histo from a Gaussian&quot;,100,-3,3);</code>
			</emphasis>
			root[]
			<emphasis role="bold">
				<code>h1.FillRandom</code>
			</emphasis>
			<emphasis role="bold">
				<code>(&quot;gaus&quot;,10000);</code>
			</emphasis>
		</programlisting>
		<para>
			<emphasis role="bold">
				<code>TH1</code>
			</emphasis>
			<code>
				::GetRandom()</code>
			can be used to get a random number distributed
			according the contents of a histogram. To fill a histogram following
			the distribution in an existing histogram you can use the second
			signature of
			<emphasis role="bold">
				<code>TH1</code>
			</emphasis>
			<code>
				::FillRandom()</code>
			. Next code snipped assumes that
			<code>
				h</code>
			is an existing histogram (
			<emphasis role="bold">
				<code>
					TH1</code>
			</emphasis>
			).
		</para>
		<programlisting language="c++">
			root[]
			<emphasis role="bold">
				<code>TH1F</code>
			</emphasis>
			<emphasis role="bold">
				<code>h2(&quot;h2&quot;,&quot;Histo</code>
			</emphasis>
			<emphasis role="bold">
				<code>from existing histo</code>
			</emphasis>
			<emphasis role="bold">
				<code>&quot;,100,-3,3);</code>
			</emphasis>
			root[]
			<emphasis role="bold">
				<code>h2.</code>
			</emphasis>
			<emphasis role="bold">
				<code>FillRandom(</code>
			</emphasis>
			<emphasis role="bold">
				<code>&amp;</code>
			</emphasis>
			<emphasis role="bold">
				<code>h</code>
			</emphasis>
			<emphasis role="bold">
				<code>1</code>
			</emphasis>
			<emphasis role="bold">
				<code>,1000);</code>
			</emphasis>
		</programlisting>
		<para>
			The distribution contained in the histogram
			<code>h</code>
			<code>1</code>
			(
			<emphasis role="bold">
				<code>TH1</code>
			</emphasis>
			) is
			integrated over the channel contents. It is normalized to one. The
			second parameter (1000) indicates how many random numbers are
			generated.
		</para>
		<para>Getting 1 random number implies:</para>
		<itemizedlist>
			<listitem>
				<para>
					Generating a random number between 0 and 1 (say
					<code>
						r1</code>
					)
				</para>
			</listitem>
			<listitem>
				<para>
					Find the bin in the normalized integral for
					<code>
						r1</code>
				</para>
			</listitem>
			<listitem>
				<para>Fill histogram channel</para>
			</listitem>
		</itemizedlist>
		<para>
			You can see below an example of the
			<emphasis role="bold">
				<code>
					TH1</code>
			</emphasis>
			<code>::GetRandom()</code>
			method which can be
			used to get a random number distributed according the contents of a
			histogram.
		</para>
		<programlisting language="c++">
			<code>void getrandomh() {</code>
			<code>TH1F *source = new TH1F(&quot;source&quot;,&quot;source
				hist&quot;,100,-3,3);</code>
			<code>source-&gt;FillRandom(&quot;gaus&quot;,1000);</code>
			<code>TH1F *final = new TH1F(&quot;final&quot;,&quot;final
				hist&quot;,100,-3,3);</code>
			<emphasis role="italic">
				<code>// continued…</code>
			</emphasis>
			<code>for (Int_t i=0;i&lt;10000;i++) {</code>
			<code>final-&gt;Fill(source-&gt;GetRandom());</code>
			<code>}</code>
			<code>TCanvas *c1 = new
				TCanvas(&quot;c1&quot;,&quot;c1&quot;,800,1000);</code>
			<code>c1-&gt;Divide(1,2);</code>
			<code>c1-&gt;cd(1);</code>
			<code>source-&gt;Draw();</code>
			<code>c1-&gt;cd(2);</code>
			<code>final-&gt;Draw();</code>
			<code>c1-&gt;cd();</code>
			<code>}</code>
		</programlisting>
	</sect1>
	<sect1>
		<title>Adding, Dividing, and Multiplying</title>
		<para>Many types of operations are supported on histograms or between
			histograms:</para>
		<itemizedlist>
			<listitem>
				<para>Addition of a histogram to the current histogram</para>
			</listitem>
			<listitem>
				<para>Additions of two histograms with coefficients and storage
					into the current histogram</para>
			</listitem>
			<listitem>
				<para>Multiplications and divisions are supported in the same way
					as additions.</para>
			</listitem>
			<listitem>
				<para>
					The
					<code>Add</code>
					,
					<code>Divide</code>
					and
					<code>
						Multiply</code>
					methods also exist to add, divide or multiply a
					histogram by a function.
				</para>
			</listitem>
		</itemizedlist>
		<para>
			Histograms objects (not pointers)
			<emphasis role="bold">
				<code>
					TH1F</code>
			</emphasis>
			<code>h1</code>
			can be multiplied by a constant
			using:
		</para>
		<programlisting language="c++">h1.Scale(const)</programlisting>
		<para>A new histogram can be created without changing the original
			one by doing:</para>
		<programlisting language="c++">TH1F h3 = 8*h1;</programlisting>
		<para>To multiply two histogram objects and put the result in a 3rd
			one do:</para>
		<programlisting language="c++">TH1F h3 = h1*h2;</programlisting>
		<para>
			The same operations can be done with histogram pointers
			<emphasis role="bold">
				<code>TH1F</code>
			</emphasis>
			<code>*h1</code>
			,
			<emphasis role="bold">
				<code>*h2</code>
			</emphasis>
			following way:
		</para>
		<programlisting language="c++">h1-&gt;Scale(const) TH1F h3 =
			8*(*h1); TH1F h3 = (*h1)*(*h2);</programlisting>
		<para>
			Of course, the
			<emphasis role="bold">
				<code>
					TH1</code>
			</emphasis>
			methods
			<code>Add</code>
			,
			<code>
				Multiply</code>
			and
			<code>Divide</code>
			can be used instead of these
			operators.
		</para>
		<para>
			If a histogram has associated error bars (
			<emphasis role="bold">
				<code>TH1</code>
			</emphasis>
			<code>
				::Sumw2()</code>
			has been called), the resulting error bars are also
			computed assuming independent histograms. In case of divisions,
			binomial errors are also supported.
		</para>
	</sect1>
	<sect1>
		<title>Projections</title>
		<para>One can make:</para>
		<itemizedlist>
			<listitem>
				<para>
					a 1-D projection of a 2-D histogram or profile. See
					<emphasis role="bold">
						<code>TH2</code>
					</emphasis>
					<code>
						::ProfileX</code>
					,
					<emphasis role="bold">
						<code>
							TH2</code>
					</emphasis>
					<code>::ProfileY,</code>
					<emphasis role="bold">
						<code>TProfile</code>
					</emphasis>
					<code>
						::ProjectionX</code>
					,
					<emphasis role="bold">
						<code>
							TProfile2D</code>
					</emphasis>
					<code>::ProjectionXY</code>
					,
					<emphasis role="bold">
						<code>TH2</code>
					</emphasis>
					<code>
						::ProjectionX</code>
					,
					<emphasis role="bold">
						<code>
							TH2</code>
					</emphasis>
					<code>::ProjectionY</code>
					.
				</para>
			</listitem>
			<listitem>
				<para>
					a 1-D, 2-D or profile out of a 3-D histogram see
					<emphasis role="bold">
						<code>TH3</code>
					</emphasis>
					<code>
						::ProjectionZ</code>
					,
					<emphasis role="bold">
						<code>
							TH3</code>
					</emphasis>
					<code>::Project3D</code>
					.
				</para>
			</listitem>
		</itemizedlist>
		<para>
			These projections can be fit via:
			<emphasis role="bold">
				<code>
					TH2</code>
			</emphasis>
			<code>::FitSlicesX</code>
			,
			<emphasis role="bold">
				<code>TH2</code>
			</emphasis>
			<code>
				::FitSlicesY</code>
			,
			<emphasis role="bold">
				<code>
					TH3</code>
			</emphasis>
			<code>::FitSlicesZ</code>
			.
		</para>
	</sect1>
	<sect1>
		<title>Drawing Histograms</title>
		<para>
			When you call the
			<code>Draw</code>
			method of a histogram (
			<emphasis role="bold">
				<code>TH1</code>
			</emphasis>
			<code>
				::Draw</code>
			) for the first time, it creates a
			<emphasis role="bold">
				<code>THistPainter</code>
			</emphasis>
			object and saves a pointer to
			painter as a data member of the histogram. The
			<emphasis role="bold">
				<code>THistPainter</code>
			</emphasis>
			class specializes in the drawing
			of histograms. It allows logarithmic axes (x, y, z) when the CONT
			drawing option is using. The
			<emphasis role="bold">
				<code>
					THistPainter</code>
			</emphasis>class
			is separated from the histogram
			so that one can have histograms without the graphics overhead, for
			example in a batch program. The choice to give each histogram has its
			own painter rather than a central singleton painter, allows two
			histograms to be drawn in two threads without overwriting the
			painter&apos;s values. When a displayed histogram is filled again,
			you do not have to call the
			<code>Draw</code>
			method again. The image
			is refreshed the next time the pad is updated. A pad is updated after
			one of these three actions:
		</para>
		<itemizedlist>
			<listitem>
				<para>A carriage control on the ROOT command line</para>
			</listitem>
			<listitem>
				<para>A click inside the pad</para>
			</listitem>
			<listitem>
				<para>
					A call to
					<emphasis role="bold">
						<code>TPad</code>
					</emphasis>
					<code>::Update()</code>
				</para>
			</listitem>
		</itemizedlist>
		<para>
			By default, the
			<emphasis role="bold">
				<code>
					TH1</code>
			</emphasis>
			<code>::Draw</code>
			clears the pad before
			drawing the new image of the histogram. You can use the
			<code>
				&quot;SAME&quot;</code>
			option to leave the previous display in tact
			and superimpose the new histogram. The same histogram can be drawn
			with different graphics options in different pads. When a displayed
			histogram is deleted, its image is automatically removed from the
			pad. To create a copy of the histogram when drawing it, you can use
			<emphasis role="bold">
				<code>TH1</code>
			</emphasis>
			<code>
				::DrawClone()</code>
			. This will clone the histogram and allow you to
			change and delete the original one without affecting the clone. You
			can use
			<emphasis role="bold">
				<code>TH1</code>
			</emphasis>
			<code>
				::DrawNormalized()</code>
			to draw a normalized copy of a
			histogram.
		</para>
		<programlisting language="c++">TH1
			*TH1::DrawNormalized(Option_t *option,Double_t norm) const</programlisting>
		<para>
			A clone of this histogram is normalized to norm and drawn with
			option. A pointer to the normalized histogram is returned. The
			contents of the histogram copy are scaled such that the new sum of
			weights (excluding under and overflow) is equal to
			<code>
				norm</code>
			.
		</para>
		<para>Note
			that the returned normalized histogram is not added to the
			list of histograms in the current directory in memory. It is the
			user&apos;s responsibility to delete this histogram. The
			<code>
				kCanDelete</code>
			bit is set for the returned object. If a pad
			containing this copy is cleared, the histogram will be automatically
			deleted. See “Draw Options” for the list of options.
		</para>
		<sect2>
			<title>Setting the Style</title>
			<para>
				Histograms use the current style
				<emphasis role="italic">
					<emphasis role="bold">
						<code>
							gStyle,</code>
					</emphasis>
				</emphasis>
				which is the global object of
				class
				<emphasis role="bold">
					<code>TStyle</code>
				</emphasis>
				. To
				change the current style for histograms, the
				<emphasis role="bold">
					<code>TStyle</code>
				</emphasis>
				class provides a multitude of methods
				ranging from setting the fill color to the axis tick marks. Here are
				a few examples:
			</para>
			<programlisting language="c++">
				<code>void SetHistFillColor(Color_t color = 1)</code>
				<code>void SetHistFillStyle(Style_t styl = 0)</code>
				<code>void SetHistLineColor(Color_t color = 1)</code>
				<code>void SetHistLineStyle(Style_t styl = 0)</code>
				<code>void SetHistLineWidth(Width_t width = 1)</code>
			</programlisting>
			<para>
				When you change the current style and would like to propagate
				the change to a previously created histogram you can call
				<emphasis role="bold">
					<code>TH1</code>
				</emphasis>
				<code>
					::UseCurrentStyle()</code>
				. You will need to call
				<code>
					UseCurrentStyle()</code>
				on each histogram. When reading many
				histograms from a file and you wish to update them to the current
				style, you can use
				<emphasis role="italic">
					<emphasis role="bold">
						<code>gROOT</code>
					</emphasis>
				</emphasis>
				<code>
					::ForceStyle</code>
				and all histograms read after this call will be
				updated to use the current style. See “Graphics and the Graphical
				User Interface”. When a histogram is automatically created as a
				result of a
				<emphasis role="bold">
					<code>TTree</code>
				</emphasis>
				<code>::Draw</code>
				, the style of the histogram is inherited from
				the tree attributes and the current style is ignored. The tree
				attributes are the ones set in the current
				<emphasis role="bold">
					<code>TStyle</code>
				</emphasis>
				at the time the tree was created. You
				can change the existing tree to use the current style, by calling
				<emphasis role="bold">
					<code>TTree</code>
				</emphasis>
				<code>
					::UseCurrentStyle()</code>
				.
			</para>
		</sect2>
		<sect2>
			<title>Draw Options</title>
			<para>The following draw options are supported on all histogram
				classes:</para>
			<itemizedlist>
				<listitem>
					<para>
						&quot;
						<code>AXIS</code>
						&quot;: Draw only the axis.
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>HIST</code>
						&quot;: When a histogram has errors,
						it is visualized by default with error bars. To visualize it
						without errors use
						<code>HIST</code>together
						with the required
						option (e.g. &quot;
						<code>HIST</code>
						<code>SAME
							C</code>
						&quot;).
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>SAME</code>
						&quot;: Superimpose on previous
						picture in the same pad.
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>CYL</code>
						&quot;: Use cylindrical
						coordinates.
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>POL</code>
						&quot;: Use polar coordinates.
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>SPH</code>
						&quot;: Use spherical
						coordinates.
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>PSR</code>
						&quot;: Use pseudo-rapidity/phi
						coordinates.
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>LEGO</code>
						&quot;: Draw a lego plot with hidden
						line removal.
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>LEGO1</code>
						&quot;: Draw a lego plot with
						hidden surface removal.
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>LEGO2</code>
						&quot;: Draw a lego plot using
						colors to show the cell contents.
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>SURF</code>
						&quot;: Draw a surface plot with
						hidden line removal.
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>SURF1</code>
						&quot;: Draw a surface plot with
						hidden surface removal.
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>SURF2</code>
						&quot;: Draw a surface plot using
						colors to show the cell contents.
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>SURF3</code>
						&quot;: Same as
						<code>
							SURF</code>
						with a contour view on the top.
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>SURF4</code>
						&quot;: Draw a surface plot using
						<code>Gouraud</code>
						shading.
					</para>
				</listitem>
				<listitem>
					<para>
						“
						<code>SURF5</code>
						”:Same as
						<code>SURF3</code>
						but only the
						colored contour is drawn. Used with option
						<code>CYL</code>
						,
						<code>
							SPH</code>
						or
						<code>PSR</code>
						it allows to draw colored contours on
						a sphere, a cylinder or in a pseudo rapidly space. In Cartesian or
						polar coordinates, option
						<code>SURF3</code>
						is used.
					</para>
				</listitem>
			</itemizedlist>
			<para>The following options are supported for 1-D histogram
				classes:</para>
			<itemizedlist>
				<listitem>
					<para>
						&quot;
						<code>AH</code>
						&quot;: Draw the histogram, but not
						the axis labels and tick marks
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>B</code>
						&quot;: Draw a bar chart
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>C</code>
						&quot;: Draw a smooth curve through the
						histogram bins
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>E</code>
						&quot;: Draw the error bars
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>E0</code>
						&quot;: Draw the error bars including
						bins with 0 contents
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>E1</code>
						&quot;:Draw the error bars with
						perpendicular lines at the edges
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>E2</code>
						&quot;: Draw the error bars with
						rectangles
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>E3</code>
						&quot;: Draw a fill area through the
						end points of the vertical error bars
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>E4</code>
						&quot;: Draw a smoothed filled area
						through the end points of the error bars
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>L</code>
						&quot;: Draw a line through the bin
						contents
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>P</code>
						&quot;: Draw a (poly)marker at each bin
						using the histogram&apos;s current marker style
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>P0</code>
						&quot;:Draw current marker at each bin
						including empty bins
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>PIE</code>
						&quot;:Draw a Pie Chart
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>*H</code>
						&quot;: Draw histogram with a * at
						each bin
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>LF2</code>
						&quot;:Draw histogram as with option
						&quot;
						<code>L</code>
						&quot; but with a fill area. Note that &quot;
						<code>L</code>
						” also draws a fill area if the histogram fill color
						is set but the fill area corresponds to the histogram
						contour.
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>9</code>
						”:Force histogram to be drawn in high
						resolution mode. By default, the histogram is drawn in low
						resolution in case the number of bins is greater than the number
						of pixels in the current pad
					</para>
				</listitem>
				<listitem>
					<para>
						“
						<code>][</code>
						“:Draw histogram without the vertical lines
						for the first and the last bin. Use it when superposing many
						histograms on the same picture.
					</para>
				</listitem>
			</itemizedlist>
			<para>The following options are supported for 2-D histogram
				classes:</para>
			<itemizedlist>
				<listitem>
					<para>
						&quot;
						<code>ARR</code>
						&quot;: Arrow mode. Shows gradient
						between adjacent cells
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>BOX</code>
						&quot;: Draw a box for each cell with
						surface proportional to contents
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>BOX1</code>
						&quot;: A sunken button is drawn for
						negative values, a raised one for positive values
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>COL</code>
						&quot;: Draw a box for each cell with
						a color scale varying with contents
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>COLZ</code>
						&quot;: Same as &quot;
						<code>
							COL</code>
						&quot; with a drawn color palette
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>CONT</code>
						&quot;: Draw a contour plot (same as
						<code>CONT0</code>
						)
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>CONTZ</code>
						&quot;: Same as &quot;
						<code>
							CONT</code>
						&quot; with a drawn color palette
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>CONT0</code>
						&quot;: Draw a contour plot using
						surface colors to distinguish contours
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>CONT1</code>
						&quot;: Draw a contour plot using
						line styles to distinguish contours
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>CONT2</code>
						&quot;: Draw a contour plot using
						the same line style for all contours
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>CONT3</code>
						&quot;: Draw a contour plot using
						fill area colors
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>CONT4</code>
						&quot;: Draw a contour plot using
						surface colors (
						<code>SURF2</code>
						option at theta = 0)
					</para>
				</listitem>
				<listitem>
					<para>
						<code>&quot;CONT5&quot;:</code>
						Use Delaunay triangles to
						compute the contours
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>LIST</code>
						&quot;: Generate a list of
						<emphasis role="bold">
							<code>TGraph</code>
						</emphasis>
						objects for
						each contour
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>FB</code>
						&quot;: To be used with
						<code>
							LEGO</code>
						or
						<code>SURFACE</code>
						, suppress the Front-Box
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>BB</code>
						&quot;: To be used with
						<code>
							LEGO</code>
						or
						<code>SURFACE</code>
						, suppress the Back-Box
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>A</code>
						&quot;: To be used with
						<code>
							LEGO</code>
						or
						<code>SURFACE</code>
						, suppress the axis
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>SCAT</code>
						&quot;: Draw a scatter-plot
						(default)
					</para>
				</listitem>
				<listitem>
					<para>
						“
						<code>SPEC</code>
						”Use
						<emphasis role="bold">
							<code>
								TSpectrum2Painter</code>
						</emphasis>
						tool for drawing
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>TEXT</code>
						&quot;:Draw bin contents as text
						(format set via
						<code>gStyle-&gt;SetPaintTextFormat)</code>
						.
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>TEXTnn</code>
						&quot; :Draw bin contents as text
						at angle
						<code>nn</code>
						(
						<code>0&lt;nn&lt;90</code>
						).
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>[cutg]</code>
						&quot;:Draw only the sub-range
						selected by the
						<emphasis role="bold">
							<code>
								TCutG</code>
						</emphasis>name
						&quot;
						<code>cutg</code>
						&quot;.
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>Z</code>
						&quot;:The &quot;
						<code>Z</code>
						&quot;
						option can be specified with the options:
						<code>BOX</code>
						,
						<code>
							COL</code>
						,
						<code>CONT</code>
						,
						<code>SURF</code>
						, and
						<code>
							LEGO</code>
						to display the color palette with an axis indicating
						the value of the corresponding color on the right side of the
						picture.
					</para>
				</listitem>
			</itemizedlist>
			<para>The following options are supported for 3-D histogram
				classes:</para>
			<itemizedlist>
				<listitem>
					<para>&quot; &quot;: Draw a 3D scatter plot.</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>BOX</code>
						&quot;: Draw a box for each cell with
						volume proportional to contents
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>LEGO</code>
						&quot;: Same as &quot;
						<code>
							BOX</code>
						&quot;
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>ISO</code>
						&quot;: Draw an iso surface
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>FB</code>
						&quot;: Suppress the Front-Box
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>BB</code>
						&quot;: Suppress the Back-Box
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>A</code>
						&quot;: Suppress the axis
					</para>
				</listitem>
			</itemizedlist>
			<para>
				Most options can be concatenated without spaces or commas, for
				example, if
				<code>h</code>
				is a histogram pointer:
			</para>
			<programlisting language="c++">h-&gt;Draw(&quot;E1SAME&quot;);
				h-&gt;Draw(&quot;e1same&quot;);</programlisting>
			<para>
				The options are not case sensitive. The options
				<code>
					BOX</code>
				,
				<code>COL</code>
				and
				<code>COLZ</code>
				use the color
				palette defined in the current style (see
				<emphasis role="bold">
					<code>TStyle</code>
				</emphasis>
				<code>::SetPalette</code>
				). The
				options
				<code>CONT</code>
				,
				<code>SURF</code>
				, and
				<code>
					LEGO</code>
				have by default 20 equidistant contour levels, you can
				change the number of levels with
				<emphasis role="bold">
					<code>
						TH1</code>
				</emphasis>
				<code>::SetContour</code>
				. You can also set
				the default drawing option with
				<emphasis role="bold">
					<code>
						TH1</code>
				</emphasis>
				<code>::SetOption</code>
				. To see the current
				option use
				<emphasis role="bold">
					<code>TH1</code>
				</emphasis>
				<code>
					::GetOption</code>
				. For example:
			</para>
			<programlisting language="c++">
				<code>h-&gt;SetOption(&quot;lego&quot;);</code>
				<code>h-&gt;Draw();</code>
				<emphasis role="italic">
					<code>// will use the lego option</code>
				</emphasis>
				<code>h-&gt;Draw(&quot;scat&quot;)</code>
				<emphasis role="italic">
					<code>// will use the scatter plot option</code>
				</emphasis>
			</programlisting>
			<sect3>
				<title>The SCATter Plot Option</title>
				<para>
					By default, 2D histograms are drawn as scatter plots. For
					each cell (
					<code>i,j</code>
					) a number of points proportional to
					the cell content are drawn. A maximum of 500 points per cell are
					drawn. If the maximum is above 500 contents are normalized to
					500.
				</para>
			</sect3>
			<sect3>
				<title>The ARRow Option</title>
				<para>
					The
					<code>ARR</code>
					option shows the gradient between
					adjacent cells. For each cell (
					<code>i,j</code>
					) an arrow is
					drawn. The orientation of the arrow follows the cell gradient
				</para>
			</sect3>
			<sect3>
				<title>The BOX Option</title>
				<para>
					For each cell
					<code>(i,j)</code>
					a box is drawn with surface
					proportional to contents. The size of the box is proportional to
					the absolute value of the cell contents. The cells with negative
					contents are drawn with an X on top of the boxes. With option
					<code>
						BOX1</code>
					a button is drawn for each cell with surface
					proportional to contents’ absolute value. A sunken button is drawn
					for negative values, a raised one for positive values.
				</para>
			</sect3>
			<sect3>
				<title>The ERRor Bars Options</title>
				<itemizedlist>
					<listitem>
						<para>
							<code>”E”</code>
							Default. Draw only error bars, without
							markers
						</para>
					</listitem>
					<listitem>
						<para>
							<code>”E0”</code>
							Draw also bins with 0 contents (turn off
							the symbols clipping).
						</para>
					</listitem>
					<listitem>
						<para>
							<code>”E1”</code>
							Draw small lines at the end of error
							bars
						</para>
					</listitem>
					<listitem>
						<para>
							<code>”E2”</code>
							Draw error rectangles
						</para>
					</listitem>
					<listitem>
						<para>
							<code>”E3”</code>
							Draw a fill area through the end points of
							vertical error bars
						</para>
					</listitem>
					<listitem>
						<para>
							<code>”E4”</code>
							Draw a smoothed filled area through the
							end points of error bars
						</para>
					</listitem>
				</itemizedlist>
				<figure>
					<title>The &quot;E1&quot; bars&apos; option</title>
					<para>
						<inlinemediaobject>
							<imageobject>
								<imagedata fileref="pictures/0300002F.png" width="400.00pt" />
							</imageobject>
						</inlinemediaobject>
					</para>
				</figure>
				<para>
					Note that for all options, the line and fill attributes of
					the histogram are used for the errors or errors contours. Use
					<code>
						gStyle-&gt;SetErrorX(dx)</code>
					to control the size of the error
					along x. The parameter
					<code>dx</code>
					is a percentage of bin width
					for errors along
					<code>X</code>
					. Set
					<code>dx=0</code>
					to suppress
					the error along
					<code>X</code>
					. Use
					<code>
						gStyle-&gt;SetEndErrorSize(np)</code>
					to control the size of the
					lines at the end of the error bars (when option 1 is used). By
					default
					<code>np=1</code>
					(
					<code>np</code>
					represents the number of
					pixels).
				</para>
			</sect3>
			<sect3>
				<title>The Color Option</title>
				<para>
					For each cell (
					<code>i,j</code>
					) a box is drawn with a color
					proportional to the cell content. The color table used is defined
					in the current style (
					<emphasis role="italic">
						<emphasis role="bold">
							<code>gStyle</code>
						</emphasis>
					</emphasis>
					).
					The color palette in
					<emphasis role="bold">
						<code>
							TStyle</code>
					</emphasis>
					can be modified with
					<emphasis role="bold">
						<code>TStyle</code>
					</emphasis>
					<code>::SetPalette</code>
					.
				</para>
				<figure>
					<title>Different draw options</title>
					<para>
						<inlinemediaobject>
							<imageobject>
								<imagedata fileref="pictures/02000030.jpg" width="400.0pt" />
							</imageobject>
						</inlinemediaobject>
					</para>
				</figure>
			</sect3>
			<sect3>
				<title>The TEXT Option</title>
				<para>
					For each cell
					<code>(i,j)</code>
					the cell content is printed.
					The text attributes are:
				</para>
				<itemizedlist>
					<listitem>
						<para>
							Text font = current font set by
							<emphasis role="bold">
								<code>
									TStyle</code>
							</emphasis>
						</para>
					</listitem>
					<listitem>
						<para>Text size= 0.02* pad-height * marker-size</para>
					</listitem>
					<listitem>
						<para>Text color= marker color</para>
					</listitem>
				</itemizedlist>
				<figure>
					<title>The TEXT option</title>
					<para>
						<inlinemediaobject>
							<imageobject>
								<imagedata fileref="pictures/02000031.jpg" width="400.00pt" />
							</imageobject>
						</inlinemediaobject>
					</para>
				</figure>
			</sect3>
			<sect3>
				<title>The CONTour Options</title>
				<para />
				<para />
				<para>The following contour options are supported:</para>
				<itemizedlist>
					<listitem>
						<para>
							<code>&quot;CONT&quot;:</code>
							Draw a contour plot (same as
							CONT0)
						</para>
					</listitem>
					<listitem>
						<para>
							<code>&quot;CONT0&quot;:</code>
							Draw a contour plot using
							surface colors to distinguish contours
						</para>
					</listitem>
					<listitem>
						<para>
							<code>&quot;CONT1&quot;:</code>
							Draw a contour plot using
							line styles to distinguish contours
						</para>
					</listitem>
					<listitem>
						<para>
							<code>&quot;CONT2&quot;:</code>
							Draw a contour plot using
							the same line style for all contours
						</para>
					</listitem>
					<listitem>
						<para>
							<code>&quot;CONT3&quot;:</code>
							Draw a contour plot using
							fill area colors
						</para>
					</listitem>
					<listitem>
						<para>
							<code>&quot;CONT4&quot;:</code>Draw
							a contour plot using
							surface colors (SURF2 option at theta = 0); see also options
							&quot;
							<code>AITOFF</code>
							&quot;, &quot;
							<code>
								MERCATOR</code>
							&quot;, etc. below
						</para>
					</listitem>
					<listitem>
						<para>
							<code>&quot;CONT5&quot;:</code>
							Use Delaunay triangles to
							compute the contours
						</para>
					</listitem>
				</itemizedlist>
				<figure>
					<title>Different contour options</title>
					<para>
						<inlinemediaobject>
							<imageobject>
								<imagedata fileref="pictures/02000032.jpg" width="400.00pt" />
							</imageobject>
						</inlinemediaobject>
					</para>
				</figure>
				<para />
				<para>
					The default number of contour levels is 20 equidistant
					levels. It can be changed with
					<emphasis role="bold">
						<code>
							TH1</code>
					</emphasis>
					<code>::SetContour</code>.
					When option &quot;
					<code>LIST</code>
					&quot; is specified together with option &quot;
					<code>CONT</code>
					&quot;, all points used for contour drawing, are
					saved in the
					<emphasis role="bold">
						<code>
							TGraph</code>
					</emphasis>
					object and are accessible in the following
					way:
				</para>
				<programlisting language="c++">TObjArray *contours =
					gROOT-&gt;GetListOfSpecials()-&gt;FindObject(&quot;contours&quot;);
					Int_t ncontours = contours-&gt;GetSize(); TList *list =
					(TList*)contours-&gt;At(i);</programlisting>
				<para>Where
					&quot;
					<code>i</code>
					&quot; is a contour number and
					list contains a list of
					<emphasis role="bold">
						<code>
							TGraph</code>
					</emphasis>
					objects. For one given contour, more than
					one disjoint poly-line may be generated. The
					<emphasis role="bold">
						<code>TGraph</code>
					</emphasis>
					numbers per contour are given by
					<code>list-&gt;GetSize().</code>
					Here we show how to access the
					first graph in the list.
				</para>
				<programlisting language="c++">TGraph *gr1 =
					(TGraph*)list-&gt;First();</programlisting>
				<itemizedlist>
					<listitem>
						<para>
							&quot;
							<code>AITOFF</code>
							&quot;: Draw a contour via an
							AITOFF projection
						</para>
					</listitem>
					<listitem>
						<para>
							&quot;
							<code>MERCATOR</code>
							&quot;: Draw a contour via a
							Mercator projection
						</para>
					</listitem>
					<listitem>
						<para>
							“
							<code>SINUSOIDAL</code>
							&quot;: Draw a contour via a
							Sinusoidal projection
						</para>
					</listitem>
					<listitem>
						<para>
							&quot;
							<code>PARABOLIC</code>
							&quot;: Draw a contour via a
							Parabolic projection
						</para>
					</listitem>
				</itemizedlist>
				<para>
					The tutorial macro
					<code>earth.C</code>
					uses these four
					options and produces the following picture:
				</para>
				<figure>
					<title>
						The
						<code>earth.C</code>
						macro output
					</title>
					<para>
						<inlinemediaobject>
							<imageobject>
								<imagedata fileref="pictures/03000033.png" width="400.00pt" />
							</imageobject>
						</inlinemediaobject>
					</para>
				</figure>
			</sect3>
			<sect3>
				<title>The LEGO Options</title>
				<para>In a lego plot, the cell contents are drawn as 3D boxes, with
					the height of the box proportional to the cell content.</para>
				<figure>
					<title>&quot;LEGO&quot; and &quot;SURF&quot; options</title>
					<para>
						<inlinemediaobject>
							<imageobject>
								<imagedata fileref="pictures/02000034.jpg" width="400.00pt" />
							</imageobject>
						</inlinemediaobject>
					</para>
				</figure>
				<itemizedlist>
					<listitem>
						<para>
							&quot;
							<code>LEGO</code>
							&quot;: Draw a lego plot with
							hidden line removal
						</para>
					</listitem>
					<listitem>
						<para>
							&quot;
							<code>LEGO1</code>
							&quot;: Draw a lego plot with
							hidden surface removal
						</para>
					</listitem>
					<listitem>
						<para>
							&quot;
							<code>LEGO2</code>
							&quot;: Draw a lego plot using
							colors to show the cell contents
						</para>
					</listitem>
				</itemizedlist>
				<para>
					A lego plot can be represented in several coordinate systems;
					the default system is Cartesian coordinates. Other possible
					coordinate systems are
					<code>CYL</code>
					,
					<code>POL</code>
					,
					<code>
						SPH</code>
					, and
					<code>PSR</code>
					.
				</para>
				<itemizedlist>
					<listitem>
						<para>
							&quot;
							<code>CYL</code>
							&quot;: Cylindrical coordinates:
							x-coordinate is mapped on the angle; y-coordinate - on the
							cylinder length.
						</para>
					</listitem>
					<listitem>
						<para>
							&quot;
							<code>POL</code>
							&quot;: Polar coordinates:
							x-coordinate is mapped on the angle; y-coordinate - on the
							radius.
						</para>
					</listitem>
					<listitem>
						<para>
							&quot;
							<code>SPH</code>
							&quot;: Spherical coordinates:
							x-coordinate is mapped on the latitude; y-coordinate - on the
							longitude.
						</para>
					</listitem>
					<listitem>
						<para>
							&quot;
							<code>PSR</code>
							&quot;: PseudoRapidity/Phi
							coordinates: x-coordinate is mapped on Phi.
						</para>
					</listitem>
				</itemizedlist>
				<para>
					With
					<emphasis role="bold">
						<code>TStyle</code>
					</emphasis>
					<code>::SetPalette</code>
					the color palette can be changed. We
					suggest you use palette 1 with the call:
				</para>
				<programlisting language="c++">gStyle-&gt;SetPalette(1);</programlisting>
			</sect3>
			<sect3>
				<title>The SURFace Options</title>
				<para>
					In a surface plot, cell contents are represented as a mesh.
					The height of the mesh is proportional to the cell content. A
					surface plot can be represented in several coordinate systems. The
					default is Cartesian coordinates, and the other possible systems
					are
					<code>CYL</code>
					,
					<code>POL</code>
					,
					<code>SPH</code>
					, and
					<code>
						PSR</code>
					. The following picture uses
					<code>SURF1</code>
					. With
					<emphasis role="bold">
						<code>TStyle</code>
					</emphasis>
					<code>
						::SetPalette</code>
					the color palette can be changed. We suggest you
					use palette 1 with the call:
				</para>
				<programlisting language="c++">gStyle-&gt;SetPalette(1);</programlisting>
				<figure>
					<title>Different surface options</title>
					<para>
						<inlinemediaobject>
							<imageobject>
								<imagedata fileref="pictures/02000035.jpg" width="400.00pt" />
							</imageobject>
						</inlinemediaobject>
					</para>
				</figure>
				<itemizedlist>
					<listitem>
						<para>
							&quot;
							<code>SURF</code>
							&quot;: Draw a surface plot with
							hidden line removal
						</para>
					</listitem>
					<listitem>
						<para>
							&quot;
							<code>SURF1</code>
							&quot;: Draw a surface plot with
							hidden surface removal
						</para>
					</listitem>
					<listitem>
						<para>
							&quot;
							<code>SURF2</code>
							&quot;: Draw a surface plot using
							colors to show the cell contents
						</para>
					</listitem>
					<listitem>
						<para>
							&quot;
							<code>SURF3</code>
							&quot;: Same as
							<code>
								SURF</code>
							with a contour view on the top
						</para>
					</listitem>
					<listitem>
						<para>
							&quot;
							<code>SURF4</code>
							&quot;: Draw a surface plot using
							<code>Gouraud</code>
							shading
						</para>
					</listitem>
					<listitem>
						<para>
							&quot;
							<code>SURF5</code>
							&quot;: Same as
							<code>
								SURF3</code>
							but only the colored contour is drawn. Used with
							options
							<code>CYL</code>
							,
							<code>SPH</code>
							or
							<code>PSR</code>
							it
							allows to draw colored contours on a sphere, a cylinder or in a
							pseudo rapidly space. In Cartesian or polar coordinates, option
							<code>SURF3</code>
							is used.
						</para>
					</listitem>
				</itemizedlist>
			</sect3>
			<sect3>
				<title>The BAR Options</title>
				<para>When
					the option &quot;
					<code>bar</code>
					&quot; or &quot;
					<code>
						hbar</code>
					&quot; is specified, a bar chart is drawn.
				</para>
				<para>The
					options for vertical bar chart are &quot;
					<code>
						bar</code>
					&quot;, &quot;
					<code>bar0</code>
					&quot;, &quot;
					<code>
						bar1</code>
					&quot;, &quot;
					<code>bar2</code>
					&quot;, &quot;
					<code>
						bar3</code>
					&quot;, &quot;
					<code>bar4</code>
					&quot;.
				</para>
				<figure>
					<title>Vertical bar charts</title>
					<para>
						<inlinemediaobject>
							<imageobject>
								<imagedata fileref="pictures/02000036.jpg" width="400.00pt" />
							</imageobject>
						</inlinemediaobject>
					</para>
				</figure>
				<itemizedlist>
					<listitem>
						<para>The bar is filled with the histogram fill color.</para>
					</listitem>
					<listitem>
						<para>The left side of the bar is drawn with a light fill
							color.</para>
					</listitem>
					<listitem>
						<para>The right side of the bar is drawn with a dark fill
							color.</para>
					</listitem>
					<listitem>
						<para>The percentage of the bar drawn with either the light or
							dark color is:</para>
					</listitem>
					<listitem>
						<para>
							0 per cent for option
							<code>&quot;bar&quot;</code>
							or
							<code>
								&quot;bar0&quot;</code>
						</para>
					</listitem>
					<listitem>
						<para>
							10 per cent for option
							<code>&quot;bar1&quot;</code>
						</para>
					</listitem>
					<listitem>
						<para>
							20 per cent for option
							<code>&quot;bar2&quot;</code>
						</para>
					</listitem>
					<listitem>
						<para>
							30 per cent for option
							<code>&quot;bar3&quot;</code>
						</para>
					</listitem>
					<listitem>
						<para>
							40 per cent for option
							<code>&quot;bar4&quot;</code>
						</para>
					</listitem>
				</itemizedlist>
				<para>
					Use
					<emphasis role="bold">
						<code>TH1</code>
					</emphasis>
					<code>
						::SetBarWidth()</code>
					to control the bar width (default is the bin
					width). Use
					<emphasis role="bold">
						<code>TH1</code>
					</emphasis>
					<code>
						::SetBarOffset</code>
					to control the bar offset (default is 0). See
					the example
					<code>$ROOTSYS/tutorials/hist/hbars.C</code>
				</para>
				<para>The
					options for the horizontal bar chart are &quot;
					<code>
						hbar</code>
					&quot;, &quot;
					<code>hbar0</code>
					&quot;, &quot;
					<code>
						hbar1</code>
					&quot;, &quot;
					<code>hbar2</code>
					&quot;, &quot;
					<code>
						hbar3</code>
					&quot;, and &quot;
					<code>hbar4</code>
					&quot;.
				</para>
				<itemizedlist>
					<listitem>
						<para>A horizontal bar is drawn for each bin.</para>
					</listitem>
					<listitem>
						<para>The bar is filled with the histogram fill color.</para>
					</listitem>
					<listitem>
						<para>The bottom side of the bar is drawn with a light fill
							color.</para>
					</listitem>
					<listitem>
						<para>The top side of the bar is drawn with a dark fill
							color.</para>
					</listitem>
					<listitem>
						<para>The percentage of the bar drawn with either the light or
							dark color is:</para>
					</listitem>
					<listitem>
						<para>0
							per cent for option &quot;
							<code>hbar</code>
							&quot; or
							&quot;
							<code>hbar0</code>
							&quot;
						</para>
					</listitem>
					<listitem>
						<para>10
							per cent for option &quot;
							<code>
								hbar1</code>
							&quot;
						</para>
					</listitem>
					<listitem>
						<para>20
							per cent for option &quot;
							<code>
								hbar2</code>
							&quot;
						</para>
					</listitem>
					<listitem>
						<para>30
							per cent for option &quot;
							<code>
								hbar3</code>
							&quot;
						</para>
					</listitem>
					<listitem>
						<para>40
							per cent for option &quot;
							<code>
								hbar4</code>
							&quot;
						</para>
					</listitem>
				</itemizedlist>
				<para>
					Use
					<emphasis role="bold">
						<code>TH1</code>
					</emphasis>
					<code>
						::SetBarWidth</code>
					to control the bar width (default is the bin
					width). Use
					<emphasis role="bold">
						<code>TH1</code>
					</emphasis>
					<code>
						::SetBarOffset</code>
					to control the bar offset (default is 0). See
					the example
					<code>$ROOTSYS/tutorials/hist/hbars.C</code>
				</para>
				<figure>
					<title>Horizontal bar charts</title>
					<para>
						<inlinemediaobject>
							<imageobject>
								<imagedata fileref="pictures/02000037.jpg" width="400.00pt" />
							</imageobject>
						</inlinemediaobject>
					</para>
				</figure>
			</sect3>
			<sect3>
				<title>The Z Option: Display the Color Palette on the Pad</title>
				<para>The
					&quot;
					<code>Z</code>
					&quot; option can be specified with
					the options:
					<code>COL</code>
					,
					<code>CONT</code>
					,
					<code>
						SURF</code>
					, and
					<code>LEGO</code>
					to display the color palette with
					an axis indicating the value of the corresponding color on the
					right side of the picture. If there is not enough space on the
					right side, you can increase the size of the right margin by
					calling
					<emphasis role="bold">
						<code>TPad</code>
					</emphasis>
					<code>
						::SetRightMargin()</code>
					. The attributes used to display the
					palette axis values are taken from the Z axis of the object. For
					example, you can set the labels size on the palette axis
					with:
				</para>
				<programlisting language="c++">
					<code>hist-&gt;GetZaxis()-&gt;SetLabelSize();</code>
				</programlisting>
				<sect4>
					<title>Setting the Color Palette</title>
					<para>
						You can set the color palette with
						<emphasis role="bold">
							<code>TStyle</code>
						</emphasis>
						<code>::SetPalette</code>
						,
						e.g.
					</para>
					<programlisting language="c++">gStyle-&gt;SetPalette(ncolors,colors);</programlisting>
					<para>
						For example, the option
						<code>COL</code>
						draws a 2-D
						histogram with cells represented by a box filled with a color
						index, which is a function of the cell content. If the cell
						content is N, the color index used will be the color number in
						<code>colors[N]</code>
						. If the maximum cell content is greater
						than
						<code>ncolors</code>
						, all cell contents are scaled to
						<code>
							ncolors</code>
						. If
						<code>ncolors&lt;=0</code>
						, a default palette
						of 50 colors is defined. This palette is recommended for pads,
						labels. It defines:
					</para>
					<itemizedlist>
						<listitem>
							<para>Index 0 to 9: shades of gray</para>
						</listitem>
						<listitem>
							<para>Index 10 to 19:shades of brown</para>
						</listitem>
						<listitem>
							<para>Index 20 to 29:shades of blue</para>
						</listitem>
						<listitem>
							<para>Index 30 to 39: shades of red</para>
						</listitem>
						<listitem>
							<para>Index 40 to 49:basic colors</para>
						</listitem>
					</itemizedlist>
					<para>The
						color numbers specified in this palette can be viewed by
						selecting the menu entry Colors in the View menu of the canvas
						menu bar. The color&apos;s red, green, and blue values can be
						changed via
						<emphasis role="bold">
							<code>TColor</code>
						</emphasis>
						<code>::SetRGB</code>
						. If
						<code>ncolors == 1</code>&amp;&amp;
						<code>colors == 0</code>
						, a pretty palette with a violet to red
						spectrum is created. We recommend you use this palette when
						drawing lego plots, surfaces, or contours. If
						<code>ncolors &gt;
							0</code>
						and
						<code>colors == 0</code>
						, the default palette is used
						with a maximum of
						<code>ncolors</code>
						.
					</para>
				</sect4>
				<sect4>
					<title>TPaletteAxis</title>
					<para>
						A
						<emphasis role="bold">
							<code>
								TPaletteAxis</code>
						</emphasis>object
						is used to display the color
						palette when drawing 2D histograms. The object is automatically
						created when drawing a 2D histogram when the option &quot;
						<code>
							z</code>
						&quot; is specified. It is added to the histogram list of
						functions. It can be retrieved and its attributes can be changed
						with:
					</para>
					<programlisting language="c++">TPaletteAxis
						*palette=(TPaletteAxis*)h-&gt;FindObject(&quot;palette&quot;);</programlisting>
					<para>The palette can be interactively moved and resized. The
						context menu can be used to set the axis attributes. It is
						possible to select a range on the axis, to set the min/max in
						z.</para>
				</sect4>
			</sect3>
			<sect3>
				<title>The SPEC Option</title>
				<para>The
					“SPEC” option offers a large set of options/attributes to
					visualize 2D histograms thanks to &quot;operators&quot; following
					the &quot;SPEC&quot; keyword. For example, to draw the 2-D
					histogram
					<code>h2</code>
					using all default attributes except the
					viewing angles, one can do:
				</para>
				<programlisting language="c++">h2-&gt;Draw(&quot;SPEC
					a(30,30,0)&quot;);</programlisting>
				<para>The operators&apos; names are case unsensitive (i.e. one can
					use &quot;a&quot; or &quot;A&quot;) and their parameters are
					seperated by coma &quot;,&quot;. Operators can be put in any order
					in the option and must be separated by a space &quot; &quot;. No
					space characters should be put in an operator. All the available
					operators are described below.</para>
				<para>The way how a 2D histogram will be painted is controled by 2
					parameters: the &quot;Display modes groups&quot; and the
					&quot;Display Modes&quot;. &quot;Display modes groups&quot; can
					take the following values:</para>
				<itemizedlist>
					<listitem>
						<para>0 = Simple - simple display modes using one color
							only</para>
					</listitem>
					<listitem>
						<para>1 = Light - the shading is carried out according to the
							position of the fictive light source</para>
					</listitem>
					<listitem>
						<para>2 = Height - the shading is carried out according to the
							channel contents</para>
					</listitem>
					<listitem>
						<para>3 = LightHeight - combination of two previous shading
							algorithms (one can control the weight between both
							algorithms).</para>
					</listitem>
				</itemizedlist>
				<para>&quot;Display modes&quot; can take the following
					values:</para>
				<para>1 = Points2 = Grid3 = Contours4 = Bars5 = LinesX6 =
					LinesY</para>
				<para>7 = BarsX8 = BarsY9 = Needles10 = Surface11 = Triangles</para>
				<para>These
					parameters can be set by using the &quot;
					<code>
						dm</code>
					&quot; operator in the option.
				</para>
				<programlisting language="c++">h2-&gt;Draw(&quot;SPEC
					dm(1,2)&quot;);</programlisting>
				<para>The above example draws the histogram using the &quot;Light
					Display mode group&quot; and the &quot;Grid Display mode&quot;. The
					following table summarizes all the possible combinations of both
					groups:</para>
				<informaltable frame="all">
					<tgroup cols="12">
						<colspec colname="column-1" colwidth="1127*" />

						<colspec colname="column-2" colwidth="717*" />

						<colspec colname="column-3" colwidth="557*" />

						<colspec colname="column-4" colwidth="672*" />

						<colspec colname="column-5" colwidth="587*" />

						<colspec colname="column-6" colwidth="767*" />

						<colspec colname="column-7" colwidth="767*" />

						<colspec colname="column-8" colwidth="707*" />

						<colspec colname="column-9" colwidth="707*" />

						<colspec colname="column-10" colwidth="877*" />

						<colspec colname="column-11" colwidth="837*" />

						<colspec colname="column-12" colwidth="701*" />
						<tbody>
							<row>
								<entry colsep="1" rowsep="1" />
								<entry colsep="1" rowsep="1">
									<para>Points</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>Grid</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>Cont-ours</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>Bars</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>LinesX</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>LinesY</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>BarsX</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>BarsY</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>Needles</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>Surface</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>Trian-gles</para>
								</entry>
							</row>
							<row>
								<entry colsep="1" rowsep="1">
									<para>Simple</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>x</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>x</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>x</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>x</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>x</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>x</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>x</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>x</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>x</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>-</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>x</para>
								</entry>
							</row>
							<row>
								<entry colsep="1" rowsep="1">
									<para>Light</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>x</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>x</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>-</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>-</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>x</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>x</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>-</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>-</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>-</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>x</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>x</para>
								</entry>
							</row>
							<row>
								<entry colsep="1" rowsep="1">
									<para>Height</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>x</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>x</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>x</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>x</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>x</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>x</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>x</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>x</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>-</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>x</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>x</para>
								</entry>
							</row>
							<row>
								<entry colsep="1" rowsep="1">
									<para>LightHeight</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>x</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>x</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>-</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>-</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>x</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>x</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>-</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>-</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>-</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>x</para>
								</entry>
								<entry colsep="1" rowsep="1">
									<para>x</para>
								</entry>
							</row>
						</tbody>
					</tgroup>
				</informaltable>
				<para />
				<para>The
					&quot;Pen Attributes&quot; can be changed using
					<code>
						pa(color,style,width)</code>
					. Next example sets line color to 2,
					line type to 1 and line width to 2. Note that if
					<code>
						pa()</code>
					is not specified, the histogram line attributes are
					used:
				</para>
				<programlisting language="c++">h2-&gt;Draw(&quot;SPEC
					dm(1,2) pa(2,1,2)&quot;);</programlisting>
				<para>The
					number of &quot;Nodes&quot; can be changed with
					<code>
						n(nodesx,nodesy)</code>
					. Example:
				</para>
				<programlisting language="c++">h2-&gt;Draw(&quot;SPEC
					n(40,40)&quot;);</programlisting>
				<para>Sometimes
					the displayed region is rather large. When
					displaying all channels the pictures become very dense and
					complicated. It is very difficult to understand the overall shape
					of data. &quot;
					<code>n(nx,ny)</code>
					&quot; allows to change the
					density of displayed channels. Only the channels coinciding with
					given nodes are displayed.
				</para>
				<para>The
					visualization &quot;Angles&quot; can be changed with
					&quot;
					<code>a(alpha,beta,view)</code>
					&quot;: &quot;
					<code>
						alpha</code>
					&quot; is the angle between the bottom horizontal
					screen line and the displayed space on the right side of the
					picture and &quot;
					<code>beta</code>
					&quot; on the left side,
					respectively. One can rotate the 3-d space around the vertical axis
					using the &quot;
					<code>view</code>
					&quot; parameter. Allowed values
					are 0, 90, 180 and 270 degrees.
				</para>
				<programlisting language="c++">h2-&gt;Draw(&quot;SPEC
					n(40,40) dm(0,1) a(30,30,0)&quot;);</programlisting>
				<para>The
					operator &quot;
					<code>zs(scale)</code>
					&quot; changes the
					scale of the Z-axis. The possible values are: 0 = Linear (default),
					1 = Log, 2 = Sqrt. If
					<code>gPad-&gt;SetLogz()</code>
					has been set,
					the log scale on Z-axis is set automatically, i.e. there is no need
					for using the
					<code>zs()</code>
					operator. Note that the X and Y axis
					are always linear.
				</para>
				<para>The
					operator &quot;
					<code>ci(r,g,b</code>)&quot;
					defines the
					colors increments (
					<code>r</code>
					,
					<code>g</code>
					and
					<code>
						b</code>
					are floats). For sophisticated shading (Light, Height and
					LightHeight Display Modes Groups) the color palette starts from the
					basic pen color (see
					<code>pa()</code>
					function). There is a
					predefined number of color levels (256). Color in every level is
					calculated by adding the increments of the
					<code>r</code>
					,
					<code>
						g</code>
					,
					<code>b</code>
					components to the previous level. Using
					this function one can change the color increments between two
					neighboring color levels. The function does not apply on the Simple
					Display Modes Group. The default values are: (1,1,1).
				</para>
				<para>
					The operator “
					<code>ca(color_algorithm)</code>
					&quot; allows
					to choose the Color Algorithm. To define the colors one can use one
					of the following color algorithms (RGB, CMY, CIE, YIQ, HVS models).
					When the level of a component reaches the limit value one can
					choose either smooth transition (by decreasing the limit value) or
					a sharp modulo transition (continuing with 0 value). This allows
					various visual effects. One can choose from the following set of
					the algorithms:
				</para>
				<para>0 = RGB Smooth, 1 = RGB Modulo, 2 = CMY Smooth, 3 = CMY
					Modulo, 4 = CIE Smooth</para>
				<para>5 = CIE Modulo, 6 = YIQ Smooth, 7 = YIQ Modulo, 8 = HVS
					Smooth, 9 = HVS Modulo</para>
				<para>This function does not apply on Simple display modes group.
					Default value is 0. Example choosing CMY Modulo to paint the 2D
					histogram:</para>
				<programlisting language="c++">h2-&gt;Draw(&quot;SPEC c1(3)
					dm(0,1) a(30,30,0)&quot;);</programlisting>
				<para>The
					operator &quot;
					<code>lp(x,y,z)</code>
					&quot; sets the
					light position. In Light and LightHeight display modes groups the
					color palette is calculated according to the fictive light source
					position in 3-d space. Using this function one can change the
					source&apos;s position and thus achieve various graphical effects.
					This function does not apply for Simple and Height display modes
					groups. Default is:
					<code>lp(1000,1000,100)</code>
					.
				</para>
				<para>The
					operator &quot;
					<code>s(shading,shadow)</code>
					&quot;
					allows to set the shading. The surface picture is composed of
					triangles. The edges of the neighboring triangles can be smoothed
					(shaded). The shadow can be painted as well. The function does not
					apply on Simple display modes group. The possible values for
					shading are: 0 = Not Shaded, 1 = Shaded. The possible values for
					shadow are: 0 = Shadows are not painted, 1 = Shadows are painted.
					Default values:
					<code>s(1,0)</code>
					.
				</para>
				<para>The
					operator &quot;
					<code>b(bezier)</code>
					&quot; sets the
					Bezier smoothing. For Simple display modes group and for Grid,
					LinesX and LinesY display modes one can smooth data using Bezier
					smoothing algorithm. The function does not apply on other display
					modes groups and display modes. Possible values are: 0 = No bezier
					smoothing, 1 = Bezier smoothing. Default value is:
					<code>
						b(0)</code>
					.
				</para>
				<para>The
					operator &quot;
					<code>cw(width)</code>
					&quot; sets the
					contour width. This function applies only on for the Contours
					display mode. One can change the width between horizontal slices
					and thus their density. Default value:
					<code>cw(50)</code>
					.
				</para>
				<para>The
					operator &quot;
					<code>lhw(weight)</code>
					&quot; sets the
					light height weight. For LightHeight display modes group one can
					change the weight between both shading algorithms. The function
					does not apply on other display modes groups. Default value is
					<code>lhw(0.5)</code>
					.
				</para>
				<para>The
					operator &quot;
					<code>
						cm(enable,color,width,height,style)</code>
					&quot; allows to draw a
					marker on each node. In addition to the surface drawn using any
					above given algorithm one can display channel marks. One can
					control the color as well as the width, height (in pixels) and the
					style of the marks. The parameter
					<code>enable</code>
					can be set to
					0 = Channel marks are not drawn or 1 = Channel marks drawn. The
					possible styles are:
				</para>
				<para>1 = Dot, 2 = Cross, 3 = Star, 4 = Rectangle, 5 = X, 6 =
					Diamond, 7 = Triangle.</para>
				<para>The
					operator &quot;
					<code>cg(enable,color)</code>
					&quot;
					channel grid. In addition to the surface drawn using any above
					given algorithm one can display grid using the color parameter. The
					parameter enable can be set to: 0 = Grid not drawn, 1 = Grid
					drawn.
				</para>
				<para>
					See the example in
					<code>
						$ROOTSYS/tutorials/spectrum/spectrumpainter.C</code>
					.
				</para>
				<figure>
					<title>The picture produced by spectrumpainter.C macro</title>
					<para>
						<inlinemediaobject>
							<imageobject>
								<imagedata fileref="pictures/03000038.png" width="400.00pt" />
							</imageobject>
						</inlinemediaobject>
					</para>
				</figure>
			</sect3>
			<sect3>
				<title>3-D Histograms</title>
				<para>By default a 3D scatter plot is drawn. If the &quot;BOX&quot;
					option is specified, a 3D box with a volume proportional to the
					cell content is drawn.</para>
			</sect3>
		</sect2>
		<sect2>
			<title>Drawing a Sub-range of a 2-D Histogram</title>
			<figure>
				<title>The picture produced by fit2a.C macro</title>
				<para>
					<inlinemediaobject>
						<imageobject>
							<imagedata fileref="pictures/02000039.jpg" width="400.00pt" />
						</imageobject>
					</inlinemediaobject>
				</para>
			</figure>
			<para>
				Using a
				<emphasis role="bold">
					<code>
						TCutG</code>
				</emphasis>
				object, it is possible to draw a 2D histogram
				sub-range. One must create a graphical cut (mouse or C++) and
				specify the name of the cut between ‘
				<code>[</code>
				‘ and ‘
				<code>
					]</code>
				’ in the Draw option.
			</para>
			<para>
				For example, with a
				<emphasis role="bold">
					<code>
						TCutG</code>
				</emphasis>named
				&quot;
				<code>cutg</code>
				&quot;, one can
				call:
			</para>
			<programlisting language="c++">myhist-&gt;Draw(&quot;surf1
				[cutg]&quot;);</programlisting>
			<para>Or,
				assuming two graphical cuts with name &quot;
				<code>
					cut1</code>
				&quot; and &quot;
				<code>cut2</code>
				&quot;, one can
				do:
			</para>
			<programlisting language="c++">h1.Draw(&quot;lego&quot;);
				h2.Draw(&quot;[cut1,-cut2],surf,same&quot;);</programlisting>
			<para>
				The second
				<code>Draw</code>
				will superimpose on top of the
				first lego plot a subset of
				<code>h2</code>using
				the &quot;
				<code>
					surf</code>
				&quot; option with:
			</para>
			<itemizedlist>
				<listitem>
					<para>
						all the bins inside
						<code>cut1</code>
					</para>
				</listitem>
				<listitem>
					<para>
						all the bins outside
						<code>cut2</code>
					</para>
				</listitem>
			</itemizedlist>
			<para>
				Up to 16 cuts may be specified in the cut string delimited by
				<code>&quot;[..]&quot;</code>
				. Currently only the following drawing
				options are sensitive to the cuts option:
				<code>col</code>
				,
				<code>
					box</code>
				,
				<code>scat</code>
				,
				<code>hist</code>
				,
				<code>lego</code>
				,
				<code>surf</code>
				and
				<code>cartesian</code>
				coordinates only. See a
				complete example in the tutorial
				<code>
					$ROOTSYS/tutorials/fit/fit2a.C</code>
				.
			</para>
		</sect2>
		<sect2>
			<title>Superimposing Histograms with Different Scales</title>
			<para>The following script creates two histograms; the second
				histogram is the bins integral of the first one. It shows a
				procedure to draw the two histograms in the same pad and it draws
				the scale of the second histogram using a new vertical axis on the
				right side.</para>
			<figure>
				<title>Superimposed histograms with different scales</title>
				<para>
					<inlinemediaobject>
						<imageobject>
							<imagedata fileref="pictures/0300003A.png" width="400.00pt" />
						</imageobject>
					</inlinemediaobject>
				</para>
			</figure>
			<programlisting language="c++">void
				twoscales() { TCanvas *c1 = new TCanvas(&quot;c1&quot;,
				&quot;different scales hists&quot;,600,400);
				<emphasis role="italic">//create, fill and draw h1</emphasis>gStyle-&gt;SetOptStat(kFALSE);
				TH1F *h1 = new TH1F(&quot;h1&quot;,&quot;my
				histogram&quot;,100,-3,3); for (Int_t i=0;i&lt;10000;i++)
				h1-&gt;Fill(gRandom-&gt;Gaus(0,1)); h1-&gt;Draw(); c1-&gt;Update();
				<emphasis role="italic">//create hint1 filled with the bins integral
					of h1</emphasis>TH1F
				*hint1 = new TH1F(&quot;hint1&quot;,&quot;h1 bins
				integral&quot;,100,-3,3); Float_t sum = 0; for (Int_t
				i=1;i&lt;=100;i++) { sum += h1-&gt;GetBinContent(i);
				hint1-&gt;SetBinContent(i,sum); }
				<emphasis role="italic">//scale hint1 to the pad coordinates</emphasis>Float_t
				rightmax = 1.1*hint1-&gt;GetMaximum(); Float_t scale =
				gPad-&gt;GetUymax()/rightmax; hint1-&gt;SetLineColor(kRed);
				hint1-&gt;Scale(scale); hint1-&gt;Draw(&quot;same&quot;);
				<emphasis role="italic">//draw an axis on the right side</emphasis>TGaxis
				*axis = new TGaxis(gPad-&gt;GetUxmax(),gPad-&gt;GetUymin(),
				gPad-&gt;GetUxmax(),gPad-&gt;GetUymax(),0,rightmax,510,&quot;+L&quot;);
				axis-&gt;SetLineColor(kRed);
				axis-&gt;SetLabelColor(kRed); axis-&gt;Draw(); }
			</programlisting>
		</sect2>
		<sect2>
			<title>Statistics Display</title>
			<para>
				By default, a histogram drawing includes the statistics box.
				Use
				<emphasis role="bold">
					<code>TH1</code>
				</emphasis>
				<code>
					::SetStats(kFALSE)</code>
				to eliminate the statistics box. If the
				statistics box is drawn,
				<code>
					gStyle-&gt;SetOptStat(mode)</code>
				allow you to select the type of
				displayed information
				<code>.</code>
				The parameter
				<code>
					mode</code>
				has up to nine digits that can be set OFF (0) or ON as
				follows:
				<code>mode = ksiourmen</code>
				(
				<code>default =
					000001111</code>
				)
			</para>
			<itemizedlist>
				<listitem>
					<para>
						<code>n</code>
						= 1 the name of histogram is printed
					</para>
				</listitem>
				<listitem>
					<para>
						<code>e</code>
						= 1 the number of entries
					</para>
				</listitem>
				<listitem>
					<para>
						<code>m</code>
						= 1 the mean value
					</para>
				</listitem>
				<listitem>
					<para>
						<code>m</code>
						= 2 the mean and mean error values
					</para>
				</listitem>
				<listitem>
					<para>
						<code>r</code>
						= 1 the root mean square (RMS)
					</para>
				</listitem>
				<listitem>
					<para>
						<code>r</code>
						= 2 the RMS and RMS error
					</para>
				</listitem>
				<listitem>
					<para>
						<code>u</code>
						= 1 the number of underflows
					</para>
				</listitem>
				<listitem>
					<para>
						<code>o</code>
						= 1 the number of overflows
					</para>
				</listitem>
				<listitem>
					<para>
						<code>i</code>
						= 1 the integral of bins
					</para>
				</listitem>
				<listitem>
					<para>
						<code>s</code>
						= 1 the skewness
					</para>
				</listitem>
				<listitem>
					<para>
						<code>s</code>
						= 2 the skewness and the skewness error
					</para>
				</listitem>
				<listitem>
					<para>
						<code>k</code>
						= 1 the kurtosis
					</para>
				</listitem>
				<listitem>
					<para>
						<code>k</code>
						= 2 the kurtosis and the kurtosis error
					</para>
				</listitem>
			</itemizedlist>
			<para>
				Never call
				<code>SetOptStat(0001111)</code>
				, but
				<code>
					SetOptStat(1111)</code>
				, because
				<code>0001111</code>
				will be taken
				as an octal number.
			</para>
			<para>
				The method
				<emphasis role="bold">
					<code>
						TStyle</code>
				</emphasis>
				<code>::SetOptStat(Option_t
					*option)</code>
				can also be called with a character string as a
				parameter. The parameter
				<code>option</code>
				can contain:
			</para>
			<itemizedlist>
				<listitem>
					<para>
						<code>n</code>
						for printing the name of histogram
					</para>
				</listitem>
				<listitem>
					<para>
						<code>e</code>
						the number of entries
					</para>
				</listitem>
				<listitem>
					<para>
						<code>m</code>
						the mean value
					</para>
				</listitem>
				<listitem>
					<para>
						<code>M</code>
						the mean and mean error values
					</para>
				</listitem>
				<listitem>
					<para>
						<code>r</code>
						the root mean square (RMS)
					</para>
				</listitem>
				<listitem>
					<para>
						<code>R</code>
						the RMS and RMS error
					</para>
				</listitem>
				<listitem>
					<para>
						<code>u</code>
						the number of underflows
					</para>
				</listitem>
				<listitem>
					<para>
						<code>o</code>
						the number of overflows
					</para>
				</listitem>
				<listitem>
					<para>
						<code>i</code>
						the integral of bins
					</para>
				</listitem>
				<listitem>
					<para>
						<code>s</code>
						the skewness
					</para>
				</listitem>
				<listitem>
					<para>
						<code>S</code>
						the skewness and the skewness error
					</para>
				</listitem>
				<listitem>
					<para>
						<code>k</code>
						the kurtosis
					</para>
				</listitem>
				<listitem>
					<para>
						<code>K</code>
						the kurtosis and the kurtosis error
					</para>
				</listitem>
			</itemizedlist>
			<programlisting language="c++">gStyle-&gt;SetOptStat(&quot;ne&quot;);
				<emphasis role="italic">// prints the histogram name and // number
					of entries</emphasis>gStyle-&gt;SetOptStat(&quot;n&quot;);
				<emphasis role="italic">// prints the histogram name</emphasis>gStyle-&gt;SetOptStat(&quot;nemr&quot;);
				<emphasis role="italic">// the default value</emphasis>
			</programlisting>
			<para>
				With the option
				<code>&quot;same&quot;</code>
				, the statistic
				box is not redrawn. With the option
				<code>&quot;sames&quot;</code>
				,
				it is re-drawn. If it hides the previous statistics box, you can
				change its position with the next lines (where
				<code>h</code>
				is the
				histogram pointer):
			</para>
			<programlisting language="c++">
				root[]
				<emphasis role="bold">TPaveStats *s =
					(TPaveStats*)h-&gt;GetListOfFunctions()-&gt;FindObject(&quot;stats&quot;);</emphasis>
				root[]
				<emphasis role="bold">s-&gt;SetX1NDC (newx1);</emphasis>
				<emphasis role="italic">//new x start position</emphasis>
				root[]
				<emphasis role="bold">s-&gt;SetX2NDC (newx2);</emphasis>
				<emphasis role="italic">//new x end position</emphasis>
			</programlisting>
		</sect2>
		<sect2>
			<title>Setting Line, Fill, Marker, and Text Attributes</title>
			<para>
				The histogram classes inherit from the attribute classes:
				<emphasis role="bold">
					<code>TAttLine</code>
				</emphasis>
				,
				<emphasis role="bold">
					<code>TAttFill</code>
				</emphasis>
				,
				<emphasis role="bold">
					<code>TAttMarker</code>
				</emphasis>
				and
				<emphasis role="bold">
					<code>TAttText</code>
				</emphasis>
				. See the
				description of these classes for the list of options.
			</para>
		</sect2>
		<sect2>
			<title>Setting Tick Marks on the Axis</title>
			<para>
				The
				<emphasis role="bold">
					<code>TPad</code>
				</emphasis>
				<code>
					::SetTicks()</code>
				method specifies the type of tick marks on the
				axis. Let
				<code>tx=gPad-&gt;GetTickx()</code>
				and
				<code>
					ty=gPad-&gt;GetTicky()</code>
				.
			</para>
			<itemizedlist>
				<listitem>
					<para>
						<code>tx</code>
						= 1; tick marks on top side are drawn
						(inside)
					</para>
				</listitem>
				<listitem>
					<para>
						<code>tx</code>
						= 2; tick marks and labels on top side are
						drawn
					</para>
				</listitem>
				<listitem>
					<para>
						<code>ty</code>
						= 1; tick marks on right side are drawn
						(inside)
					</para>
				</listitem>
				<listitem>
					<para>
						<code>ty</code>
						= 2; tick marks and labels on right side are
						drawn
					</para>
				</listitem>
				<listitem>
					<para>
						<code>tx=ty=0</code>
						by default only the left Y axis and X
						bottom axis are drawn
					</para>
				</listitem>
			</itemizedlist>
			<para>
				Use
				<emphasis role="bold">
					<code>TPad</code>
				</emphasis>
				<code>
					::SetTicks(tx,ty)</code>
				to set these options. See also the methods
				of
				<emphasis role="bold">
					<code>TAxis</code>
				</emphasis>
				that set
				specific axis attributes. If multiple color-filled histograms are
				drawn on the same pad, the fill area may hide the axis tick marks.
				One can force the axis redrawing over all the histograms by
				calling:
			</para>
			<programlisting language="c++">gPad-&gt;RedrawAxis();</programlisting>
		</sect2>
		<sect2>
			<title>Giving Titles to the X, Y and Z Axis</title>
			<para>
				Because the axis title is an attribute of the axis, you have
				to get the axis first and then call
				<emphasis role="bold">
					<code>
						TAxis</code>
				</emphasis>
				<code>::SetTitle</code>
				.
			</para>
			<programlisting language="c++">h-&gt;GetXaxis()-&gt;SetTitle(&quot;X
				axis title&quot;); h-&gt;GetYaxis()-&gt;SetTitle(&quot;Y axis
				title&quot;);</programlisting>
			<para>
				The histogram title and the axis titles can be any
				<emphasis role="bold">
					<code>TLatex</code>
				</emphasis>
				string. The
				titles are part of the persistent histogram. For example if you
				wanted to write E with a subscript (T) you could use this:
			</para>
			<programlisting language="c++">h-&gt;GetXaxis()-&gt;SetTitle(&quot;E_{T}&quot;);</programlisting>
			<para>For
				a complete explanation of the Latex mathematical
				expressions, see &quot;Graphics and the Graphical User
				Interface&quot;. It is also possible to specify the histogram title
				and the axis titles at creation time. These titles can be given in
				the &quot;title&quot; parameter. They must be separated by &quot;
				<emphasis role="bold">;</emphasis>
				&quot;:
			</para>
			<programlisting language="c++">TH1F* h=new
				TH1F(&quot;h&quot;,&quot;Histogram title;X Axis;Y Axis;Z
				Axis&quot;,100,0,1);</programlisting>
			<para>Any title can be omitted:</para>
			<programlisting language="c++">TH1F* h=new
				TH1F(&quot;h&quot;,&quot;Histogram title;;Y Axis&quot;,100,0,1);
				TH1F* h=new TH1F(&quot;h&quot;,&quot;;;Y Axis&quot;,100,0,1);</programlisting>
			<para>
				The method
				<code>SetTitle</code>
				has the same syntax:
			</para>
			<programlisting language="c++">h-&gt;SetTitle(&quot;Histogram
				title;An other X title Axis&quot;);</programlisting>
		</sect2>
	</sect1>
	<sect1>
		<title>Making a Copy of an Histogram</title>
		<para>
			Like for any other ROOT object derived from
			<emphasis role="bold">
				<code>TObject</code>
			</emphasis>
			, the
			<code>
				Clone</code>
			method can be used. This makes an identical copy of the
			original histogram including all associated errors and
			functions:
		</para>
		<programlisting language="c++">TH1F
			*hnew = (TH1F*)h-&gt;Clone();
			<emphasis role="italic">// renaming is recommended, // because
				otherwise you</emphasis>hnew-&gt;SetName(&quot;hnew&quot;);
			<emphasis role="italic">// will have two histograms with // the same
				name</emphasis>
		</programlisting>
	</sect1>
	<sect1>
		<title>Normalizing Histograms</title>
		<para>
			You can scale a histogram (
			<emphasis role="bold">
				<code>
					TH1</code>
			</emphasis>
			<code>*h</code>
			) such that the bins integral is
			equal to the normalization parameter norm:
		</para>
		<programlisting language="c++">Double_t scale =
			norm/h-&gt;Integral(); h-&gt;Scale(scale);</programlisting>
	</sect1>
	<sect1>
		<title>Saving/Reading Histograms to/from a File</title>
		<para>
			The following statements create a ROOT file and store a
			histogram on the file. Because
			<emphasis role="bold">
				<code>
					TH1</code>
			</emphasis>
			derives from
			<emphasis role="bold">
				<code>
					TNamed</code>
			</emphasis>
			, the key identifier on the file is the
			histogram name:
		</para>
		<programlisting language="c++">TFile
			f(&quot;histos.root&quot;,&quot;new&quot;); TH1F
			h1(&quot;hgaus&quot;,&quot;histo from a gaussian&quot;,100,-3,3);
			h1.FillRandom(&quot;gaus&quot;,10000); h1-&gt;Write();</programlisting>
		<para>To read this histogram in another ROOT session, do:</para>
		<programlisting language="c++">TFile
			f(&quot;histos.root&quot;); TH1F *h =
			(TH1F*)f.Get(&quot;hgaus&quot;);</programlisting>
		<para>One can save all histograms in memory to the file by:</para>
		<programlisting language="c++">file-&gt;Write();</programlisting>
		<para>For a more detailed explanation, see “Input/Output”.</para>
	</sect1>
	<sect1>
		<title>Miscellaneous Operations</title>
		<itemizedlist>
			<listitem>
				<para>
					<emphasis role="bold">
						<code>TH1</code>
					</emphasis>
					<code>
						::KolmogorovTest(</code>
					<emphasis role="bold">
						<code>
							TH1</code>
					</emphasis>
					<code>*</code>
					<code>h2,Option_t
						*option)</code>
					is statistical test of compatibility in shape
					between two histograms. The parameter
					<code>option</code>
					is a
					character string that specifies:
				</para>
			</listitem>
			<listitem>
				<para>
					&quot;
					<code>U</code>
					&quot; include Underflows in test (also
					for 2-dim)
				</para>
			</listitem>
			<listitem>
				<para>
					&quot;
					<code>O</code>
					&quot; include Overflows (also valid for
					2-dim)
				</para>
			</listitem>
			<listitem>
				<para>
					&quot;
					<code>N</code>
					&quot; include comparison of
					normalizations
				</para>
			</listitem>
			<listitem>
				<para>
					&quot;
					<code>D</code>
					&quot; put out a line of
					&quot;Debug&quot; printout
				</para>
			</listitem>
			<listitem>
				<para>
					&quot;
					<code>M</code>
					&quot; return the maximum Kolmogorov
					distance instead of
					<code>prob</code>
				</para>
			</listitem>
			<listitem>
				<para>
					&quot;
					<code>X</code>
					&quot; run the pseudo experiments
					post-processor with the following procedure: it makes pseudo
					experiments based on random values from the parent distribution and
					compare the KS distance of the pseudo experiment to the parent
					distribution. Bin the KS distances in a histogram, and then take
					the integral of all the KS values above the value obtained from the
					original data to Monte Carlo distribution. The number of
					pseudo-experiments NEXPT is currently fixed at 1000. The function
					returns the integral. Note that this option &quot;
					<code>
						X</code>
					&quot; is much slower.
				</para>
			</listitem>
			<listitem>
				<para>
					<emphasis role="bold">
						<code>TH1</code>
					</emphasis>
					<code>
						::Smooth</code>
					- smoothes the bin contents of a 1D histogram.
				</para>
			</listitem>
			<listitem>
				<para>
					<emphasis role="bold">
						<code>TH1</code>
					</emphasis>
					<code>
						::Integral(Option_t *opt)-</code>returns
					the integral of bin
					contents in a given bin range. If the option &quot;
					<code>
						width</code>
					&quot; is specified, the integral is the sum of the bin
					contents multiplied by the bin width in
					<code>x</code>
					.
				</para>
			</listitem>
			<listitem>
				<para>
					<emphasis role="bold">
						<code>TH1</code>
					</emphasis>
					<code>
						::GetMean(int axis)</code>
					- returns the mean value along
					axis.
				</para>
			</listitem>
			<listitem>
				<para>
					<emphasis role="bold">
						<code>TH1</code>
					</emphasis>
					<code>
						::GetRMS(int axis)</code>
					- returns the Root Mean Square along
					axis.
				</para>
			</listitem>
			<listitem>
				<para>
					<emphasis role="bold">
						<code>TH1</code>
					</emphasis>
					<code>
						::GetEntries()</code>
					- returns the number of entries.
				</para>
			</listitem>
			<listitem>
				<para>
					<emphasis role="bold">
						<code>TH1</code>
					</emphasis>
					<code>
						::GetAsymmetry(</code>
					<emphasis role="bold">
						<code>
							TH1</code>
					</emphasis>
					<code>*</code>
					<code>h2,Double_t c2,Double_t
						dc2)</code>
					- returns an histogram containing the asymmetry of this
					histogram with
					<code>h2</code>
					, where the asymmetry is defined
					as:
				</para>
			</listitem>
		</itemizedlist>
		<programlisting language="c++">
			Asymmetry = (h1 - h2)/(h1 + h2)
			<emphasis role="italic">
				<code>//where h1 = this</code>
			</emphasis>
		</programlisting>
		<itemizedlist>
			<listitem>
				<para>
					It works for
					<code>1D</code>
					,
					<code>2D</code>
					, etc.
					histograms. The parameter
					<code>c2</code>
					is an optional argument
					that gives a relative weight between the two histograms, and
					<code>
						dc</code>
					<code>2</code>
					is the error on this weight. This is
					useful, for example, when forming an asymmetry between two
					histograms from two different data sets that need to be normalized
					to each other in some way. The function calculates the errors
					assuming Poisson statistics on
					<code>h1</code>
					and
					<code>
						h2</code>
					(that is,
					<code>dh=sqrt(h)</code>
					). In the next example we
					assume that
					<code>h1</code>
					and
					<code>h2</code>
					are already
					filled:
				</para>
			</listitem>
		</itemizedlist>
		<programlisting language="c++">h3 = h1-&gt;GetAsymmetry(h2)</programlisting>
		<itemizedlist>
			<listitem>
				<para>
					Then
					<code>h3</code>
					is created and filled with the asymmetry
					between
					<code>h1</code>
					and
					<code>h2</code>
					;
					<code>h1</code>
					and
					<code>h2</code>
					are left Intact.
				</para>
			</listitem>
			<listitem>
				<para>Note that the user’s responsibility is to ménage the created
					histograms.</para>
			</listitem>
			<listitem>
				<para>
					<emphasis role="bold">
						<code>TH1</code>
					</emphasis>
					<code>
						::Reset()</code>
					- resets the bin contents and errors of a
					histogram
				</para>
			</listitem>
		</itemizedlist>
	</sect1>
	<sect1>
		<title>Alphanumeric Bin Labels</title>
		<para>By default, a histogram axis is drawn with its numeric bin
			labels. One can specify alphanumeric labels instead.</para>
		<sect2>
			<title>Option 1: SetBinLabel</title>
			<para>To set an alphanumeric bin label call:</para>
			<programlisting language="c++">
				<code>TAxis::SetBinLabel(bin,label);</code>
			</programlisting>
			<para>This can always be done before or after filling. Bin labels
				will be automatically drawn with the histogram.</para>
			<figure>
				<title>Histograms with alphanumeric bin labels</title>
				<para>
					<inlinemediaobject>
						<imageobject>
							<imagedata fileref="pictures/0600003B.png" width="400.00pt" />
						</imageobject>
					</inlinemediaobject>
				</para>
			</figure>
			<para>
				See example in
				<code>
					$ROOTSYS/tutorials/hist/hlabels1.C</code>
				,
				<code>
					hlabels2.C</code>
			</para>
		</sect2>
		<sect2>
			<title>Option 2: Fill</title>
			<para>
				You can also call a
				<code>Fill()</code>
				function with one of
				the arguments being a string:
			</para>
			<programlisting language="c++">
				<code>hist1-&gt;Fill(somename,weigth);</code>
				<code>hist2-&gt;Fill(x,somename,weight);</code>
				<code>hist2-&gt;Fill(somename,y,weight);</code>
				<code>hist2-&gt;Fill(somenamex,somenamey,weight);</code>
			</programlisting>
		</sect2>
		<sect2>
			<title>Option 3: TTree::Draw</title>
			<para>
				You can use a char* variable type to histogram strings with
				<emphasis role="bold">
					<code>TTree</code>
				</emphasis>
				<code>
					::Draw()</code>
				.
			</para>
			<programlisting language="c++">
				<emphasis role="italic">
					<code>// here &quot;Nation&quot; and &quot;Division&quot; are two
						char* branches of a Tree</code>
				</emphasis>tree.Draw(&quot;Nation::Division&quot;);
			</programlisting>
			<figure>
				<title>Using a *char variable type in TTree::Draw</title>
				<para>
					<inlinemediaobject>
						<imageobject>
							<imagedata fileref="pictures/0200003C.jpg" width="400.00pt" />
						</imageobject>
					</inlinemediaobject>
				</para>
			</figure>
			<para>
				There is an example in
				<code>
					$ROOTSYS/tutorials/tree/cernstaff.C.</code>
			</para>
			<para>
				If a variable is defined as
				<code>char*</code>
				it is drawn as a
				string by default. You change that and draw the value of
				<code>
					char[0]</code>
				as an integer by adding an arithmetic operation to the
				expression as shown below.
			</para>
			<programlisting language="c++">
				<code>tree.Draw(&quot;MyChar + 0&quot;);</code>
				<emphasis role="italic">
					<code>//this will draw the integer value of MyChar[0] // where
						&quot;MyChar&quot; is char[5]</code>
				</emphasis>
			</programlisting>
		</sect2>
		<sect2>
			<title>Sort Options</title>
			<para>
				When using the options 2 or 3 above, the labels are
				automatically added to the list (
				<emphasis role="bold">
					<code>
						THashList</code>
				</emphasis>
				) of labels for a given axis. By default,
				an axis is drawn with the order of bins corresponding to the filling
				sequence. It is possible to reorder the axis alphabetically or by
				increasing or decreasing values. The reordering can be triggered via
				the
				<emphasis role="bold">
					<code>TAxis</code>
				</emphasis>context
				menu
				by selecting the menu item &quot;
				<code>LabelsOption</code>
				&quot; or
				by calling directly.
			</para>
			<programlisting language="c++">
				<code>TH1::LabelsOption(option,axis)</code>
			</programlisting>
			<para>
				Here
				<code>axis</code>
				may be X, Y, or Z. The parameter
				<code>
					option</code>
				may be:
			</para>
			<itemizedlist>
				<listitem>
					<para>
						&quot;
						<code>a</code>
						&quot; sort by alphabetic order
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>&gt;</code>
						&quot; sort by decreasing
						values
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>&lt;</code>
						&quot; sort by increasing
						values
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>h</code>
						&quot; draw labels horizontal
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>v</code>
						&quot; draw labels vertical
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>u</code>
						&quot; draw labels up (end of label
						right adjusted)
					</para>
				</listitem>
				<listitem>
					<para>
						&quot;
						<code>d</code>
						&quot; draw labels down (start of label
						left adjusted)
					</para>
				</listitem>
			</itemizedlist>
			<para>When using the option second above, new labels are added by
				doubling the current number of bins in case one label does not exist
				yet. When the filling is terminated, it is possible to trim the
				number of bins to match the number of active labels by
				calling:</para>
			<programlisting language="c++">
				<code>TH1::LabelsDeflate(axis)</code>
			</programlisting>
			<para>
				Here
				<code>axis</code>
				may be X, Y, or Z. This operation is
				automatic when using
				<emphasis role="bold">
					<code>
						TTree</code>
				</emphasis>
				<code>::Draw</code>
				. Once bin labels have
				been created, they become persistent if the histogram is written to
				a file or when generating the C++ code via
				<code>
					SavePrimitive</code>
				.
			</para>
		</sect2>
	</sect1>
	<sect1>
		<title>Histogram Stacks</title>
		<para>
			A
			<emphasis role="bold">
				<code>THStack</code>
			</emphasis>
			is a
			collection of
			<emphasis role="bold">
				<code>TH1</code>
			</emphasis>
			(or
			derived) objects. Use
			<emphasis role="bold">
				<code>
					THStack</code>
			</emphasis>
			<code>::Add(</code>
			<emphasis role="bold">
				<code>TH1</code>
			</emphasis>
			<code>*h)</code>
			to add a histogram to the
			stack. The
			<emphasis role="bold">
				<code>THStack</code>
			</emphasis>
			does
			not own the objects in the list.
		</para>
		<figure>
			<title>Stacked histograms</title>
			<para>
				<inlinemediaobject>
					<imageobject>
						<imagedata fileref="pictures/0300003D.png" width="400.00pt" />
					</imageobject>
				</inlinemediaobject>
			</para>
		</figure>
		<para>
			By default,
			<emphasis role="bold">
				<code>
					THStack</code>
			</emphasis>
			<code>::Draw</code>
			draws the histograms
			stacked as shown in the left pad in the picture above. If the option
			<code>&quot;nostack” is</code>
			used, the histograms are superimposed
			as if they were drawn one at a time using the
			<code>
				&quot;same&quot;</code>
			draw option
			<code>.</code>
			The right pad in
			this picture illustrates the
			<emphasis role="bold">
				<code>
					THStack</code>
			</emphasis>
			drawn with the
			<code>
				&quot;nostack&quot;</code>
			option.
		</para>
		<programlisting language="c++">
			<code>hs-&gt;Draw(&quot;nostack&quot;);</code>
		</programlisting>
		<para>
			Next is a simple example, for a more complex one see $
			<code>
				ROOTSYS/tutorials/hist/hstack.C.</code>
		</para>
		<programlisting language="c++">{ THStack
			hs(&quot;hs&quot;,&quot;test stacked histograms&quot;); TH1F *h1 =
			new TH1F(&quot;h1&quot;,&quot;test hstack&quot;,100,-4,4);
			h1-&gt;FillRandom(&quot;gaus&quot;,20000); h1-&gt;SetFillColor(kRed);
			hs.Add(h1); TH1F *h2 = new TH1F(&quot;h2&quot;,&quot;test
			hstack&quot;,100,-4,4);
			h2-&gt;FillRandom(&quot;gaus&quot;,15000); h2-&gt;SetFillColor(kBlue); hs.Add(h2); TH1F *h3 = new
			TH1F(&quot;h3&quot;,&quot;test hstack&quot;,100,-4,4);
			h3-&gt;FillRandom(&quot;gaus&quot;,10000);
			h3-&gt;SetFillColor(kGreen); hs.Add(h3); TCanvas
			c1(&quot;c1&quot;,&quot;stacked hists&quot;,10,10,700,900);
			c1.Divide (1,2); c1.cd(1); hs.Draw(); c1.cd(2);
			hs-&gt;Draw(&quot;nostack&quot;); }</programlisting>
	</sect1>
	<sect1>
		<title>TH2Poly</title>
		<para>
			<code>TH2Poly</code>
			is a 2D Histogram class allowing to define
			polygonal bins of arbitary shape.
		</para>
		<para>
			Each bin in the
			<code>TH2Poly</code>
			histogram is a
			<code>
				TH2PolyBin</code>
			object.
			<code>TH2PolyBin</code>
			is a very simple
			class containing the vertices and contents of the polygonal bin as
			well as several related functions.
		</para>
		<para>
			Bins are defined using one of the
			<code>AddBin()</code>
			methods.
			The bin definition should be done before filling.
		</para>
		<para>
			The following very simple macro shows how to build and fill a
			<code>TH2Poly</code>
			:
		</para>
		<programlisting language="c++">{ TH2Poly *h2p = new
			TH2Poly(); Double_t x1[] = {0, 5, 5}; Double_t y1[] = {0, 0, 5};
			Double_t x2[] = {0, -1, -1, 0}; Double_t y2[] = {0, 0, -1, -1};
			Double_t x3[] = {4, 3, 0, 1, 2.4}; Double_t y3[] = {4, 3.7, 1, 4.7,
			3.5}; h2p-&gt;AddBin(3, x1, y1); h2p-&gt;AddBin(3, x2, y2);
			h2p-&gt;AddBin(3, x3, y3); h2p-&gt;Fill( 3, 1, 3); // fill bin 1
			h2p-&gt;Fill(-0.5, -0.5, 7); // fill bin 2 h2p-&gt;Fill(-0.7, -0.5,
			1); // fill bin 2 h2p-&gt;Fill( 1, 3, 5); // fill bin 3
			}</programlisting>
		<para>
			More examples can bin found in
			<code>
				$ROOTSYS/tutorials/hist/th2poly*.C</code>
		</para>
		<figure>
			<title>A TH2Poly histogram example</title>
			<para>
				<inlinemediaobject>
					<imageobject>
						<imagedata fileref="pictures/th2poly1.png" width="400.00pt" />
					</imageobject>
				</inlinemediaobject>
			</para>
		</figure>
	</sect1>
	<sect1>
		<title>Profile Histograms</title>
		<para>
			Profile histograms are in many cases an elegant replacement of
			two-dimensional histograms. The relationship of two quantities X and
			Y can be visualized by a two-dimensional histogram or a scatter-plot;
			its representation is not particularly satisfactory, except for
			sparse data. If Y is an unknown [but single-valued] function of X, it
			can be displayed by a profile histogram with much better precision
			than by a scatter-plot. Profile histograms display the mean value of
			Y and its RMS for each bin in X. The following shows the contents
			[capital letters] and the values shown in the graphics [small
			letters] of the elements for bin j. When you fill a profile histogram
			with
			<emphasis role="bold">
				<code>TProfile</code>
			</emphasis>
			<code>
				.Fill[x,y]</code>
			:
		</para>
		<itemizedlist>
			<listitem>
				<para>
					<code>H[j]</code>
					will contain for each bin
					<code>j</code>
					the
					sum of the y values for this bin
				</para>
			</listitem>
			<listitem>
				<para>
					<code>L[j]</code>
					contains the number of entries in the bin
					<code>j</code>
				</para>
			</listitem>
			<listitem>
				<para>
					<code>e[j]</code>
					or
					<code>s[j]</code>
					will be the resulting
					error depending on the selected option. See “Build Options“.
				</para>
			</listitem>
		</itemizedlist>
		<programlisting language="c++">E[j] = sum Y**2 L[j] = number
			of entries in bin J H[j] = sum Y h[j] = H[j] / L[j] s[j] = sqrt[E[j]
			/ L[j] - h[j]**2] e[j] = s[j] / sqrt[L[j]]</programlisting>
		<para>
			In the special case where
			<code>s[j]</code>
			is zero, when there
			is only one entry per bin,
			<code>e[j]</code>
			is computed from the
			average of the
			<code>s[j]</code>
			for all bins. This approximation is
			used to keep the bin during a fit operation. The
			<emphasis role="bold">
				<code>TProfile</code>
			</emphasis>
			constructor
			takes up to eight arguments. The first five parameters are similar to
			<emphasis role="bold">
				<code>TH1D</code>
			</emphasis>
			constructor.
		</para>
		<programlisting language="c++">
			<code>TProfile(const char *name,const char *title,Int_t nbinsx,</code>
			<code>Double_t xlow, Double_t xup, Double_t ylow, Double_t yup,</code>
			<code>Option_t *option)</code>
		</programlisting>
		<para>
			All values of
			<code>y</code>
			are accepted at filling time. To
			fill a profile histogram, you must use
			<emphasis role="bold">
				<code>
					TProfile</code>
			</emphasis>
			<code>::Fill</code>
			function. Note that
			when filling the profile histogram the method
			<emphasis role="bold">
				<code>TProfile</code>
			</emphasis>
			<code>::Fill</code>
			checks if the
			variable
			<code>y</code>
			is between
			<code>fYmin</code>
			and
			<code>
				fYmax</code>
			. If a minimum or maximum value is set for the Y scale
			before filling, then all values below
			<code>ylow</code>
			or above
			<code>
				yup</code>
			will be discarded. Setting the minimum or maximum value for
			the Y scale before filling has the same effect as calling the special
			<emphasis role="bold">
				<code>TProfile</code>
			</emphasis>
			constructor
			above where
			<code>ylow</code>
			and
			<code>yup</code>
			are specified.
		</para>
		<sect2>
			<title>Build Options</title>
			<para>
				The last parameter is the build option. If a bin has N data
				points all with the same value Y, which is the case when dealing
				with integers, the spread in Y for that bin is zero, and the
				uncertainty assigned is also zero, and the bin is ignored in making
				subsequent fits. If
				<code>SQRT(Y)</code>
				was the correct error in the
				case above, then
				<code>SQRT(Y)/SQRT(N)</code>
				would be the correct
				error here. In fact, any bin with non-zero number of entries N but
				with zero spread (
				<code>spread = s[j]</code>
				) should have an
				uncertainty
				<code>SQRT(Y)/SQRT(N)</code>
				. Now, is
				<code>
					SQRT(Y)/SQRT(N)</code>
				really the correct uncertainty? That it is
				only in the case where the Y variable is some sort of counting
				statistics, following a Poisson distribution. This is the default
				case. However, Y can be any variable from an original
				<code>
					NTUPLE</code>
				, and does not necessarily follow a Poisson
				distribution. The computation of errors is based on Y = values of
				data points; N = number of data points.
			</para>
			<itemizedlist>
				<listitem>
					<para>
						<code>&apos; &apos;</code>
						- the default is blank, the errors
						are:
					</para>
				</listitem>
				<listitem>
					<para>
						<code>spread/SQRT(N)</code>
						for a non-zero spread
					</para>
				</listitem>
				<listitem>
					<para>
						<code>SQRT(Y)/SQRT(N)</code>
						for a spread of zero and some
						data points
					</para>
				</listitem>
				<listitem>
					<para>
						<code>0</code>
						for no data points
					</para>
				</listitem>
				<listitem>
					<para>
						‘
						<code>s</code>
						’ - errors are:
					</para>
				</listitem>
				<listitem>
					<para>
						<code>spread</code>
						for a non-zero spread
					</para>
				</listitem>
				<listitem>
					<para>
						<code>SQRT(Y)</code>
						for a Spread of zero and some data
						points
					</para>
				</listitem>
				<listitem>
					<para>
						<code>0</code>
						for no data points
					</para>
				</listitem>
				<listitem>
					<para>
						‘
						<code>i</code>
						’ - errors are:
					</para>
				</listitem>
				<listitem>
					<para>
						<code>spread/SQRT(N)</code>
						for a non-zero spread
					</para>
				</listitem>
				<listitem>
					<para>
						<code>1/SQRT(12*N)</code>
						for a Spread of zero and some data
						points
					</para>
				</listitem>
				<listitem>
					<para>
						<code>0</code>
						for no data points
					</para>
				</listitem>
				<listitem>
					<para>
						‘
						<code>G</code>
						’ - errors are:
					</para>
				</listitem>
				<listitem>
					<para>
						<code>spread/SQRT(N)</code>
						for a non-zero spread
					</para>
				</listitem>
				<listitem>
					<para>
						<code>sigma/SQRT(N)</code>
						for a spread of zero and some data
						points
					</para>
				</listitem>
				<listitem>
					<para>
						<code>0</code>
						for no data points
					</para>
				</listitem>
			</itemizedlist>
			<para>The
				option &apos;
				<code>i</code>
				&apos; is used for integer Y
				values with the uncertainty of ±0.5, assuming the probability that Y
				takes any value between Y-0.5 and Y+0.5 is uniform (the same
				argument for Y uniformly distributed between Y and Y+1). An example
				is an ADC measurement. The &apos;
				<code>G</code>
				&apos; option is
				useful, if all Y variables are distributed according to some known
				Gaussian of standard deviation Sigma. For example when all Y&apos;s
				are experimental quantities measured with the same instrument with
				precision Sigma. The next figure shows the graphic output of this
				simple example of a profile histogram.
			</para>
			<programlisting language="c++">
				{
				<emphasis role="italic">// Create a canvas giving the coordinates
					and the size</emphasis>TCanvas
				*c1 = new TCanvas(&quot;c1&quot;, &quot;Profile
				example&quot;,200,10,700,500);
				<emphasis role="italic">// Create a profile with the name, title,
					the number of bins,</emphasis>
				<emphasis role="italic">// the low and high limit of the x-axis and
					the low and high</emphasis>
				<emphasis role="italic">// limit of the y-axis.</emphasis>
				<emphasis role="italic">// No option is given so the default is
					used.</emphasis>hprof
				= new TProfile(&quot;hprof&quot;, &quot;Profile of pz versus
				px&quot;,100,-4,4,0,20);
				<emphasis role="italic">// Fill the profile 25000 times with random
					numbers</emphasis>Float_t
				px, py, pz; for ( Int_t i=0; i&lt;25000; i++) {
				<emphasis role="italic">// Use the random number generator to get
					two numbers following</emphasis>
				<emphasis role="italic">// a gaussian distribution with mean=0 and
					sigma=1</emphasis>gRandom-&gt;Rannor(px,py);
				pz = px*px + py*py; hprof-&gt;Fill(px,pz,1); } hprof-&gt;Draw(); }
			</programlisting>
			<figure>
				<title>A profile histogram example</title>
				<para>
					<inlinemediaobject>
						<imageobject>
							<imagedata fileref="pictures/0300003E.png" width="400.00pt" />
						</imageobject>
					</inlinemediaobject>
				</para>
			</figure>
		</sect2>
		<sect2>
			<title>Drawing a Profile without Error Bars</title>
			<para>To
				draw a profile histogram and not show the error bars use
				the &quot;
				<code>HIST</code>
				&quot; option in the
				<emphasis role="bold">
					<code>TProfile</code>
				</emphasis>
				<code>
					::Draw</code>
				method. This will draw the outline of the
				<emphasis role="bold">
					<code>TProfile</code>
				</emphasis>
				.
			</para>
		</sect2>
		<sect2>
			<title>Create a Profile from a 2D Histogram</title>
			<para>
				You can make a profile from a histogram using the methods
				<emphasis role="bold">
					<code>TH2</code>
				</emphasis>
				<code>
					::ProfileX</code>
				and
				<emphasis role="bold">
					<code>
						TH2</code>
				</emphasis>
				<code>::ProfileY</code>
				.
			</para>
		</sect2>
		<sect2>
			<title>Create a Histogram from a Profile</title>
			<para>
				To create a regular histogram from a profile histogram, use
				the method
				<emphasis role="bold">
					<code>TProfile</code>
				</emphasis>
				<code>::ProjectionX</code>
				.This example instantiates a
				<emphasis role="bold">
					<code>TH1D</code>
				</emphasis>
				object by copying
				the
				<code>TH1D</code>
				piece of
				<emphasis role="bold">
					<code>
						TProfile</code>
				</emphasis>
				.
			</para>
			<programlisting language="c++">
				<code>TH1D *sum = myProfile.ProjectionX()</code>
			</programlisting>
			<para>
				You can do the same with a 2D profile using the method
				<emphasis role="bold">
					<code>TProfile2D</code>
				</emphasis>
				<code>
					::ProjectionXY</code>
				.
			</para>
		</sect2>
		<sect2>
			<title>Generating a Profile from a TTree</title>
			<para>
				The
				<code>&apos;prof&apos;</code>
				and
				<code>
					&apos;profs&apos;</code>
				options in the
				<emphasis role="bold">
					<code>
						TTree</code>
				</emphasis>
				<code>::Draw</code>
				method generate a profile
				histogram (
				<emphasis role="bold">
					<code>TProfile</code>
				</emphasis>
				),
				given a two dimensional expression in the tree, or a
				<emphasis role="bold">
					<code>TProfile2D</code>
				</emphasis>
				given a
				three dimensional expression. See “Trees”. Note that you can specify
				<code>&apos;prof&apos;</code>
				or
				<code>&apos;profs&apos;</code>
				:
				<code>&apos;prof&apos;</code>
				generates a
				<emphasis role="bold">
					<code>
						TProfile</code>
				</emphasis>
				with error on the mean,
				<code>
					&apos;profs&apos;</code>
				generates a
				<emphasis role="bold">
					<code>
						TProfile</code>
				</emphasis>
				with error on the spread.
			</para>
		</sect2>
		<sect2>
			<title>2D Profiles</title>
			<para>
				The class for a 2D Profile is called
				<emphasis role="bold">
					<code>TProfile2D</code>
				</emphasis>
				. It is in many cases an elegant
				replacement of a three-dimensional histogram. The relationship of
				three measured quantities X, Y and Z can be visualized by a
				three-dimensional histogram or scatter-plot; its representation is
				not particularly satisfactory, except for sparse data. If Z is an
				unknown (but single-valued) function of (X,Y), it can be displayed
				with a
				<emphasis role="bold">
					<code>TProfile2D</code>
				</emphasis>
				with
				better precision than by a scatter-plot. A
				<emphasis role="bold">
					<code>TProfile2D</code>
				</emphasis>
				displays the mean value of Z and
				its RMS for each cell in X, Y. The following shows the cumulated
				contents (capital letters) and the values displayed (small letters)
				of the elements for cell
				<code>i,j</code>
				.
			</para>
			<para>
				When you fill a profile histogram with
				<emphasis role="bold">
					<code>TProfile2D</code>
				</emphasis>
				<code>.Fill</code>
				<code>
					[x,y,z]</code>
				:
			</para>
			<itemizedlist>
				<listitem>
					<para>
						<code>E[i,j]</code>
						contains for each bin
						<code>i,j</code>
						the
						sum of the z values for this bin
					</para>
				</listitem>
				<listitem>
					<para>
						<code>L[i,j]</code>
						contains the number of entries in the bin
						j
					</para>
				</listitem>
				<listitem>
					<para>
						<code>e[j]</code>
						or
						<code>s[j]</code>
						will be the resulting
						error depending on the selected option. See “Build Options“.
					</para>
				</listitem>
			</itemizedlist>
			<programlisting language="c++">
				<code>E[i,j] = sum z</code>
				<code>L[i,j] = sum l</code>
				<code>h[i,j] = H[i,j ] / L[i,j]</code>
				<code>s[i,j] = sqrt[E[i,j] / L[i,j]- h[i,j]**2]</code>
				<code>e[i,j] = s[i,j] / sqrt[L[i,j]]</code>
			</programlisting>
			<para>
				In the special case where
				<code>s[i,j]</code>
				is zero, when
				there is only one entry per cell,
				<code>e[i,j]</code>
				is computed
				from the average of the
				<code>s[i,j]</code>
				for all cells. This
				approximation is used to keep the cell during a fit operation.
			</para>
			<programlisting language="c++">
				<code>{</code>
				<emphasis role="italic">
					<code>// Creating a Canvas and a TProfile2D</code>
				</emphasis>
				<code>TCanvas *c1 = new TCanvas(&quot;c1&quot;,&quot;Profile
					histogram example&quot;, 200,10,700,500);</code>
				<code>hprof2d = new TProfile2D(&quot;hprof2d&quot;, &quot;Profile of
					pz versus px and py&quot;,40,-4,4,40,-4,4,0,20);</code>
				<emphasis role="italic">
					<code>// Filling the TProfile2D with 25000 points</code>
				</emphasis>
				<code>Float_t px, py, pz;</code>
				<code>for (Int_t i=0; i&lt;25000; i++) {</code>
				<code>gRandom-&gt;Rannor(px,py);</code>
				<code>pz = px*px + py*py;</code>
				<code>hprof2d-&gt;Fill(px,py,pz,1);</code>
				<code>}</code>
				<code>hprof2d-&gt;Draw();</code>
				<code>}</code>
			</programlisting>
			<figure>
				<title>A TProfile2D histogram example</title>
				<para>
					<inlinemediaobject>
						<imageobject>
							<imagedata depth="209.15pt" fileref="pictures/0800003F.png"
								width="279.95pt" />
						</imageobject>
					</inlinemediaobject>
				</para>
			</figure>
		</sect2>
	</sect1>
	<sect1>
		<title>Iso Surfaces</title>
		<para>Paint one Gouraud shaded 3d iso surface though a 3d histogram
			at the value computed as follow:</para>
		<para>
			<code>SumOfWeights/(NbinsX*NbinsY*NbinsZ)</code>
			.
		</para>
		<figure>
			<title>Iso surfaces</title>
			<para>
				<inlinemediaobject>
					<imageobject>
						<imagedata fileref="pictures/03000040.png" width="400.00pt" />
					</imageobject>
				</inlinemediaobject>
			</para>
		</figure>
		<para />
		<programlisting language="c++">void hist3d() { TH3D *h3=new
			TH3D(« h3 », »h3 »,20,-2,2,20,-2,2,20,0,4); Double_t x,y,z; for
			(Int_t i=0; i&lt;10000; i++) { gRandom-&gt;Rannor(x,y); z=x*x+y*y;
			h3-&gt;Fill(x,y,z); }
			h3-&gt;Draw(“iso”); }</programlisting>
	</sect1>
	<sect1>
		<title>3D Implicit Functions</title>
		<programlisting language="c++">
			<code>TF3 *fun3 = new TF3(“fun3”,
				“sin(x*x+y*y+z*z-36”,-2,2,-2,2,-2,2);</code>
			<code>Fun3-&gt;Draw();</code>
		</programlisting>
		<figure>
			<title>3D implicit function</title>
			<para>
				<inlinemediaobject>
					<imageobject>
						<imagedata fileref="pictures/03000041.png" width="400.00pt" />
					</imageobject>
				</inlinemediaobject>
			</para>
		</figure>
	</sect1>
	<sect1>
		<title>TPie</title>
		<para>
			The
			<emphasis role="bold">
				<code>TPie</code>
			</emphasis>
			class
			allows to create a Pie Chart representation of a one dimensional data
			set. The data can come from an array of
			<code>Double_t</code>
			(or
			<code>Float_t</code>
			) or from a 1D-histogram. The possible options to
			draw a
			<emphasis role="bold">
				<code>TPie</code>
			</emphasis>
			are:
		</para>
		<itemizedlist>
			<listitem>
				<para>
					&quot;
					<code>R</code>
					&quot;Paint the labels along the central
					&quot;
					<code>R</code>
					&quot;adius of slices.
				</para>
			</listitem>
			<listitem>
				<para>
					&quot;
					<code>T</code>
					&quot;Paint the labels in a direction
					&quot;
					<code>T</code>
					&quot;angent to circle that describes the
					TPie.
				</para>
			</listitem>
			<listitem>
				<para>
					&quot;
					<code>3D</code>
					&quot;Draw the pie-chart with a pseudo
					3D effect.
				</para>
			</listitem>
			<listitem>
				<para>
					&quot;
					<code>NOL</code>
					&quot;No OutLine: do not draw the
					slices&apos; outlines; any property over the slices&apos; line is
					ignored.
				</para>
			</listitem>
		</itemizedlist>
		<para>
			The method
			<code>SetLabelFormat()</code>
			is used to customize
			the label format. The format string must contain one of these
			modifiers:
		</para>
		<itemizedlist>
			<listitem>
				<para>
					-
					<code>%txt</code>
					: to print the text label associated with
					the slice
				</para>
			</listitem>
			<listitem>
				<para>
					-
					<code>%val</code>
					: to print the numeric value of the
					slice
				</para>
			</listitem>
			<listitem>
				<para>
					-
					<code>%frac</code>
					: to print the relative fraction of this
					slice
				</para>
			</listitem>
			<listitem>
				<para>
					-
					<code>%perc</code>
					: to print the % of this slice
				</para>
			</listitem>
		</itemizedlist>
		<programlisting language="c++">mypie-&gt;SetLabelFormat(&quot;%txt
			(%frac)&quot;);</programlisting>
		<para>
			See the macro
			<code>
				$ROOTSYS/tutorials/graphics/piechart.C</code>
			.
		</para>
		<figure>
			<title>The picture generated by tutorial macro piechart.C</title>
			<para>
				<inlinemediaobject>
					<imageobject>
						<imagedata fileref="pictures/03000042.png" width="400.00pt" />
					</imageobject>
				</inlinemediaobject>
			</para>
		</figure>
	</sect1>
	<sect1>
		<title>The User Interface for Histograms</title>
		<para>
			The classes
			<emphasis role="bold">
				<code>T</code>
			</emphasis>
			<emphasis role="bold">
				<code>H1</code>
			</emphasis>
			<emphasis role="bold">
				<code>Editor</code>
			</emphasis>
			and
			<emphasis role="bold">
				<code>T</code>
			</emphasis>
			<emphasis role="bold">
				<code>H2</code>
			</emphasis>
			<emphasis role="bold">
				<code>
					Editor</code>
			</emphasis>
			provides the user interface for setting
			histogram’s attributes and rebinning interactively.
		</para>
		<sect2>
			<title>TH1Editor</title>
			<para>
				<inlinemediaobject>
					<imageobject>
						<imagedata depth="157.65pt" fileref="pictures/03000043.png"
							width="216.6pt" />
					</imageobject>
				</inlinemediaobject>
				<inlinemediaobject>
					<imageobject>
						<imagedata depth="158.9pt" fileref="pictures/03000044.png"
							width="216.6pt" />
					</imageobject>
				</inlinemediaobject>
			</para>
			<para>Style Tab:</para>
			<para>Titlesets the title of the histogram.</para>
			<para>Plotdraw a 2D or 3D plot; according to the dimension,
				different drawing possibilities can be set.</para>
			<para>Erroradd different error bars to the histogram (no errors,
				simple, etc.).</para>
			<para>Addfurther things which can be added to the histogram (None,
				simple/smooth line, fill area, etc.)</para>
			<para>
				<emphasis role="italic">
					<code>2-D
						Plot</code>
				</emphasis>
				:
			</para>
			<para>Simple Drawingdraw a simple histogram without errors (=
				&quot;HIST&quot; draw option). In combination with some other draw
				options an outer line is drawn on top of the histogram</para>
			<para>Show markersdraw a marker on to of each bin (=&quot;P&quot;
				draw option).</para>
			<para>Draw bar chartdraw a bar chart (=&quot;B&quot; draw
				option).</para>
			<para>Bar optiondraw a bar chart (=&quot;BAR&quot; draw option); if
				selected, it will show an additional interface elements for bars:
				width, offset, percentage and the possibility to draw horizontal
				bars.</para>
			<para />
			<para>
				<emphasis role="italic">
					<code>3</code>
				</emphasis>
				<emphasis role="italic">
					<code>-D Plot:</code>
				</emphasis>
			</para>
			<para>Addset histogram type Lego-Plot or Surface draw (Lego,
				Lego1.2, Surf, Surf1…5).</para>
			<para>Coordsset the coordinate system (Cartesian, Spheric,
				etc.).</para>
			<para>Errorsame as for 2D plot.</para>
			<para>Barset the bar attributes: width and offset.</para>
			<para>Horizontal Bar draw a horizontal bar chart.</para>
			<para>The Binning tab has two different layouts. One is for a
				histogram, which is not drawn from an ntuple. The other one is
				available for a histogram, which is drawn from an ntuple. In this
				case, the rebin algorithm can create a rebinned histogram from the
				original data i.e. the ntuple.</para>
			<para>
				<inlinemediaobject>
					<imageobject>
						<imagedata depth="193.05pt" fileref="pictures/03000045.png"
							width="280.55pt" />
					</imageobject>
				</inlinemediaobject>
				<inlinemediaobject>
					<imageobject>
						<imagedata depth="192.4pt" fileref="pictures/03000046.png"
							width="63.3pt" />
					</imageobject>
				</inlinemediaobject>
			</para>
			<para>To see the differences do:</para>
			<programlisting language="c++">TFile
				f(&quot;hsimple.root&quot;); hpx-&gt;Draw(&quot;BAR1&quot;);
				<emphasis role="italic">
					<code>// non ntuple histogram</code>
				</emphasis>ntuple-&gt;Draw(&quot;px&quot;);
				<emphasis role="italic">
					<code>// ntuple histogra</code>
				</emphasis>
				m
			</programlisting>
			<para>
				<emphasis role="italic">
					<code>Non ntuple
						histogram:</code>
				</emphasis>
			</para>
			<para>Rebin with a slider and the number of bins (shown in the field
				below the slider). The number of bins can be changed to any number,
				which divides the number of bins of the original histogram. A click
				on the Apply button will delete the origin histogram and will
				replace it by the rebinned one on the screen. A click on the Ignore
				button will restore the origin histogram.</para>
			<para>
				<emphasis role="italic">
					<code>Histogram drawn from an
						ntuple:</code>
				</emphasis>
			</para>
			<para>Rebin - With the slider, the number of bins can be enlarged by
				a factor of 2,3,4,5 (moving to the right) or reduced by a factor of
				1/2, 1/3, 1/4, 1/5.</para>
			<para>BinOffset with a BinOffset slider - the origin of the
				histogram can be changed within one binwidth. Using this slider the
				effect of binning the data into bins can be made visible
				(statistical fluctuations).</para>
			<para>Axis Range - with a double slider it is possible to zoom into
				the specified axis range. It is also possible to set the upper and
				lower limit in fields below the slider.</para>
			<para>Delayed drawing - all the Binning sliders can set to delay
				draw mode. Then the changes on the histogram are only updated, when
				the Slider is released. This should be activated if the redrawing of
				the histogram is time consuming.</para>
		</sect2>
		<sect2>
			<title>TH2Editor</title>
			<para>
				<inlinemediaobject>
					<imageobject>
						<imagedata depth="156.4pt" fileref="pictures/03000047.png"
							width="221.6pt" />
					</imageobject>
				</inlinemediaobject>
				<inlinemediaobject>
					<imageobject>
						<imagedata depth="155.8pt" fileref="pictures/03000048.png"
							width="219.7pt" />
					</imageobject>
				</inlinemediaobject>
			</para>
			<para>Style Tab:</para>
			<para>Titleset the title of the histogram</para>
			<para>Histogramchange the draw options of the histogram.</para>
			<para>Plotdraw a 2D or 3D plot of the histogram; according to the
				dimension, the drawing possibilities are different.</para>
			<para />
			<para>
				<emphasis role="italic">
					<code>2-D
						Plot</code>
				</emphasis>
				:
			</para>
			<para>Contour draw a contour plot (None, Cont0...5)</para>
			<para>Cont # set the number of Contours;</para>
			<para>Arrow set the arrow mode and shows the gradient between
				adjacent cells;</para>
			<para>Col a box is drawn for each cell with a color scale varying
				with contents;</para>
			<para>Text draw bin contents as text;</para>
			<para>Boxa box is drawn for each cell with surface proportional to
				contents;</para>
			<para>Scat draw a scatter-plot (default);</para>
			<para>Palette the color palette is drawn.</para>
			<para>
				<emphasis role="italic">
					<code>3</code>
				</emphasis>
				<emphasis role="italic">
					<code>-D Plot:</code>
				</emphasis>
			</para>
			<para>Type set histogram type to Lego or surface plot; draw (Lego,
				Lego1.2, Surf, Surf1…5)</para>
			<para>Coords set the coordinate system (Cartesian, Spheric,
				etc.);</para>
			<para>Cont # set the number of Contours (for e.g. Lego2 draw
				option);</para>
			<para>Errors draw errors in a Cartesian lego plot;</para>
			<para>Palette draw the color palette;</para>
			<para>Front draw the front box of a Cartesian lego plot;</para>
			<para>Back draw the back box of a Cartesian lego plot;</para>
			<para>Bar change the bar attributes: the width and offset.</para>
			<para />
			<para>Rebinning Tab:</para>
			<para>The Rebinning tab has two different layouts. One is for a
				histogram that is not drawn from an ntuple; the other one is
				available for a histogram, which is drawn from an ntuple. In this
				case, the rebin algorithm can create a rebinned histogram from the
				original data i.e. the ntuple. To see the differences do for
				example:</para>
			<programlisting language="c++">TFile
				f(&quot;hsimple.root&quot;); hpxpy-&gt;Draw(&quot;Lego2&quot;); //
				non ntuple histogram
				ntuple-&gt;Draw(&quot;px:py&quot;,&quot;&quot;,&quot;Lego2&quot;);
				// ntuple histogram</programlisting>
			<para>Non-ntuple histogram:</para>
			<para>Rebin with sliders (one for the x, one for the y-axis) and the
				number of bins (shown in the field below them can be changed to any
				number, which divides the number of bins of the original histogram.
				Selecting the Apply button will delete the origin histogram and will
				replace it by the rebinned one on the screen. Selecting the Ignore
				the origin histogram will be restored.</para>
			<para />
			<para>
				<inlinemediaobject>
					<imageobject>
						<imagedata depth="207.95pt" fileref="pictures/03000049.png"
							width="351.95pt" />
					</imageobject>
				</inlinemediaobject>
				<inlinemediaobject>
					<imageobject>
						<imagedata depth="194.9pt" fileref="pictures/0300004A.png"
							width="69.5pt" />
					</imageobject>
				</inlinemediaobject>
			</para>
			<para />
			<para />
			<para>Histogram drawn from an ntuple:</para>
			<para>Rebin with the sliders the number of bins can be enlarged by a
				factor of 2,3,4,5 (moving to the right) or reduced by a factor of
				1/2, 1/3, 1/4, 1/5. BinOffset with the BinOffset slider the origin
				of the histogram can be changed within one binwidth. Using this
				slider the effect of binning the data into bins can be made visible
				(=&gt; statistical fluctuations).</para>
			<para>Axis Range - with a double slider that gives the possibility
				for zooming. It is also possible to set the upper and lower limit in
				fields below the slider.</para>
			<para>Delayed drawing - all the binning sliders can be set to delay
				draw mode. Then the changes on the histogram are only updated, when
				the Slider is released. This should be activated if the redrawing of
				the histogram is too time consuming.</para>
			<para />
		</sect2>
	</sect1>
</chapter>
