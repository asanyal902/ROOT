Index: tools/clang/include/clang/CodeGen/CodeGenTypes.h
===================================================================
--- tools/clang/include/clang/CodeGen/CodeGenTypes.h	(revision 0)
+++ tools/clang/include/clang/CodeGen/CodeGenTypes.h	(revision 47286)
@@ -0,0 +1,260 @@
+//===--- CodeGenTypes.h - Type translation for LLVM CodeGen -----*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This is the code that handles AST -> LLVM type lowering.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef CLANG_CODEGEN_CODEGENTYPES_H
+#define CLANG_CODEGEN_CODEGENTYPES_H
+
+#include "CGCall.h"
+#include "clang/AST/GlobalDecl.h"
+#include "llvm/Module.h"
+#include "llvm/ADT/DenseMap.h"
+#include <vector>
+
+namespace llvm {
+  class FunctionType;
+  class Module;
+  class TargetData;
+  class Type;
+  class LLVMContext;
+  class StructType;
+}
+
+namespace clang {
+  class ABIInfo;
+  class ASTContext;
+  template <typename> class CanQual;
+  class CXXConstructorDecl;
+  class CXXDestructorDecl;
+  class CXXMethodDecl;
+  class CodeGenOptions;
+  class FieldDecl;
+  class FunctionProtoType;
+  class ObjCInterfaceDecl;
+  class ObjCIvarDecl;
+  class PointerType;
+  class QualType;
+  class RecordDecl;
+  class TagDecl;
+  class TargetInfo;
+  class Type;
+  typedef CanQual<Type> CanQualType;
+
+namespace CodeGen {
+  class CGCXXABI;
+  class CGRecordLayout;
+  class CodeGenModule;
+  class RequiredArgs;
+
+/// CodeGenTypes - This class organizes the cross-module state that is used
+/// while lowering AST types to LLVM types.
+class CodeGenTypes {
+  // Some of this stuff should probably be left on the CGM.
+  ASTContext &Context;
+  const TargetInfo &Target;
+  llvm::Module &TheModule;
+  const llvm::TargetData &TheTargetData;
+  const ABIInfo &TheABIInfo;
+  CGCXXABI &TheCXXABI;
+  const CodeGenOptions &CodeGenOpts;
+  CodeGenModule &CGM;
+
+  /// The opaque type map for Objective-C interfaces. All direct
+  /// manipulation is done by the runtime interfaces, which are
+  /// responsible for coercing to the appropriate type; these opaque
+  /// types are never refined.
+  llvm::DenseMap<const ObjCInterfaceType*, llvm::Type *> InterfaceTypes;
+
+  /// CGRecordLayouts - This maps llvm struct type with corresponding
+  /// record layout info.
+  llvm::DenseMap<const Type*, CGRecordLayout *> CGRecordLayouts;
+
+  /// RecordDeclTypes - This contains the LLVM IR type for any converted
+  /// RecordDecl.
+  llvm::DenseMap<const Type*, llvm::StructType *> RecordDeclTypes;
+  
+  /// FunctionInfos - Hold memoized CGFunctionInfo results.
+  llvm::FoldingSet<CGFunctionInfo> FunctionInfos;
+
+  /// RecordsBeingLaidOut - This set keeps track of records that we're currently
+  /// converting to an IR type.  For example, when converting:
+  /// struct A { struct B { int x; } } when processing 'x', the 'A' and 'B'
+  /// types will be in this set.
+  llvm::SmallPtrSet<const Type*, 4> RecordsBeingLaidOut;
+  
+  llvm::SmallPtrSet<const CGFunctionInfo*, 4> FunctionsBeingProcessed;
+  
+  /// SkippedLayout - True if we didn't layout a function due to a being inside
+  /// a recursive struct conversion, set this to true.
+  bool SkippedLayout;
+
+  SmallVector<const RecordDecl *, 8> DeferredRecords;
+  
+private:
+  /// TypeCache - This map keeps cache of llvm::Types
+  /// and maps llvm::Types to corresponding clang::Type.
+  llvm::DenseMap<const Type *, llvm::Type *> TypeCache;
+
+public:
+  CodeGenTypes(CodeGenModule &CGM);
+  ~CodeGenTypes();
+
+  const llvm::TargetData &getTargetData() const { return TheTargetData; }
+  const TargetInfo &getTarget() const { return Target; }
+  ASTContext &getContext() const { return Context; }
+  const ABIInfo &getABIInfo() const { return TheABIInfo; }
+  const CodeGenOptions &getCodeGenOpts() const { return CodeGenOpts; }
+  CGCXXABI &getCXXABI() const { return TheCXXABI; }
+  llvm::LLVMContext &getLLVMContext() { return TheModule.getContext(); }
+
+  /// ConvertType - Convert type T into a llvm::Type.
+  llvm::Type *ConvertType(QualType T);
+
+  /// ConvertTypeForMem - Convert type T into a llvm::Type.  This differs from
+  /// ConvertType in that it is used to convert to the memory representation for
+  /// a type.  For example, the scalar representation for _Bool is i1, but the
+  /// memory representation is usually i8 or i32, depending on the target.
+  llvm::Type *ConvertTypeForMem(QualType T);
+
+  /// GetFunctionType - Get the LLVM function type for \arg Info.
+  llvm::FunctionType *GetFunctionType(const CGFunctionInfo &Info);
+
+  llvm::FunctionType *GetFunctionType(GlobalDecl GD);
+
+  /// isFuncTypeConvertible - Utility to check whether a function type can
+  /// be converted to an LLVM type (i.e. doesn't depend on an incomplete tag
+  /// type).
+  bool isFuncTypeConvertible(const FunctionType *FT);
+  bool isFuncTypeArgumentConvertible(QualType Ty);
+  
+  /// GetFunctionTypeForVTable - Get the LLVM function type for use in a vtable,
+  /// given a CXXMethodDecl. If the method to has an incomplete return type,
+  /// and/or incomplete argument types, this will return the opaque type.
+  llvm::Type *GetFunctionTypeForVTable(GlobalDecl GD);
+
+  const CGRecordLayout &getCGRecordLayout(const RecordDecl*);
+
+  /// UpdateCompletedType - When we find the full definition for a TagDecl,
+  /// replace the 'opaque' type we previously made for it if applicable.
+  void UpdateCompletedType(const TagDecl *TD);
+
+  /// getNullaryFunctionInfo - Get the function info for a void()
+  /// function with standard CC.
+  const CGFunctionInfo &arrangeNullaryFunction();
+
+  // The arrangement methods are split into three families:
+  //   - those meant to drive the signature and prologue/epilogue
+  //     of a function declaration or definition,
+  //   - those meant for the computation of the LLVM type for an abstract
+  //     appearance of a function, and
+  //   - those meant for performing the IR-generation of a call.
+  // They differ mainly in how they deal with optional (i.e. variadic)
+  // arguments, as well as unprototyped functions.
+  //
+  // Key points:
+  // - The CGFunctionInfo for emitting a specific call site must include
+  //   entries for the optional arguments.
+  // - The function type used at the call site must reflect the formal
+  //   signature of the declaration being called, or else the call will
+  //   go awry.
+  // - For the most part, unprototyped functions are called by casting to
+  //   a formal signature inferred from the specific argument types used
+  //   at the call-site.  However, some targets (e.g. x86-64) screw with
+  //   this for compatibility reasons.
+
+  const CGFunctionInfo &arrangeGlobalDeclaration(GlobalDecl GD);
+  const CGFunctionInfo &arrangeFunctionDeclaration(const FunctionDecl *FD);
+  const CGFunctionInfo &arrangeFunctionDeclaration(QualType ResTy,
+                                                   const FunctionArgList &Args,
+                                             const FunctionType::ExtInfo &Info,
+                                                   bool isVariadic);
+
+  const CGFunctionInfo &arrangeObjCMethodDeclaration(const ObjCMethodDecl *MD);
+  const CGFunctionInfo &arrangeObjCMessageSendSignature(const ObjCMethodDecl *MD,
+                                                        QualType receiverType);
+
+  const CGFunctionInfo &arrangeCXXMethodDeclaration(const CXXMethodDecl *MD);
+  const CGFunctionInfo &arrangeCXXConstructorDeclaration(
+                                                    const CXXConstructorDecl *D,
+                                                    CXXCtorType Type);
+  const CGFunctionInfo &arrangeCXXDestructor(const CXXDestructorDecl *D,
+                                             CXXDtorType Type);
+
+  const CGFunctionInfo &arrangeFreeFunctionCall(const CallArgList &Args,
+                                                const FunctionType *Ty);
+  const CGFunctionInfo &arrangeFreeFunctionCall(QualType ResTy,
+                                                const CallArgList &args,
+                                                FunctionType::ExtInfo info,
+                                                RequiredArgs required);
+
+  const CGFunctionInfo &arrangeCXXMethodCall(const CallArgList &args,
+                                             const FunctionProtoType *type,
+                                             RequiredArgs required);
+
+  const CGFunctionInfo &arrangeFreeFunctionType(CanQual<FunctionProtoType> Ty);
+  const CGFunctionInfo &arrangeFreeFunctionType(CanQual<FunctionNoProtoType> Ty);
+  const CGFunctionInfo &arrangeCXXMethodType(const CXXRecordDecl *RD,
+                                             const FunctionProtoType *FTP);
+
+  /// "Arrange" the LLVM information for a call or type with the given
+  /// signature.  This is largely an internal method; other clients
+  /// should use one of the above routines, which ultimately defer to
+  /// this.
+  ///
+  /// \param argTypes - must all actually be canonical as params
+  const CGFunctionInfo &arrangeLLVMFunctionInfo(CanQualType returnType,
+                                                ArrayRef<CanQualType> argTypes,
+                                                FunctionType::ExtInfo info,
+                                                RequiredArgs args);
+
+  /// \brief Compute a new LLVM record layout object for the given record.
+  CGRecordLayout *ComputeRecordLayout(const RecordDecl *D,
+                                      llvm::StructType *Ty);
+
+  /// addRecordTypeName - Compute a name from the given record decl with an
+  /// optional suffix and name the given LLVM type using it.
+  void addRecordTypeName(const RecordDecl *RD, llvm::StructType *Ty,
+                         StringRef suffix);
+  
+
+public:  // These are internal details of CGT that shouldn't be used externally.
+  /// ConvertRecordDeclType - Lay out a tagged decl type like struct or union.
+  llvm::StructType *ConvertRecordDeclType(const RecordDecl *TD);
+
+  /// GetExpandedTypes - Expand the type \arg Ty into the LLVM
+  /// argument types it would be passed as on the provided vector \arg
+  /// ArgTys. See ABIArgInfo::Expand.
+  void GetExpandedTypes(QualType type,
+                        SmallVectorImpl<llvm::Type*> &expanded);
+
+  /// IsZeroInitializable - Return whether a type can be
+  /// zero-initialized (in the C++ sense) with an LLVM zeroinitializer.
+  bool isZeroInitializable(QualType T);
+
+  /// IsZeroInitializable - Return whether a record type can be
+  /// zero-initialized (in the C++ sense) with an LLVM zeroinitializer.
+  bool isZeroInitializable(const CXXRecordDecl *RD);
+  
+  bool isRecordLayoutComplete(const Type *Ty) const;
+  bool noRecordsBeingLaidOut() const {
+    return RecordsBeingLaidOut.empty();
+  }
+  bool isRecordBeingLaidOut(const Type *Ty) const {
+    return RecordsBeingLaidOut.count(Ty);
+  }
+                            
+};
+
+}  // end namespace CodeGen
+}  // end namespace clang
+
+#endif
Index: tools/clang/include/clang/CodeGen/CGVTables.h
===================================================================
--- tools/clang/include/clang/CodeGen/CGVTables.h	(revision 0)
+++ tools/clang/include/clang/CodeGen/CGVTables.h	(revision 47286)
@@ -0,0 +1,141 @@
+//===--- CGVTables.h - Emit LLVM Code for C++ vtables -----------*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This contains code dealing with C++ code generation of virtual tables.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef CLANG_CODEGEN_CGVTABLE_H
+#define CLANG_CODEGEN_CGVTABLE_H
+
+#include "llvm/ADT/DenseMap.h"
+#include "llvm/GlobalVariable.h"
+#include "clang/Basic/ABI.h"
+#include "clang/AST/BaseSubobject.h"
+#include "clang/AST/CharUnits.h"
+#include "clang/AST/GlobalDecl.h"
+#include "clang/AST/VTableBuilder.h"
+
+namespace clang {
+  class CXXRecordDecl;
+
+namespace CodeGen {
+  class CodeGenModule;
+
+class CodeGenVTables {
+  CodeGenModule &CGM;
+
+  VTableContext VTContext;
+
+  /// VTables - All the vtables which have been defined.
+  llvm::DenseMap<const CXXRecordDecl *, llvm::GlobalVariable *> VTables;
+  
+  /// VTableAddressPointsMapTy - Address points for a single vtable.
+  typedef llvm::DenseMap<BaseSubobject, uint64_t> VTableAddressPointsMapTy;
+
+  typedef std::pair<const CXXRecordDecl *, BaseSubobject> BaseSubobjectPairTy;
+  typedef llvm::DenseMap<BaseSubobjectPairTy, uint64_t> SubVTTIndiciesMapTy;
+  
+  /// SubVTTIndicies - Contains indices into the various sub-VTTs.
+  SubVTTIndiciesMapTy SubVTTIndicies;
+
+  typedef llvm::DenseMap<BaseSubobjectPairTy, uint64_t>
+    SecondaryVirtualPointerIndicesMapTy;
+
+  /// SecondaryVirtualPointerIndices - Contains the secondary virtual pointer
+  /// indices.
+  SecondaryVirtualPointerIndicesMapTy SecondaryVirtualPointerIndices;
+
+  /// EmitThunk - Emit a single thunk.
+  void EmitThunk(GlobalDecl GD, const ThunkInfo &Thunk, 
+                 bool UseAvailableExternallyLinkage);
+
+  /// MaybeEmitThunkAvailableExternally - Try to emit the given thunk with
+  /// available_externally linkage to allow for inlining of thunks.
+  /// This will be done iff optimizations are enabled and the member function
+  /// doesn't contain any incomplete types.
+  void MaybeEmitThunkAvailableExternally(GlobalDecl GD, const ThunkInfo &Thunk);
+
+  /// CreateVTableInitializer - Create a vtable initializer for the given record
+  /// decl.
+  /// \param Components - The vtable components; this is really an array of
+  /// VTableComponents.
+  llvm::Constant *CreateVTableInitializer(const CXXRecordDecl *RD,
+                                          const VTableComponent *Components, 
+                                          unsigned NumComponents,
+                                const VTableLayout::VTableThunkTy *VTableThunks,
+                                          unsigned NumVTableThunks);
+
+public:
+  CodeGenVTables(CodeGenModule &CGM);
+
+  VTableContext &getVTableContext() { return VTContext; }
+
+  /// \brief True if the VTable of this record must be emitted in the
+  /// translation unit.
+  bool ShouldEmitVTableInThisTU(const CXXRecordDecl *RD);
+
+  /// needsVTTParameter - Return whether the given global decl needs a VTT
+  /// parameter, which it does if it's a base constructor or destructor with
+  /// virtual bases.
+  static bool needsVTTParameter(GlobalDecl GD);
+
+  /// getSubVTTIndex - Return the index of the sub-VTT for the base class of the
+  /// given record decl.
+  uint64_t getSubVTTIndex(const CXXRecordDecl *RD, BaseSubobject Base);
+  
+  /// getSecondaryVirtualPointerIndex - Return the index in the VTT where the
+  /// virtual pointer for the given subobject is located.
+  uint64_t getSecondaryVirtualPointerIndex(const CXXRecordDecl *RD,
+                                           BaseSubobject Base);
+
+  /// getAddressPoint - Get the address point of the given subobject in the
+  /// class decl.
+  uint64_t getAddressPoint(BaseSubobject Base, const CXXRecordDecl *RD);
+  
+  /// GetAddrOfVTable - Get the address of the vtable for the given record decl.
+  llvm::GlobalVariable *GetAddrOfVTable(const CXXRecordDecl *RD);
+
+  /// EmitVTableDefinition - Emit the definition of the given vtable.
+  void EmitVTableDefinition(llvm::GlobalVariable *VTable,
+                            llvm::GlobalVariable::LinkageTypes Linkage,
+                            const CXXRecordDecl *RD);
+  
+  /// GenerateConstructionVTable - Generate a construction vtable for the given 
+  /// base subobject.
+  llvm::GlobalVariable *
+  GenerateConstructionVTable(const CXXRecordDecl *RD, const BaseSubobject &Base, 
+                             bool BaseIsVirtual, 
+                             llvm::GlobalVariable::LinkageTypes Linkage,
+                             VTableAddressPointsMapTy& AddressPoints);
+
+    
+  /// GetAddrOfVTable - Get the address of the VTT for the given record decl.
+  llvm::GlobalVariable *GetAddrOfVTT(const CXXRecordDecl *RD);
+
+  /// EmitVTTDefinition - Emit the definition of the given vtable.
+  void EmitVTTDefinition(llvm::GlobalVariable *VTT,
+                         llvm::GlobalVariable::LinkageTypes Linkage,
+                         const CXXRecordDecl *RD);
+
+  /// EmitThunks - Emit the associated thunks for the given global decl.
+  void EmitThunks(GlobalDecl GD);
+    
+  /// GenerateClassData - Generate all the class data required to be generated
+  /// upon definition of a KeyFunction.  This includes the vtable, the
+  /// rtti data structure and the VTT.
+  ///
+  /// \param Linkage - The desired linkage of the vtable, the RTTI and the VTT.
+  void GenerateClassData(llvm::GlobalVariable::LinkageTypes Linkage,
+                         const CXXRecordDecl *RD);
+};
+
+} // end namespace CodeGen
+} // end namespace clang
+#endif
Index: tools/clang/include/clang/CodeGen/CodeGenModule.h
===================================================================
--- tools/clang/include/clang/CodeGen/CodeGenModule.h	(revision 0)
+++ tools/clang/include/clang/CodeGen/CodeGenModule.h	(revision 47286)
@@ -0,0 +1,1000 @@
+//===--- CodeGenModule.h - Per-Module state for LLVM CodeGen ----*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This is the internal per-translation-unit state used for llvm translation.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef CLANG_CODEGEN_CODEGENMODULE_H
+#define CLANG_CODEGEN_CODEGENMODULE_H
+
+#include "clang/Basic/ABI.h"
+#include "clang/Basic/LangOptions.h"
+#include "clang/AST/Attr.h"
+#include "clang/AST/DeclCXX.h"
+#include "clang/AST/DeclObjC.h"
+#include "clang/AST/GlobalDecl.h"
+#include "clang/AST/Mangle.h"
+#include "CGVTables.h"
+#include "CodeGenTypes.h"
+#include "llvm/Module.h"
+#include "llvm/ADT/DenseMap.h"
+#include "llvm/ADT/StringMap.h"
+#include "llvm/ADT/SmallPtrSet.h"
+#include "llvm/Support/ValueHandle.h"
+
+namespace llvm {
+  class Module;
+  class Constant;
+  class ConstantInt;
+  class Function;
+  class GlobalValue;
+  class TargetData;
+  class FunctionType;
+  class LLVMContext;
+}
+
+namespace clang {
+  class TargetCodeGenInfo;
+  class ASTContext;
+  class FunctionDecl;
+  class IdentifierInfo;
+  class ObjCMethodDecl;
+  class ObjCImplementationDecl;
+  class ObjCCategoryImplDecl;
+  class ObjCProtocolDecl;
+  class ObjCEncodeExpr;
+  class BlockExpr;
+  class CharUnits;
+  class Decl;
+  class Expr;
+  class Stmt;
+  class InitListExpr;
+  class StringLiteral;
+  class NamedDecl;
+  class ValueDecl;
+  class VarDecl;
+  class LangOptions;
+  class CodeGenOptions;
+  class DiagnosticsEngine;
+  class AnnotateAttr;
+  class CXXDestructorDecl;
+  class MangleBuffer;
+
+namespace CodeGen {
+
+  class CallArgList;
+  class CodeGenFunction;
+  class CodeGenTBAA;
+  class CGCXXABI;
+  class CGDebugInfo;
+  class CGObjCRuntime;
+  class CGOpenCLRuntime;
+  class CGCUDARuntime;
+  class BlockFieldFlags;
+  class FunctionArgList;
+  
+  struct OrderGlobalInits {
+    unsigned int priority;
+    unsigned int lex_order;
+    OrderGlobalInits(unsigned int p, unsigned int l) 
+      : priority(p), lex_order(l) {}
+    
+    bool operator==(const OrderGlobalInits &RHS) const {
+      return priority == RHS.priority &&
+             lex_order == RHS.lex_order;
+    }
+    
+    bool operator<(const OrderGlobalInits &RHS) const {
+      if (priority < RHS.priority)
+        return true;
+      
+      return priority == RHS.priority && lex_order < RHS.lex_order;
+    }
+  };
+
+  struct CodeGenTypeCache {
+    /// void
+    llvm::Type *VoidTy;
+
+    /// i8, i16, i32, and i64
+    llvm::IntegerType *Int8Ty, *Int16Ty, *Int32Ty, *Int64Ty;
+    /// float, double
+    llvm::Type *FloatTy, *DoubleTy;
+
+    /// int
+    llvm::IntegerType *IntTy;
+
+    /// intptr_t, size_t, and ptrdiff_t, which we assume are the same size.
+    union {
+      llvm::IntegerType *IntPtrTy;
+      llvm::IntegerType *SizeTy;
+      llvm::IntegerType *PtrDiffTy;
+    };
+
+    /// void* in address space 0
+    union {
+      llvm::PointerType *VoidPtrTy;
+      llvm::PointerType *Int8PtrTy;
+    };
+
+    /// void** in address space 0
+    union {
+      llvm::PointerType *VoidPtrPtrTy;
+      llvm::PointerType *Int8PtrPtrTy;
+    };
+
+    /// The width of a pointer into the generic address space.
+    unsigned char PointerWidthInBits;
+
+    /// The size and alignment of a pointer into the generic address
+    /// space.
+    union {
+      unsigned char PointerAlignInBytes;
+      unsigned char PointerSizeInBytes;
+      unsigned char SizeSizeInBytes;     // sizeof(size_t)
+    };
+  };
+
+struct RREntrypoints {
+  RREntrypoints() { memset(this, 0, sizeof(*this)); }
+  /// void objc_autoreleasePoolPop(void*);
+  llvm::Constant *objc_autoreleasePoolPop;
+
+  /// void *objc_autoreleasePoolPush(void);
+  llvm::Constant *objc_autoreleasePoolPush;
+};
+
+struct ARCEntrypoints {
+  ARCEntrypoints() { memset(this, 0, sizeof(*this)); }
+
+  /// id objc_autorelease(id);
+  llvm::Constant *objc_autorelease;
+
+  /// id objc_autoreleaseReturnValue(id);
+  llvm::Constant *objc_autoreleaseReturnValue;
+
+  /// void objc_copyWeak(id *dest, id *src);
+  llvm::Constant *objc_copyWeak;
+
+  /// void objc_destroyWeak(id*);
+  llvm::Constant *objc_destroyWeak;
+
+  /// id objc_initWeak(id*, id);
+  llvm::Constant *objc_initWeak;
+
+  /// id objc_loadWeak(id*);
+  llvm::Constant *objc_loadWeak;
+
+  /// id objc_loadWeakRetained(id*);
+  llvm::Constant *objc_loadWeakRetained;
+
+  /// void objc_moveWeak(id *dest, id *src);
+  llvm::Constant *objc_moveWeak;
+
+  /// id objc_retain(id);
+  llvm::Constant *objc_retain;
+
+  /// id objc_retainAutorelease(id);
+  llvm::Constant *objc_retainAutorelease;
+
+  /// id objc_retainAutoreleaseReturnValue(id);
+  llvm::Constant *objc_retainAutoreleaseReturnValue;
+
+  /// id objc_retainAutoreleasedReturnValue(id);
+  llvm::Constant *objc_retainAutoreleasedReturnValue;
+
+  /// id objc_retainBlock(id);
+  llvm::Constant *objc_retainBlock;
+
+  /// void objc_release(id);
+  llvm::Constant *objc_release;
+
+  /// id objc_storeStrong(id*, id);
+  llvm::Constant *objc_storeStrong;
+
+  /// id objc_storeWeak(id*, id);
+  llvm::Constant *objc_storeWeak;
+
+  /// A void(void) inline asm to use to mark that the return value of
+  /// a call will be immediately retain.
+  llvm::InlineAsm *retainAutoreleasedReturnValueMarker;
+};
+  
+/// CodeGenModule - This class organizes the cross-function state that is used
+/// while generating LLVM code.
+class CodeGenModule : public CodeGenTypeCache {
+  CodeGenModule(const CodeGenModule &) LLVM_DELETED_FUNCTION;
+  void operator=(const CodeGenModule &) LLVM_DELETED_FUNCTION;
+
+  typedef std::vector<std::pair<llvm::Constant*, int> > CtorList;
+
+  ASTContext &Context;
+  const LangOptions &LangOpts;
+  const CodeGenOptions &CodeGenOpts;
+  llvm::Module &TheModule;
+  const llvm::TargetData &TheTargetData;
+  mutable const TargetCodeGenInfo *TheTargetCodeGenInfo;
+  DiagnosticsEngine &Diags;
+  CGCXXABI &ABI;
+  CodeGenTypes Types;
+  CodeGenTBAA *TBAA;
+
+  /// VTables - Holds information about C++ vtables.
+  CodeGenVTables VTables;
+  friend class CodeGenVTables;
+
+  CGObjCRuntime* ObjCRuntime;
+  CGOpenCLRuntime* OpenCLRuntime;
+  CGCUDARuntime* CUDARuntime;
+  CGDebugInfo* DebugInfo;
+  ARCEntrypoints *ARCData;
+  llvm::MDNode *NoObjCARCExceptionsMetadata;
+  RREntrypoints *RRData;
+
+  // WeakRefReferences - A set of references that have only been seen via
+  // a weakref so far. This is used to remove the weak of the reference if we ever
+  // see a direct reference or a definition.
+  llvm::SmallPtrSet<llvm::GlobalValue*, 10> WeakRefReferences;
+
+  /// DeferredDecls - This contains all the decls which have definitions but
+  /// which are deferred for emission and therefore should only be output if
+  /// they are actually used.  If a decl is in this, then it is known to have
+  /// not been referenced yet.
+  llvm::StringMap<GlobalDecl> DeferredDecls;
+
+  /// DeferredDeclsToEmit - This is a list of deferred decls which we have seen
+  /// that *are* actually referenced.  These get code generated when the module
+  /// is done.
+  std::vector<GlobalDecl> DeferredDeclsToEmit;
+
+  /// LLVMUsed - List of global values which are required to be
+  /// present in the object file; bitcast to i8*. This is used for
+  /// forcing visibility of symbols which may otherwise be optimized
+  /// out.
+  std::vector<llvm::WeakVH> LLVMUsed;
+
+  /// GlobalCtors - Store the list of global constructors and their respective
+  /// priorities to be emitted when the translation unit is complete.
+  CtorList GlobalCtors;
+
+  /// GlobalDtors - Store the list of global destructors and their respective
+  /// priorities to be emitted when the translation unit is complete.
+  CtorList GlobalDtors;
+
+  /// MangledDeclNames - A map of canonical GlobalDecls to their mangled names.
+  llvm::DenseMap<GlobalDecl, StringRef> MangledDeclNames;
+  llvm::BumpPtrAllocator MangledNamesAllocator;
+  
+  /// Global annotations.
+  std::vector<llvm::Constant*> Annotations;
+
+  /// Map used to get unique annotation strings.
+  llvm::StringMap<llvm::Constant*> AnnotationStrings;
+
+  llvm::StringMap<llvm::Constant*> CFConstantStringMap;
+  llvm::StringMap<llvm::GlobalVariable*> ConstantStringMap;
+  llvm::DenseMap<const Decl*, llvm::Constant *> StaticLocalDeclMap;
+  llvm::DenseMap<const Decl*, llvm::GlobalVariable*> StaticLocalDeclGuardMap;
+  
+  llvm::DenseMap<QualType, llvm::Constant *> AtomicSetterHelperFnMap;
+  llvm::DenseMap<QualType, llvm::Constant *> AtomicGetterHelperFnMap;
+
+  /// CXXGlobalInits - Global variables with initializers that need to run
+  /// before main.
+  std::vector<llvm::Constant*> CXXGlobalInits;
+
+  /// When a C++ decl with an initializer is deferred, null is
+  /// appended to CXXGlobalInits, and the index of that null is placed
+  /// here so that the initializer will be performed in the correct
+  /// order.
+  llvm::DenseMap<const Decl*, unsigned> DelayedCXXInitPosition;
+  
+  /// - Global variables with initializers whose order of initialization
+  /// is set by init_priority attribute.
+  
+  SmallVector<std::pair<OrderGlobalInits, llvm::Function*>, 8> 
+    PrioritizedCXXGlobalInits;
+
+  /// CXXGlobalDtors - Global destructor functions and arguments that need to
+  /// run on termination.
+  std::vector<std::pair<llvm::WeakVH,llvm::Constant*> > CXXGlobalDtors;
+
+  /// @name Cache for Objective-C runtime types
+  /// @{
+
+  /// CFConstantStringClassRef - Cached reference to the class for constant
+  /// strings. This value has type int * but is actually an Obj-C class pointer.
+  llvm::Constant *CFConstantStringClassRef;
+
+  /// ConstantStringClassRef - Cached reference to the class for constant
+  /// strings. This value has type int * but is actually an Obj-C class pointer.
+  llvm::Constant *ConstantStringClassRef;
+
+  /// \brief The LLVM type corresponding to NSConstantString.
+  llvm::StructType *NSConstantStringType;
+  
+  /// \brief The type used to describe the state of a fast enumeration in
+  /// Objective-C's for..in loop.
+  QualType ObjCFastEnumerationStateType;
+  
+  /// @}
+
+  /// Lazily create the Objective-C runtime
+  void createObjCRuntime();
+
+  void createOpenCLRuntime();
+  void createCUDARuntime();
+
+  bool isTriviallyRecursive(const FunctionDecl *F);
+  bool shouldEmitFunction(const FunctionDecl *F);
+  llvm::LLVMContext &VMContext;
+
+  /// @name Cache for Blocks Runtime Globals
+  /// @{
+
+  llvm::Constant *NSConcreteGlobalBlock;
+  llvm::Constant *NSConcreteStackBlock;
+
+  llvm::Constant *BlockObjectAssign;
+  llvm::Constant *BlockObjectDispose;
+
+  llvm::Type *BlockDescriptorType;
+  llvm::Type *GenericBlockLiteralType;
+
+  struct {
+    int GlobalUniqueCount;
+  } Block;
+  
+  GlobalDecl initializedGlobalDecl;
+
+  /// @}
+public:
+  CodeGenModule(ASTContext &C, const CodeGenOptions &CodeGenOpts,
+                llvm::Module &M, const llvm::TargetData &TD,
+                DiagnosticsEngine &Diags);
+
+  ~CodeGenModule();
+
+  /// Release - Finalize LLVM code generation.
+  void Release();
+
+  /// getObjCRuntime() - Return a reference to the configured
+  /// Objective-C runtime.
+  CGObjCRuntime &getObjCRuntime() {
+    if (!ObjCRuntime) createObjCRuntime();
+    return *ObjCRuntime;
+  }
+
+  /// hasObjCRuntime() - Return true iff an Objective-C runtime has
+  /// been configured.
+  bool hasObjCRuntime() { return !!ObjCRuntime; }
+
+  /// getOpenCLRuntime() - Return a reference to the configured OpenCL runtime.
+  CGOpenCLRuntime &getOpenCLRuntime() {
+    assert(OpenCLRuntime != 0);
+    return *OpenCLRuntime;
+  }
+
+  /// getCUDARuntime() - Return a reference to the configured CUDA runtime.
+  CGCUDARuntime &getCUDARuntime() {
+    assert(CUDARuntime != 0);
+    return *CUDARuntime;
+  }
+
+  /// getCXXABI() - Return a reference to the configured C++ ABI.
+  CGCXXABI &getCXXABI() { return ABI; }
+
+  ARCEntrypoints &getARCEntrypoints() const {
+    assert(getLangOpts().ObjCAutoRefCount && ARCData != 0);
+    return *ARCData;
+  }
+
+  RREntrypoints &getRREntrypoints() const {
+    assert(RRData != 0);
+    return *RRData;
+  }
+
+  llvm::Constant *getStaticLocalDeclAddress(const VarDecl *D) {
+    return StaticLocalDeclMap[D];
+  }
+  void setStaticLocalDeclAddress(const VarDecl *D, 
+                                 llvm::Constant *C) {
+    StaticLocalDeclMap[D] = C;
+  }
+
+  llvm::GlobalVariable *getStaticLocalDeclGuardAddress(const VarDecl *D) {
+    return StaticLocalDeclGuardMap[D];
+  }
+  void setStaticLocalDeclGuardAddress(const VarDecl *D, 
+                                      llvm::GlobalVariable *C) {
+    StaticLocalDeclGuardMap[D] = C;
+  }
+
+  llvm::Constant *getAtomicSetterHelperFnMap(QualType Ty) {
+    return AtomicSetterHelperFnMap[Ty];
+  }
+  void setAtomicSetterHelperFnMap(QualType Ty,
+                            llvm::Constant *Fn) {
+    AtomicSetterHelperFnMap[Ty] = Fn;
+  }
+
+  llvm::Constant *getAtomicGetterHelperFnMap(QualType Ty) {
+    return AtomicGetterHelperFnMap[Ty];
+  }
+  void setAtomicGetterHelperFnMap(QualType Ty,
+                            llvm::Constant *Fn) {
+    AtomicGetterHelperFnMap[Ty] = Fn;
+  }
+
+  CGDebugInfo *getModuleDebugInfo() { return DebugInfo; }
+
+  llvm::MDNode *getNoObjCARCExceptionsMetadata() {
+    if (!NoObjCARCExceptionsMetadata)
+      NoObjCARCExceptionsMetadata =
+        llvm::MDNode::get(getLLVMContext(),
+                          SmallVector<llvm::Value*,1>());
+    return NoObjCARCExceptionsMetadata;
+  }
+
+  ASTContext &getContext() const { return Context; }
+  const CodeGenOptions &getCodeGenOpts() const { return CodeGenOpts; }
+  const LangOptions &getLangOpts() const { return LangOpts; }
+  llvm::Module &getModule() const { return TheModule; }
+  CodeGenTypes &getTypes() { return Types; }
+  CodeGenVTables &getVTables() { return VTables; }
+  VTableContext &getVTableContext() { return VTables.getVTableContext(); }
+  DiagnosticsEngine &getDiags() const { return Diags; }
+  const llvm::TargetData &getTargetData() const { return TheTargetData; }
+  const TargetInfo &getTarget() const { return Context.getTargetInfo(); }
+  llvm::LLVMContext &getLLVMContext() { return VMContext; }
+  const TargetCodeGenInfo &getTargetCodeGenInfo();
+  bool isTargetDarwin() const;
+
+  bool shouldUseTBAA() const { return TBAA != 0; }
+
+  llvm::MDNode *getTBAAInfo(QualType QTy);
+  llvm::MDNode *getTBAAInfoForVTablePtr();
+  llvm::MDNode *getTBAAStructInfo(QualType QTy);
+
+  bool isTypeConstant(QualType QTy, bool ExcludeCtorDtor);
+
+  static void DecorateInstruction(llvm::Instruction *Inst,
+                                  llvm::MDNode *TBAAInfo);
+
+  /// getSize - Emit the given number of characters as a value of type size_t.
+  llvm::ConstantInt *getSize(CharUnits numChars);
+
+  /// setGlobalVisibility - Set the visibility for the given LLVM
+  /// GlobalValue.
+  void setGlobalVisibility(llvm::GlobalValue *GV, const NamedDecl *D) const;
+
+  /// setTLSMode - Set the TLS mode for the given LLVM GlobalVariable
+  /// for the thread-local variable declaration D.
+  void setTLSMode(llvm::GlobalVariable *GV, const VarDecl &D) const;
+
+  /// TypeVisibilityKind - The kind of global variable that is passed to 
+  /// setTypeVisibility
+  enum TypeVisibilityKind {
+    TVK_ForVTT,
+    TVK_ForVTable,
+    TVK_ForConstructionVTable,
+    TVK_ForRTTI,
+    TVK_ForRTTIName
+  };
+
+  /// setTypeVisibility - Set the visibility for the given global
+  /// value which holds information about a type.
+  void setTypeVisibility(llvm::GlobalValue *GV, const CXXRecordDecl *D,
+                         TypeVisibilityKind TVK) const;
+
+  static llvm::GlobalValue::VisibilityTypes GetLLVMVisibility(Visibility V) {
+    switch (V) {
+    case DefaultVisibility:   return llvm::GlobalValue::DefaultVisibility;
+    case HiddenVisibility:    return llvm::GlobalValue::HiddenVisibility;
+    case ProtectedVisibility: return llvm::GlobalValue::ProtectedVisibility;
+    }
+    llvm_unreachable("unknown visibility!");
+  }
+
+  llvm::Constant *GetAddrOfGlobal(GlobalDecl GD) {
+    if (isa<CXXConstructorDecl>(GD.getDecl()))
+      return GetAddrOfCXXConstructor(cast<CXXConstructorDecl>(GD.getDecl()),
+                                     GD.getCtorType());
+    else if (isa<CXXDestructorDecl>(GD.getDecl()))
+      return GetAddrOfCXXDestructor(cast<CXXDestructorDecl>(GD.getDecl()),
+                                     GD.getDtorType());
+    else if (isa<FunctionDecl>(GD.getDecl()))
+      return GetAddrOfFunction(GD);
+    else
+      return GetAddrOfGlobalVar(cast<VarDecl>(GD.getDecl()));
+  }
+
+  /// CreateOrReplaceCXXRuntimeVariable - Will return a global variable of the given
+  /// type. If a variable with a different type already exists then a new 
+  /// variable with the right type will be created and all uses of the old
+  /// variable will be replaced with a bitcast to the new variable.
+  llvm::GlobalVariable *
+  CreateOrReplaceCXXRuntimeVariable(StringRef Name, llvm::Type *Ty,
+                                    llvm::GlobalValue::LinkageTypes Linkage);
+
+  /// GetGlobalVarAddressSpace - Return the address space of the underlying
+  /// global variable for D, as determined by its declaration.  Normally this
+  /// is the same as the address space of D's type, but in CUDA, address spaces
+  /// are associated with declarations, not types.
+  unsigned GetGlobalVarAddressSpace(const VarDecl *D, unsigned AddrSpace);
+
+  /// GetAddrOfGlobalVar - Return the llvm::Constant for the address of the
+  /// given global variable.  If Ty is non-null and if the global doesn't exist,
+  /// then it will be greated with the specified type instead of whatever the
+  /// normal requested type would be.
+  llvm::Constant *GetAddrOfGlobalVar(const VarDecl *D,
+                                     llvm::Type *Ty = 0);
+
+
+  /// GetAddrOfFunction - Return the address of the given function.  If Ty is
+  /// non-null, then this function will use the specified type if it has to
+  /// create it.
+  llvm::Constant *GetAddrOfFunction(GlobalDecl GD,
+                                    llvm::Type *Ty = 0,
+                                    bool ForVTable = false);
+
+  /// GetAddrOfRTTIDescriptor - Get the address of the RTTI descriptor 
+  /// for the given type.
+  llvm::Constant *GetAddrOfRTTIDescriptor(QualType Ty, bool ForEH = false);
+
+  /// GetAddrOfThunk - Get the address of the thunk for the given global decl.
+  llvm::Constant *GetAddrOfThunk(GlobalDecl GD, const ThunkInfo &Thunk);
+
+  /// GetWeakRefReference - Get a reference to the target of VD.
+  llvm::Constant *GetWeakRefReference(const ValueDecl *VD);
+
+  /// GetNonVirtualBaseClassOffset - Returns the offset from a derived class to 
+  /// a class. Returns null if the offset is 0. 
+  llvm::Constant *
+  GetNonVirtualBaseClassOffset(const CXXRecordDecl *ClassDecl,
+                               CastExpr::path_const_iterator PathBegin,
+                               CastExpr::path_const_iterator PathEnd);
+
+  /// A pair of helper functions for a __block variable.
+  class ByrefHelpers : public llvm::FoldingSetNode {
+  public:
+    llvm::Constant *CopyHelper;
+    llvm::Constant *DisposeHelper;
+
+    /// The alignment of the field.  This is important because
+    /// different offsets to the field within the byref struct need to
+    /// have different helper functions.
+    CharUnits Alignment;
+
+    ByrefHelpers(CharUnits alignment) : Alignment(alignment) {}
+    virtual ~ByrefHelpers();
+
+    void Profile(llvm::FoldingSetNodeID &id) const {
+      id.AddInteger(Alignment.getQuantity());
+      profileImpl(id);
+    }
+    virtual void profileImpl(llvm::FoldingSetNodeID &id) const = 0;
+
+    virtual bool needsCopy() const { return true; }
+    virtual void emitCopy(CodeGenFunction &CGF,
+                          llvm::Value *dest, llvm::Value *src) = 0;
+
+    virtual bool needsDispose() const { return true; }
+    virtual void emitDispose(CodeGenFunction &CGF, llvm::Value *field) = 0;
+  };
+
+  llvm::FoldingSet<ByrefHelpers> ByrefHelpersCache;
+
+  /// getUniqueBlockCount - Fetches the global unique block count.
+  int getUniqueBlockCount() { return ++Block.GlobalUniqueCount; }
+  
+  /// getBlockDescriptorType - Fetches the type of a generic block
+  /// descriptor.
+  llvm::Type *getBlockDescriptorType();
+
+  /// getGenericBlockLiteralType - The type of a generic block literal.
+  llvm::Type *getGenericBlockLiteralType();
+
+  /// GetAddrOfGlobalBlock - Gets the address of a block which
+  /// requires no captures.
+  llvm::Constant *GetAddrOfGlobalBlock(const BlockExpr *BE, const char *);
+  
+  /// GetAddrOfConstantCFString - Return a pointer to a constant CFString object
+  /// for the given string.
+  llvm::Constant *GetAddrOfConstantCFString(const StringLiteral *Literal);
+  
+  /// GetAddrOfConstantString - Return a pointer to a constant NSString object
+  /// for the given string. Or a user defined String object as defined via
+  /// -fconstant-string-class=class_name option.
+  llvm::Constant *GetAddrOfConstantString(const StringLiteral *Literal);
+
+  /// GetConstantArrayFromStringLiteral - Return a constant array for the given
+  /// string.
+  llvm::Constant *GetConstantArrayFromStringLiteral(const StringLiteral *E);
+
+  /// GetAddrOfConstantStringFromLiteral - Return a pointer to a constant array
+  /// for the given string literal.
+  llvm::Constant *GetAddrOfConstantStringFromLiteral(const StringLiteral *S);
+
+  /// GetAddrOfConstantStringFromObjCEncode - Return a pointer to a constant
+  /// array for the given ObjCEncodeExpr node.
+  llvm::Constant *GetAddrOfConstantStringFromObjCEncode(const ObjCEncodeExpr *);
+
+  /// GetAddrOfConstantString - Returns a pointer to a character array
+  /// containing the literal. This contents are exactly that of the given
+  /// string, i.e. it will not be null terminated automatically; see
+  /// GetAddrOfConstantCString. Note that whether the result is actually a
+  /// pointer to an LLVM constant depends on Feature.WriteableStrings.
+  ///
+  /// The result has pointer to array type.
+  ///
+  /// \param GlobalName If provided, the name to use for the global
+  /// (if one is created).
+  llvm::Constant *GetAddrOfConstantString(StringRef Str,
+                                          const char *GlobalName=0,
+                                          unsigned Alignment=1);
+
+  /// GetAddrOfConstantCString - Returns a pointer to a character array
+  /// containing the literal and a terminating '\0' character. The result has
+  /// pointer to array type.
+  ///
+  /// \param GlobalName If provided, the name to use for the global (if one is
+  /// created).
+  llvm::Constant *GetAddrOfConstantCString(const std::string &str,
+                                           const char *GlobalName=0,
+                                           unsigned Alignment=1);
+
+  /// GetAddrOfConstantCompoundLiteral - Returns a pointer to a constant global
+  /// variable for the given file-scope compound literal expression.
+  llvm::Constant *GetAddrOfConstantCompoundLiteral(const CompoundLiteralExpr*E);
+  
+  /// \brief Retrieve the record type that describes the state of an
+  /// Objective-C fast enumeration loop (for..in).
+  QualType getObjCFastEnumerationStateType();
+  
+  /// GetAddrOfCXXConstructor - Return the address of the constructor of the
+  /// given type.
+  llvm::GlobalValue *GetAddrOfCXXConstructor(const CXXConstructorDecl *ctor,
+                                             CXXCtorType ctorType,
+                                             const CGFunctionInfo *fnInfo = 0);
+
+  /// GetAddrOfCXXDestructor - Return the address of the constructor of the
+  /// given type.
+  llvm::GlobalValue *GetAddrOfCXXDestructor(const CXXDestructorDecl *dtor,
+                                            CXXDtorType dtorType,
+                                            const CGFunctionInfo *fnInfo = 0);
+
+  /// getBuiltinLibFunction - Given a builtin id for a function like
+  /// "__builtin_fabsf", return a Function* for "fabsf".
+  llvm::Value *getBuiltinLibFunction(const FunctionDecl *FD,
+                                     unsigned BuiltinID);
+
+  llvm::Function *getIntrinsic(unsigned IID, ArrayRef<llvm::Type*> Tys =
+                                                 ArrayRef<llvm::Type*>());
+
+  /// EmitTopLevelDecl - Emit code for a single top level declaration.
+  void EmitTopLevelDecl(Decl *D);
+
+  /// HandleCXXStaticMemberVarInstantiation - Tell the consumer that this
+  // variable has been instantiated.
+  void HandleCXXStaticMemberVarInstantiation(VarDecl *VD);
+
+  /// AddUsedGlobal - Add a global which should be forced to be
+  /// present in the object file; these are emitted to the llvm.used
+  /// metadata global.
+  void AddUsedGlobal(llvm::GlobalValue *GV);
+
+  /// AddCXXDtorEntry - Add a destructor and object to add to the C++ global
+  /// destructor function.
+  void AddCXXDtorEntry(llvm::Constant *DtorFn, llvm::Constant *Object) {
+    CXXGlobalDtors.push_back(std::make_pair(DtorFn, Object));
+  }
+
+  /// CreateRuntimeFunction - Create a new runtime function with the specified
+  /// type and name.
+  llvm::Constant *CreateRuntimeFunction(llvm::FunctionType *Ty,
+                                        StringRef Name,
+                                        llvm::Attributes ExtraAttrs =
+                                          llvm::Attribute::None);
+  /// CreateRuntimeVariable - Create a new runtime global variable with the
+  /// specified type and name.
+  llvm::Constant *CreateRuntimeVariable(llvm::Type *Ty,
+                                        StringRef Name);
+
+  ///@name Custom Blocks Runtime Interfaces
+  ///@{
+
+  llvm::Constant *getNSConcreteGlobalBlock();
+  llvm::Constant *getNSConcreteStackBlock();
+  llvm::Constant *getBlockObjectAssign();
+  llvm::Constant *getBlockObjectDispose();
+
+  ///@}
+
+  // UpdateCompleteType - Make sure that this type is translated.
+  void UpdateCompletedType(const TagDecl *TD);
+
+  llvm::Constant *getMemberPointerConstant(const UnaryOperator *e);
+
+  /// EmitConstantInit - Try to emit the initializer for the given declaration
+  /// as a constant; returns 0 if the expression cannot be emitted as a
+  /// constant.
+  llvm::Constant *EmitConstantInit(const VarDecl &D, CodeGenFunction *CGF = 0);
+
+  /// EmitConstantExpr - Try to emit the given expression as a
+  /// constant; returns 0 if the expression cannot be emitted as a
+  /// constant.
+  llvm::Constant *EmitConstantExpr(const Expr *E, QualType DestType,
+                                   CodeGenFunction *CGF = 0);
+
+  /// EmitConstantValue - Emit the given constant value as a constant, in the
+  /// type's scalar representation.
+  llvm::Constant *EmitConstantValue(const APValue &Value, QualType DestType,
+                                    CodeGenFunction *CGF = 0);
+
+  /// EmitConstantValueForMemory - Emit the given constant value as a constant,
+  /// in the type's memory representation.
+  llvm::Constant *EmitConstantValueForMemory(const APValue &Value,
+                                             QualType DestType,
+                                             CodeGenFunction *CGF = 0);
+
+  /// EmitNullConstant - Return the result of value-initializing the given
+  /// type, i.e. a null expression of the given type.  This is usually,
+  /// but not always, an LLVM null constant.
+  llvm::Constant *EmitNullConstant(QualType T);
+
+  /// EmitNullConstantForBase - Return a null constant appropriate for 
+  /// zero-initializing a base class with the given type.  This is usually,
+  /// but not always, an LLVM null constant.
+  llvm::Constant *EmitNullConstantForBase(const CXXRecordDecl *Record);
+
+  /// Error - Emit a general error that something can't be done.
+  void Error(SourceLocation loc, StringRef error);
+
+  /// ErrorUnsupported - Print out an error that codegen doesn't support the
+  /// specified stmt yet.
+  /// \param OmitOnError - If true, then this error should only be emitted if no
+  /// other errors have been reported.
+  void ErrorUnsupported(const Stmt *S, const char *Type,
+                        bool OmitOnError=false);
+
+  /// ErrorUnsupported - Print out an error that codegen doesn't support the
+  /// specified decl yet.
+  /// \param OmitOnError - If true, then this error should only be emitted if no
+  /// other errors have been reported.
+  void ErrorUnsupported(const Decl *D, const char *Type,
+                        bool OmitOnError=false);
+
+  /// SetInternalFunctionAttributes - Set the attributes on the LLVM
+  /// function for the given decl and function info. This applies
+  /// attributes necessary for handling the ABI as well as user
+  /// specified attributes like section.
+  void SetInternalFunctionAttributes(const Decl *D, llvm::Function *F,
+                                     const CGFunctionInfo &FI);
+
+  /// SetLLVMFunctionAttributes - Set the LLVM function attributes
+  /// (sext, zext, etc).
+  void SetLLVMFunctionAttributes(const Decl *D,
+                                 const CGFunctionInfo &Info,
+                                 llvm::Function *F);
+
+  /// SetLLVMFunctionAttributesForDefinition - Set the LLVM function attributes
+  /// which only apply to a function definintion.
+  void SetLLVMFunctionAttributesForDefinition(const Decl *D, llvm::Function *F);
+
+  /// ReturnTypeUsesSRet - Return true iff the given type uses 'sret' when used
+  /// as a return type.
+  bool ReturnTypeUsesSRet(const CGFunctionInfo &FI);
+
+  /// ReturnTypeUsesFPRet - Return true iff the given type uses 'fpret' when
+  /// used as a return type.
+  bool ReturnTypeUsesFPRet(QualType ResultType);
+
+  /// ReturnTypeUsesFP2Ret - Return true iff the given type uses 'fp2ret' when
+  /// used as a return type.
+  bool ReturnTypeUsesFP2Ret(QualType ResultType);
+
+  /// ConstructAttributeList - Get the LLVM attributes and calling convention to
+  /// use for a particular function type.
+  ///
+  /// \param Info - The function type information.
+  /// \param TargetDecl - The decl these attributes are being constructed
+  /// for. If supplied the attributes applied to this decl may contribute to the
+  /// function attributes and calling convention.
+  /// \param PAL [out] - On return, the attribute list to use.
+  /// \param CallingConv [out] - On return, the LLVM calling convention to use.
+  void ConstructAttributeList(const CGFunctionInfo &Info,
+                              const Decl *TargetDecl,
+                              AttributeListType &PAL,
+                              unsigned &CallingConv);
+
+  StringRef getMangledName(GlobalDecl GD);
+  void getBlockMangledName(GlobalDecl GD, MangleBuffer &Buffer,
+                           const BlockDecl *BD);
+
+  void EmitTentativeDefinition(const VarDecl *D);
+
+  void EmitVTable(CXXRecordDecl *Class, bool DefinitionRequired);
+
+  llvm::GlobalVariable::LinkageTypes
+  getFunctionLinkage(const FunctionDecl *FD);
+
+  void setFunctionLinkage(const FunctionDecl *FD, llvm::GlobalValue *V) {
+    V->setLinkage(getFunctionLinkage(FD));
+  }
+
+  /// getVTableLinkage - Return the appropriate linkage for the vtable, VTT,
+  /// and type information of the given class.
+  llvm::GlobalVariable::LinkageTypes getVTableLinkage(const CXXRecordDecl *RD);
+
+  /// GetTargetTypeStoreSize - Return the store size, in character units, of
+  /// the given LLVM type.
+  CharUnits GetTargetTypeStoreSize(llvm::Type *Ty) const;
+  
+  /// GetLLVMLinkageVarDefinition - Returns LLVM linkage for a global 
+  /// variable.
+  llvm::GlobalValue::LinkageTypes 
+  GetLLVMLinkageVarDefinition(const VarDecl *D,
+                              llvm::GlobalVariable *GV);
+  
+  std::vector<const CXXRecordDecl*> DeferredVTables;
+
+  /// Emit all the global annotations.
+  void EmitGlobalAnnotations();
+
+  /// Emit an annotation string.
+  llvm::Constant *EmitAnnotationString(llvm::StringRef Str);
+
+  /// Emit the annotation's translation unit.
+  llvm::Constant *EmitAnnotationUnit(SourceLocation Loc);
+
+  /// Emit the annotation line number.
+  llvm::Constant *EmitAnnotationLineNo(SourceLocation L);
+
+  /// EmitAnnotateAttr - Generate the llvm::ConstantStruct which contains the
+  /// annotation information for a given GlobalValue. The annotation struct is
+  /// {i8 *, i8 *, i8 *, i32}. The first field is a constant expression, the
+  /// GlobalValue being annotated. The second field is the constant string
+  /// created from the AnnotateAttr's annotation. The third field is a constant
+  /// string containing the name of the translation unit. The fourth field is
+  /// the line number in the file of the annotated value declaration.
+  llvm::Constant *EmitAnnotateAttr(llvm::GlobalValue *GV,
+                                   const AnnotateAttr *AA,
+                                   SourceLocation L);
+
+  /// Add global annotations that are set on D, for the global GV. Those
+  /// annotations are emitted during finalization of the LLVM code.
+  void AddGlobalAnnotations(const ValueDecl *D, llvm::GlobalValue *GV);
+
+private:
+  llvm::GlobalValue *GetGlobalValue(StringRef Ref);
+
+  llvm::Constant *GetOrCreateLLVMFunction(StringRef MangledName,
+                                          llvm::Type *Ty,
+                                          GlobalDecl D,
+                                          bool ForVTable,
+                                          llvm::Attributes ExtraAttrs =
+                                            llvm::Attribute::None);
+  llvm::Constant *GetOrCreateLLVMGlobal(StringRef MangledName,
+                                        llvm::PointerType *PTy,
+                                        const VarDecl *D,
+                                        bool UnnamedAddr = false);
+
+  /// SetCommonAttributes - Set attributes which are common to any
+  /// form of a global definition (alias, Objective-C method,
+  /// function, global variable).
+  ///
+  /// NOTE: This should only be called for definitions.
+  void SetCommonAttributes(const Decl *D, llvm::GlobalValue *GV);
+
+  /// SetFunctionDefinitionAttributes - Set attributes for a global definition.
+  void SetFunctionDefinitionAttributes(const FunctionDecl *D,
+                                       llvm::GlobalValue *GV);
+
+  /// SetFunctionAttributes - Set function attributes for a function
+  /// declaration.
+  void SetFunctionAttributes(GlobalDecl GD,
+                             llvm::Function *F,
+                             bool IsIncompleteFunction);
+
+  /// EmitGlobal - Emit code for a singal global function or var decl. Forward
+  /// declarations are emitted lazily.
+  void EmitGlobal(GlobalDecl D);
+
+  void EmitGlobalDefinition(GlobalDecl D);
+
+  void EmitGlobalFunctionDefinition(GlobalDecl GD);
+  void EmitGlobalVarDefinition(const VarDecl *D);
+  llvm::Constant *MaybeEmitGlobalStdInitializerListInitializer(const VarDecl *D,
+                                                              const Expr *init);
+  void EmitAliasDefinition(GlobalDecl GD);
+  void EmitObjCPropertyImplementations(const ObjCImplementationDecl *D);
+  void EmitObjCIvarInitializations(ObjCImplementationDecl *D);
+  
+  // C++ related functions.
+
+  bool TryEmitDefinitionAsAlias(GlobalDecl Alias, GlobalDecl Target);
+  bool TryEmitBaseDestructorAsAlias(const CXXDestructorDecl *D);
+
+  void EmitNamespace(const NamespaceDecl *D);
+  void EmitLinkageSpec(const LinkageSpecDecl *D);
+
+  /// EmitCXXConstructors - Emit constructors (base, complete) from a
+  /// C++ constructor Decl.
+  void EmitCXXConstructors(const CXXConstructorDecl *D);
+
+  /// EmitCXXConstructor - Emit a single constructor with the given type from
+  /// a C++ constructor Decl.
+  void EmitCXXConstructor(const CXXConstructorDecl *D, CXXCtorType Type);
+
+  /// EmitCXXDestructors - Emit destructors (base, complete) from a
+  /// C++ destructor Decl.
+  void EmitCXXDestructors(const CXXDestructorDecl *D);
+
+  /// EmitCXXDestructor - Emit a single destructor with the given type from
+  /// a C++ destructor Decl.
+  void EmitCXXDestructor(const CXXDestructorDecl *D, CXXDtorType Type);
+
+  /// EmitCXXGlobalInitFunc - Emit the function that initializes C++ globals.
+  void EmitCXXGlobalInitFunc();
+
+  /// EmitCXXGlobalDtorFunc - Emit the function that destroys C++ globals.
+  void EmitCXXGlobalDtorFunc();
+
+  /// EmitCXXGlobalVarDeclInitFunc - Emit the function that initializes the
+  /// specified global (if PerformInit is true) and registers its destructor.
+  void EmitCXXGlobalVarDeclInitFunc(const VarDecl *D,
+                                    llvm::GlobalVariable *Addr,
+                                    bool PerformInit);
+
+  // FIXME: Hardcoding priority here is gross.
+  void AddGlobalCtor(llvm::Function *Ctor, int Priority=65535);
+  void AddGlobalDtor(llvm::Function *Dtor, int Priority=65535);
+
+  /// EmitCtorList - Generates a global array of functions and priorities using
+  /// the given list and name. This array will have appending linkage and is
+  /// suitable for use as a LLVM constructor or destructor array.
+  void EmitCtorList(const CtorList &Fns, const char *GlobalName);
+
+  /// EmitFundamentalRTTIDescriptor - Emit the RTTI descriptors for the
+  /// given type.
+  void EmitFundamentalRTTIDescriptor(QualType Type);
+
+  /// EmitFundamentalRTTIDescriptors - Emit the RTTI descriptors for the
+  /// builtin types.
+  void EmitFundamentalRTTIDescriptors();
+
+  /// EmitDeferred - Emit any needed decls for which code generation
+  /// was deferred.
+  void EmitDeferred(void);
+
+  /// EmitLLVMUsed - Emit the llvm.used metadata used to force
+  /// references to global which may otherwise be optimized out.
+  void EmitLLVMUsed(void);
+
+  void EmitDeclMetadata();
+
+  /// EmitCoverageFile - Emit the llvm.gcov metadata used to tell LLVM where
+  /// to emit the .gcno and .gcda files in a way that persists in .bc files.
+  void EmitCoverageFile();
+
+  /// MayDeferGeneration - Determine if the given decl can be emitted
+  /// lazily; this is only relevant for definitions. The given decl
+  /// must be either a function or var decl.
+  bool MayDeferGeneration(const ValueDecl *D);
+
+  /// SimplifyPersonality - Check whether we can use a "simpler", more
+  /// core exceptions personality function.
+  void SimplifyPersonality();
+};
+}  // end namespace CodeGen
+}  // end namespace clang
+
+#endif
Index: tools/clang/include/clang/CodeGen/ModuleBuilder.h
===================================================================
--- tools/clang/include/clang/CodeGen/ModuleBuilder.h	(revision 47284)
+++ tools/clang/include/clang/CodeGen/ModuleBuilder.h	(revision 47286)
@@ -27,11 +27,16 @@
   class LangOptions;
   class CodeGenOptions;
 
+  namespace CodeGen {
+    class CodeGenModule;
+  }
+
   class CodeGenerator : public ASTConsumer {
     virtual void anchor();
   public:
     virtual llvm::Module* GetModule() = 0;
     virtual llvm::Module* ReleaseModule() = 0;
+    virtual CodeGen::CodeGenModule* GetBuilder() = 0;
   };
 
   /// CreateLLVMCodeGen - Create a CodeGenerator instance.
Index: tools/clang/include/clang/CodeGen/CGCall.h
===================================================================
--- tools/clang/include/clang/CodeGen/CGCall.h	(revision 0)
+++ tools/clang/include/clang/CodeGen/CGCall.h	(revision 47286)
@@ -0,0 +1,306 @@
+//===----- CGCall.h - Encapsulate calling convention details ----*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// These classes wrap the information about a call or function
+// definition used to handle ABI compliancy.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef CLANG_CODEGEN_CGCALL_H
+#define CLANG_CODEGEN_CGCALL_H
+
+#include "llvm/ADT/FoldingSet.h"
+#include "llvm/Value.h"
+#include "clang/AST/Type.h"
+#include "clang/AST/CanonicalType.h"
+
+#include "CGValue.h"
+
+// FIXME: Restructure so we don't have to expose so much stuff.
+#include "ABIInfo.h"
+
+namespace llvm {
+  struct AttributeWithIndex;
+  class Function;
+  class Type;
+  class Value;
+
+  template<typename T, unsigned> class SmallVector;
+}
+
+namespace clang {
+  class ASTContext;
+  class Decl;
+  class FunctionDecl;
+  class ObjCMethodDecl;
+  class VarDecl;
+
+namespace CodeGen {
+  typedef SmallVector<llvm::AttributeWithIndex, 8> AttributeListType;
+
+  struct CallArg {
+    RValue RV;
+    QualType Ty;
+    bool NeedsCopy;
+    CallArg(RValue rv, QualType ty, bool needscopy)
+    : RV(rv), Ty(ty), NeedsCopy(needscopy)
+    { }
+  };
+
+  /// CallArgList - Type for representing both the value and type of
+  /// arguments in a call.
+  class CallArgList :
+    public SmallVector<CallArg, 16> {
+  public:
+    struct Writeback {
+      /// The original argument.
+      llvm::Value *Address;
+
+      /// The pointee type of the original argument.
+      QualType AddressType;
+
+      /// The temporary alloca.
+      llvm::Value *Temporary;
+    };
+
+    void add(RValue rvalue, QualType type, bool needscopy = false) {
+      push_back(CallArg(rvalue, type, needscopy));
+    }
+
+    void addFrom(const CallArgList &other) {
+      insert(end(), other.begin(), other.end());
+      Writebacks.insert(Writebacks.end(),
+                        other.Writebacks.begin(), other.Writebacks.end());
+    }
+
+    void addWriteback(llvm::Value *address, QualType addressType,
+                      llvm::Value *temporary) {
+      Writeback writeback;
+      writeback.Address = address;
+      writeback.AddressType = addressType;
+      writeback.Temporary = temporary;
+      Writebacks.push_back(writeback);
+    }
+
+    bool hasWritebacks() const { return !Writebacks.empty(); }
+
+    typedef SmallVectorImpl<Writeback>::const_iterator writeback_iterator;
+    writeback_iterator writeback_begin() const { return Writebacks.begin(); }
+    writeback_iterator writeback_end() const { return Writebacks.end(); }
+
+  private:
+    SmallVector<Writeback, 1> Writebacks;
+  };
+
+  /// A class for recording the number of arguments that a function
+  /// signature requires.
+  class RequiredArgs {
+    /// The number of required arguments, or ~0 if the signature does
+    /// not permit optional arguments.
+    unsigned NumRequired;
+  public:
+    enum All_t { All };
+
+    RequiredArgs(All_t _) : NumRequired(~0U) {}
+    explicit RequiredArgs(unsigned n) : NumRequired(n) {
+      assert(n != ~0U);
+    }
+
+    /// Compute the arguments required by the given formal prototype,
+    /// given that there may be some additional, non-formal arguments
+    /// in play.
+    static RequiredArgs forPrototypePlus(const FunctionProtoType *prototype,
+                                         unsigned additional) {
+      if (!prototype->isVariadic()) return All;
+      return RequiredArgs(prototype->getNumArgs() + additional);
+    }
+
+    static RequiredArgs forPrototype(const FunctionProtoType *prototype) {
+      return forPrototypePlus(prototype, 0);
+    }
+
+    static RequiredArgs forPrototype(CanQual<FunctionProtoType> prototype) {
+      return forPrototype(prototype.getTypePtr());
+    }
+
+    static RequiredArgs forPrototypePlus(CanQual<FunctionProtoType> prototype,
+                                         unsigned additional) {
+      return forPrototypePlus(prototype.getTypePtr(), additional);
+    }
+
+    bool allowsOptionalArgs() const { return NumRequired != ~0U; }
+    bool getNumRequiredArgs() const {
+      assert(allowsOptionalArgs());
+      return NumRequired;
+    }
+
+    unsigned getOpaqueData() const { return NumRequired; }
+    static RequiredArgs getFromOpaqueData(unsigned value) {
+      if (value == ~0U) return All;
+      return RequiredArgs(value);
+    }
+  };
+
+  /// FunctionArgList - Type for representing both the decl and type
+  /// of parameters to a function. The decl must be either a
+  /// ParmVarDecl or ImplicitParamDecl.
+  class FunctionArgList : public SmallVector<const VarDecl*, 16> {
+  };
+
+  /// CGFunctionInfo - Class to encapsulate the information about a
+  /// function definition.
+  class CGFunctionInfo : public llvm::FoldingSetNode {
+    struct ArgInfo {
+      CanQualType type;
+      ABIArgInfo info;
+    };
+
+    /// The LLVM::CallingConv to use for this function (as specified by the
+    /// user).
+    unsigned CallingConvention : 8;
+
+    /// The LLVM::CallingConv to actually use for this function, which may
+    /// depend on the ABI.
+    unsigned EffectiveCallingConvention : 8;
+
+    /// The clang::CallingConv that this was originally created with.
+    unsigned ASTCallingConvention : 8;
+
+    /// Whether this function is noreturn.
+    unsigned NoReturn : 1;
+
+    /// Whether this function is returns-retained.
+    unsigned ReturnsRetained : 1;
+
+    /// How many arguments to pass inreg.
+    unsigned HasRegParm : 1;
+    unsigned RegParm : 4;
+
+    RequiredArgs Required;
+
+    unsigned NumArgs;
+    ArgInfo *getArgsBuffer() {
+      return reinterpret_cast<ArgInfo*>(this+1);
+    }
+    const ArgInfo *getArgsBuffer() const {
+      return reinterpret_cast<const ArgInfo*>(this + 1);
+    }
+
+    CGFunctionInfo() : Required(RequiredArgs::All) {}
+
+  public:
+    static CGFunctionInfo *create(unsigned llvmCC,
+                                  const FunctionType::ExtInfo &extInfo,
+                                  CanQualType resultType,
+                                  ArrayRef<CanQualType> argTypes,
+                                  RequiredArgs required);
+
+    typedef const ArgInfo *const_arg_iterator;
+    typedef ArgInfo *arg_iterator;
+
+    const_arg_iterator arg_begin() const { return getArgsBuffer() + 1; }
+    const_arg_iterator arg_end() const { return getArgsBuffer() + 1 + NumArgs; }
+    arg_iterator arg_begin() { return getArgsBuffer() + 1; }
+    arg_iterator arg_end() { return getArgsBuffer() + 1 + NumArgs; }
+
+    unsigned  arg_size() const { return NumArgs; }
+
+    bool isVariadic() const { return Required.allowsOptionalArgs(); }
+    RequiredArgs getRequiredArgs() const { return Required; }
+
+    bool isNoReturn() const { return NoReturn; }
+
+    /// In ARC, whether this function retains its return value.  This
+    /// is not always reliable for call sites.
+    bool isReturnsRetained() const { return ReturnsRetained; }
+
+    /// getASTCallingConvention() - Return the AST-specified calling
+    /// convention.
+    CallingConv getASTCallingConvention() const {
+      return CallingConv(ASTCallingConvention);
+    }
+
+    /// getCallingConvention - Return the user specified calling
+    /// convention, which has been translated into an LLVM CC.
+    unsigned getCallingConvention() const { return CallingConvention; }
+
+    /// getEffectiveCallingConvention - Return the actual calling convention to
+    /// use, which may depend on the ABI.
+    unsigned getEffectiveCallingConvention() const {
+      return EffectiveCallingConvention;
+    }
+    void setEffectiveCallingConvention(unsigned Value) {
+      EffectiveCallingConvention = Value;
+    }
+
+    bool getHasRegParm() const { return HasRegParm; }
+    unsigned getRegParm() const { return RegParm; }
+
+    FunctionType::ExtInfo getExtInfo() const {
+      return FunctionType::ExtInfo(isNoReturn(),
+                                   getHasRegParm(), getRegParm(),
+                                   getASTCallingConvention(),
+                                   isReturnsRetained());
+    }
+
+    CanQualType getReturnType() const { return getArgsBuffer()[0].type; }
+
+    ABIArgInfo &getReturnInfo() { return getArgsBuffer()[0].info; }
+    const ABIArgInfo &getReturnInfo() const { return getArgsBuffer()[0].info; }
+
+    void Profile(llvm::FoldingSetNodeID &ID) {
+      ID.AddInteger(getASTCallingConvention());
+      ID.AddBoolean(NoReturn);
+      ID.AddBoolean(ReturnsRetained);
+      ID.AddBoolean(HasRegParm);
+      ID.AddInteger(RegParm);
+      ID.AddInteger(Required.getOpaqueData());
+      getReturnType().Profile(ID);
+      for (arg_iterator it = arg_begin(), ie = arg_end(); it != ie; ++it)
+        it->type.Profile(ID);
+    }
+    static void Profile(llvm::FoldingSetNodeID &ID,
+                        const FunctionType::ExtInfo &info,
+                        RequiredArgs required,
+                        CanQualType resultType,
+                        ArrayRef<CanQualType> argTypes) {
+      ID.AddInteger(info.getCC());
+      ID.AddBoolean(info.getNoReturn());
+      ID.AddBoolean(info.getProducesResult());
+      ID.AddBoolean(info.getHasRegParm());
+      ID.AddInteger(info.getRegParm());
+      ID.AddInteger(required.getOpaqueData());
+      resultType.Profile(ID);
+      for (ArrayRef<CanQualType>::iterator
+             i = argTypes.begin(), e = argTypes.end(); i != e; ++i) {
+        i->Profile(ID);
+      }
+    }
+  };
+  
+  /// ReturnValueSlot - Contains the address where the return value of a 
+  /// function can be stored, and whether the address is volatile or not.
+  class ReturnValueSlot {
+    llvm::PointerIntPair<llvm::Value *, 1, bool> Value;
+
+  public:
+    ReturnValueSlot() {}
+    ReturnValueSlot(llvm::Value *Value, bool IsVolatile)
+      : Value(Value, IsVolatile) {}
+
+    bool isNull() const { return !getValue(); }
+    
+    bool isVolatile() const { return Value.getInt(); }
+    llvm::Value *getValue() const { return Value.getPointer(); }
+  };
+  
+}  // end namespace CodeGen
+}  // end namespace clang
+
+#endif
Index: tools/clang/include/clang/CodeGen/CGValue.h
===================================================================
--- tools/clang/include/clang/CodeGen/CGValue.h	(revision 0)
+++ tools/clang/include/clang/CodeGen/CGValue.h	(revision 47286)
@@ -0,0 +1,452 @@
+//===-- CGValue.h - LLVM CodeGen wrappers for llvm::Value* ------*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// These classes implement wrappers around llvm::Value in order to
+// fully represent the range of values for C L- and R- values.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef CLANG_CODEGEN_CGVALUE_H
+#define CLANG_CODEGEN_CGVALUE_H
+
+#include "clang/AST/ASTContext.h"
+#include "clang/AST/CharUnits.h"
+#include "clang/AST/Type.h"
+
+namespace llvm {
+  class Constant;
+  class Value;
+}
+
+namespace clang {
+namespace CodeGen {
+  class AggValueSlot;
+  class CGBitFieldInfo;
+
+/// RValue - This trivial value class is used to represent the result of an
+/// expression that is evaluated.  It can be one of three things: either a
+/// simple LLVM SSA value, a pair of SSA values for complex numbers, or the
+/// address of an aggregate value in memory.
+class RValue {
+  enum Flavor { Scalar, Complex, Aggregate };
+
+  // Stores first value and flavor.
+  llvm::PointerIntPair<llvm::Value *, 2, Flavor> V1;
+  // Stores second value and volatility.
+  llvm::PointerIntPair<llvm::Value *, 1, bool> V2;
+
+public:
+  bool isScalar() const { return V1.getInt() == Scalar; }
+  bool isComplex() const { return V1.getInt() == Complex; }
+  bool isAggregate() const { return V1.getInt() == Aggregate; }
+
+  bool isVolatileQualified() const { return V2.getInt(); }
+
+  /// getScalarVal() - Return the Value* of this scalar value.
+  llvm::Value *getScalarVal() const {
+    assert(isScalar() && "Not a scalar!");
+    return V1.getPointer();
+  }
+
+  /// getComplexVal - Return the real/imag components of this complex value.
+  ///
+  std::pair<llvm::Value *, llvm::Value *> getComplexVal() const {
+    return std::make_pair(V1.getPointer(), V2.getPointer());
+  }
+
+  /// getAggregateAddr() - Return the Value* of the address of the aggregate.
+  llvm::Value *getAggregateAddr() const {
+    assert(isAggregate() && "Not an aggregate!");
+    return V1.getPointer();
+  }
+
+  static RValue get(llvm::Value *V) {
+    RValue ER;
+    ER.V1.setPointer(V);
+    ER.V1.setInt(Scalar);
+    ER.V2.setInt(false);
+    return ER;
+  }
+  static RValue getComplex(llvm::Value *V1, llvm::Value *V2) {
+    RValue ER;
+    ER.V1.setPointer(V1);
+    ER.V2.setPointer(V2);
+    ER.V1.setInt(Complex);
+    ER.V2.setInt(false);
+    return ER;
+  }
+  static RValue getComplex(const std::pair<llvm::Value *, llvm::Value *> &C) {
+    return getComplex(C.first, C.second);
+  }
+  // FIXME: Aggregate rvalues need to retain information about whether they are
+  // volatile or not.  Remove default to find all places that probably get this
+  // wrong.
+  static RValue getAggregate(llvm::Value *V, bool Volatile = false) {
+    RValue ER;
+    ER.V1.setPointer(V);
+    ER.V1.setInt(Aggregate);
+    ER.V2.setInt(Volatile);
+    return ER;
+  }
+};
+
+
+/// LValue - This represents an lvalue references.  Because C/C++ allow
+/// bitfields, this is not a simple LLVM pointer, it may be a pointer plus a
+/// bitrange.
+class LValue {
+  enum {
+    Simple,       // This is a normal l-value, use getAddress().
+    VectorElt,    // This is a vector element l-value (V[i]), use getVector*
+    BitField,     // This is a bitfield l-value, use getBitfield*.
+    ExtVectorElt  // This is an extended vector subset, use getExtVectorComp
+  } LVType;
+
+  llvm::Value *V;
+
+  union {
+    // Index into a vector subscript: V[i]
+    llvm::Value *VectorIdx;
+
+    // ExtVector element subset: V.xyx
+    llvm::Constant *VectorElts;
+
+    // BitField start bit and size
+    const CGBitFieldInfo *BitFieldInfo;
+  };
+
+  QualType Type;
+
+  // 'const' is unused here
+  Qualifiers Quals;
+
+  // The alignment to use when accessing this lvalue.  (For vector elements,
+  // this is the alignment of the whole vector.)
+  int64_t Alignment;
+
+  // objective-c's ivar
+  bool Ivar:1;
+  
+  // objective-c's ivar is an array
+  bool ObjIsArray:1;
+
+  // LValue is non-gc'able for any reason, including being a parameter or local
+  // variable.
+  bool NonGC: 1;
+
+  // Lvalue is a global reference of an objective-c object
+  bool GlobalObjCRef : 1;
+  
+  // Lvalue is a thread local reference
+  bool ThreadLocalRef : 1;
+
+  Expr *BaseIvarExp;
+
+  /// TBAAInfo - TBAA information to attach to dereferences of this LValue.
+  llvm::MDNode *TBAAInfo;
+
+private:
+  void Initialize(QualType Type, Qualifiers Quals,
+                  CharUnits Alignment,
+                  llvm::MDNode *TBAAInfo = 0) {
+    this->Type = Type;
+    this->Quals = Quals;
+    this->Alignment = Alignment.getQuantity();
+    assert(this->Alignment == Alignment.getQuantity() &&
+           "Alignment exceeds allowed max!");
+
+    // Initialize Objective-C flags.
+    this->Ivar = this->ObjIsArray = this->NonGC = this->GlobalObjCRef = false;
+    this->ThreadLocalRef = false;
+    this->BaseIvarExp = 0;
+    this->TBAAInfo = TBAAInfo;
+  }
+
+public:
+  bool isSimple() const { return LVType == Simple; }
+  bool isVectorElt() const { return LVType == VectorElt; }
+  bool isBitField() const { return LVType == BitField; }
+  bool isExtVectorElt() const { return LVType == ExtVectorElt; }
+
+  bool isVolatileQualified() const { return Quals.hasVolatile(); }
+  bool isRestrictQualified() const { return Quals.hasRestrict(); }
+  unsigned getVRQualifiers() const {
+    return Quals.getCVRQualifiers() & ~Qualifiers::Const;
+  }
+
+  QualType getType() const { return Type; }
+
+  Qualifiers::ObjCLifetime getObjCLifetime() const {
+    return Quals.getObjCLifetime();
+  }
+
+  bool isObjCIvar() const { return Ivar; }
+  void setObjCIvar(bool Value) { Ivar = Value; }
+
+  bool isObjCArray() const { return ObjIsArray; }
+  void setObjCArray(bool Value) { ObjIsArray = Value; }
+
+  bool isNonGC () const { return NonGC; }
+  void setNonGC(bool Value) { NonGC = Value; }
+
+  bool isGlobalObjCRef() const { return GlobalObjCRef; }
+  void setGlobalObjCRef(bool Value) { GlobalObjCRef = Value; }
+
+  bool isThreadLocalRef() const { return ThreadLocalRef; }
+  void setThreadLocalRef(bool Value) { ThreadLocalRef = Value;}
+
+  bool isObjCWeak() const {
+    return Quals.getObjCGCAttr() == Qualifiers::Weak;
+  }
+  bool isObjCStrong() const {
+    return Quals.getObjCGCAttr() == Qualifiers::Strong;
+  }
+
+  bool isVolatile() const {
+    return Quals.hasVolatile();
+  }
+  
+  Expr *getBaseIvarExp() const { return BaseIvarExp; }
+  void setBaseIvarExp(Expr *V) { BaseIvarExp = V; }
+
+  llvm::MDNode *getTBAAInfo() const { return TBAAInfo; }
+  void setTBAAInfo(llvm::MDNode *N) { TBAAInfo = N; }
+
+  const Qualifiers &getQuals() const { return Quals; }
+  Qualifiers &getQuals() { return Quals; }
+
+  unsigned getAddressSpace() const { return Quals.getAddressSpace(); }
+
+  CharUnits getAlignment() const { return CharUnits::fromQuantity(Alignment); }
+  void setAlignment(CharUnits A) { Alignment = A.getQuantity(); }
+
+  // simple lvalue
+  llvm::Value *getAddress() const { assert(isSimple()); return V; }
+  void setAddress(llvm::Value *address) {
+    assert(isSimple());
+    V = address;
+  }
+
+  // vector elt lvalue
+  llvm::Value *getVectorAddr() const { assert(isVectorElt()); return V; }
+  llvm::Value *getVectorIdx() const { assert(isVectorElt()); return VectorIdx; }
+
+  // extended vector elements.
+  llvm::Value *getExtVectorAddr() const { assert(isExtVectorElt()); return V; }
+  llvm::Constant *getExtVectorElts() const {
+    assert(isExtVectorElt());
+    return VectorElts;
+  }
+
+  // bitfield lvalue
+  llvm::Value *getBitFieldBaseAddr() const {
+    assert(isBitField());
+    return V;
+  }
+  const CGBitFieldInfo &getBitFieldInfo() const {
+    assert(isBitField());
+    return *BitFieldInfo;
+  }
+
+  static LValue MakeAddr(llvm::Value *address, QualType type,
+                         CharUnits alignment, ASTContext &Context,
+                         llvm::MDNode *TBAAInfo = 0) {
+    Qualifiers qs = type.getQualifiers();
+    qs.setObjCGCAttr(Context.getObjCGCAttrKind(type));
+
+    LValue R;
+    R.LVType = Simple;
+    R.V = address;
+    R.Initialize(type, qs, alignment, TBAAInfo);
+    return R;
+  }
+
+  static LValue MakeVectorElt(llvm::Value *Vec, llvm::Value *Idx,
+                              QualType type, CharUnits Alignment) {
+    LValue R;
+    R.LVType = VectorElt;
+    R.V = Vec;
+    R.VectorIdx = Idx;
+    R.Initialize(type, type.getQualifiers(), Alignment);
+    return R;
+  }
+
+  static LValue MakeExtVectorElt(llvm::Value *Vec, llvm::Constant *Elts,
+                                 QualType type, CharUnits Alignment) {
+    LValue R;
+    R.LVType = ExtVectorElt;
+    R.V = Vec;
+    R.VectorElts = Elts;
+    R.Initialize(type, type.getQualifiers(), Alignment);
+    return R;
+  }
+
+  /// \brief Create a new object to represent a bit-field access.
+  ///
+  /// \param BaseValue - The base address of the structure containing the
+  /// bit-field.
+  /// \param Info - The information describing how to perform the bit-field
+  /// access.
+  static LValue MakeBitfield(llvm::Value *BaseValue,
+                             const CGBitFieldInfo &Info,
+                             QualType type, CharUnits Alignment) {
+    LValue R;
+    R.LVType = BitField;
+    R.V = BaseValue;
+    R.BitFieldInfo = &Info;
+    R.Initialize(type, type.getQualifiers(), Alignment);
+    return R;
+  }
+
+  RValue asAggregateRValue() const {
+    // FIMXE: Alignment
+    return RValue::getAggregate(getAddress(), isVolatileQualified());
+  }
+};
+
+/// An aggregate value slot.
+class AggValueSlot {
+  /// The address.
+  llvm::Value *Addr;
+
+  // Qualifiers
+  Qualifiers Quals;
+
+  unsigned short Alignment;
+
+  /// DestructedFlag - This is set to true if some external code is
+  /// responsible for setting up a destructor for the slot.  Otherwise
+  /// the code which constructs it should push the appropriate cleanup.
+  bool DestructedFlag : 1;
+
+  /// ObjCGCFlag - This is set to true if writing to the memory in the
+  /// slot might require calling an appropriate Objective-C GC
+  /// barrier.  The exact interaction here is unnecessarily mysterious.
+  bool ObjCGCFlag : 1;
+  
+  /// ZeroedFlag - This is set to true if the memory in the slot is
+  /// known to be zero before the assignment into it.  This means that
+  /// zero fields don't need to be set.
+  bool ZeroedFlag : 1;
+
+  /// AliasedFlag - This is set to true if the slot might be aliased
+  /// and it's not undefined behavior to access it through such an
+  /// alias.  Note that it's always undefined behavior to access a C++
+  /// object that's under construction through an alias derived from
+  /// outside the construction process.
+  ///
+  /// This flag controls whether calls that produce the aggregate
+  /// value may be evaluated directly into the slot, or whether they
+  /// must be evaluated into an unaliased temporary and then memcpy'ed
+  /// over.  Since it's invalid in general to memcpy a non-POD C++
+  /// object, it's important that this flag never be set when
+  /// evaluating an expression which constructs such an object.
+  bool AliasedFlag : 1;
+
+public:
+  enum IsAliased_t { IsNotAliased, IsAliased };
+  enum IsDestructed_t { IsNotDestructed, IsDestructed };
+  enum IsZeroed_t { IsNotZeroed, IsZeroed };
+  enum NeedsGCBarriers_t { DoesNotNeedGCBarriers, NeedsGCBarriers };
+
+  /// ignored - Returns an aggregate value slot indicating that the
+  /// aggregate value is being ignored.
+  static AggValueSlot ignored() {
+    return forAddr(0, CharUnits(), Qualifiers(), IsNotDestructed,
+                   DoesNotNeedGCBarriers, IsNotAliased);
+  }
+
+  /// forAddr - Make a slot for an aggregate value.
+  ///
+  /// \param quals - The qualifiers that dictate how the slot should
+  /// be initialied. Only 'volatile' and the Objective-C lifetime
+  /// qualifiers matter.
+  ///
+  /// \param isDestructed - true if something else is responsible
+  ///   for calling destructors on this object
+  /// \param needsGC - true if the slot is potentially located
+  ///   somewhere that ObjC GC calls should be emitted for
+  static AggValueSlot forAddr(llvm::Value *addr, CharUnits align,
+                              Qualifiers quals,
+                              IsDestructed_t isDestructed,
+                              NeedsGCBarriers_t needsGC,
+                              IsAliased_t isAliased,
+                              IsZeroed_t isZeroed = IsNotZeroed) {
+    AggValueSlot AV;
+    AV.Addr = addr;
+    AV.Alignment = align.getQuantity();
+    AV.Quals = quals;
+    AV.DestructedFlag = isDestructed;
+    AV.ObjCGCFlag = needsGC;
+    AV.ZeroedFlag = isZeroed;
+    AV.AliasedFlag = isAliased;
+    return AV;
+  }
+
+  static AggValueSlot forLValue(const LValue &LV,
+                                IsDestructed_t isDestructed,
+                                NeedsGCBarriers_t needsGC,
+                                IsAliased_t isAliased,
+                                IsZeroed_t isZeroed = IsNotZeroed) {
+    return forAddr(LV.getAddress(), LV.getAlignment(),
+                   LV.getQuals(), isDestructed, needsGC, isAliased, isZeroed);
+  }
+
+  IsDestructed_t isExternallyDestructed() const {
+    return IsDestructed_t(DestructedFlag);
+  }
+  void setExternallyDestructed(bool destructed = true) {
+    DestructedFlag = destructed;
+  }
+
+  Qualifiers getQualifiers() const { return Quals; }
+
+  bool isVolatile() const {
+    return Quals.hasVolatile();
+  }
+
+  Qualifiers::ObjCLifetime getObjCLifetime() const {
+    return Quals.getObjCLifetime();
+  }
+
+  NeedsGCBarriers_t requiresGCollection() const {
+    return NeedsGCBarriers_t(ObjCGCFlag);
+  }
+  
+  llvm::Value *getAddr() const {
+    return Addr;
+  }
+
+  bool isIgnored() const {
+    return Addr == 0;
+  }
+
+  CharUnits getAlignment() const {
+    return CharUnits::fromQuantity(Alignment);
+  }
+
+  IsAliased_t isPotentiallyAliased() const {
+    return IsAliased_t(AliasedFlag);
+  }
+
+  // FIXME: Alignment?
+  RValue asRValue() const {
+    return RValue::getAggregate(getAddr(), isVolatile());
+  }
+
+  void setZeroed(bool V = true) { ZeroedFlag = V; }
+  IsZeroed_t isZeroed() const {
+    return IsZeroed_t(ZeroedFlag);
+  }
+};
+
+}  // end namespace CodeGen
+}  // end namespace clang
+
+#endif
Index: tools/clang/include/clang/CodeGen/ABIInfo.h
===================================================================
--- tools/clang/include/clang/CodeGen/ABIInfo.h	(revision 0)
+++ tools/clang/include/clang/CodeGen/ABIInfo.h	(revision 47286)
@@ -0,0 +1,197 @@
+//===----- ABIInfo.h - ABI information access & encapsulation ---*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef CLANG_CODEGEN_ABIINFO_H
+#define CLANG_CODEGEN_ABIINFO_H
+
+#include "clang/AST/Type.h"
+#include "llvm/Type.h"
+
+namespace llvm {
+  class Value;
+  class LLVMContext;
+  class TargetData;
+}
+
+namespace clang {
+  class ASTContext;
+
+  namespace CodeGen {
+    class CGFunctionInfo;
+    class CodeGenFunction;
+    class CodeGenTypes;
+  }
+
+  // FIXME: All of this stuff should be part of the target interface
+  // somehow. It is currently here because it is not clear how to factor
+  // the targets to support this, since the Targets currently live in a
+  // layer below types n'stuff.
+
+  /// ABIArgInfo - Helper class to encapsulate information about how a
+  /// specific C type should be passed to or returned from a function.
+  class ABIArgInfo {
+  public:
+    enum Kind {
+      /// Direct - Pass the argument directly using the normal converted LLVM
+      /// type, or by coercing to another specified type stored in
+      /// 'CoerceToType').  If an offset is specified (in UIntData), then the
+      /// argument passed is offset by some number of bytes in the memory
+      /// representation. A dummy argument is emitted before the real argument
+      /// if the specified type stored in "PaddingType" is not zero.
+      Direct,
+
+      /// Extend - Valid only for integer argument types. Same as 'direct'
+      /// but also emit a zero/sign extension attribute.
+      Extend,
+
+      /// Indirect - Pass the argument indirectly via a hidden pointer
+      /// with the specified alignment (0 indicates default alignment).
+      Indirect,
+
+      /// Ignore - Ignore the argument (treat as void). Useful for void and
+      /// empty structs.
+      Ignore,
+
+      /// Expand - Only valid for aggregate argument types. The structure should
+      /// be expanded into consecutive arguments for its constituent fields.
+      /// Currently expand is only allowed on structures whose fields
+      /// are all scalar types or are themselves expandable types.
+      Expand,
+
+      KindFirst=Direct, KindLast=Expand
+    };
+
+  private:
+    Kind TheKind;
+    llvm::Type *TypeData;
+    llvm::Type *PaddingType; // Currently allowed only for Direct.
+    unsigned UIntData;
+    bool BoolData0;
+    bool BoolData1;
+    bool InReg;
+
+    ABIArgInfo(Kind K, llvm::Type *TD, unsigned UI, bool B0, bool B1, bool IR,
+               llvm::Type* P)
+      : TheKind(K), TypeData(TD), PaddingType(P), UIntData(UI), BoolData0(B0),
+        BoolData1(B1), InReg(IR) {}
+
+  public:
+    ABIArgInfo() : TheKind(Direct), TypeData(0), UIntData(0) {}
+
+    static ABIArgInfo getDirect(llvm::Type *T = 0, unsigned Offset = 0,
+                                llvm::Type *Padding = 0) {
+      return ABIArgInfo(Direct, T, Offset, false, false, false, Padding);
+    }
+    static ABIArgInfo getDirectInReg(llvm::Type *T) {
+      return ABIArgInfo(Direct, T, 0, false, false, true, 0);
+    }
+    static ABIArgInfo getExtend(llvm::Type *T = 0) {
+      return ABIArgInfo(Extend, T, 0, false, false, false, 0);
+    }
+    static ABIArgInfo getExtendInReg(llvm::Type *T = 0) {
+      return ABIArgInfo(Extend, T, 0, false, false, true, 0);
+    }
+    static ABIArgInfo getIgnore() {
+      return ABIArgInfo(Ignore, 0, 0, false, false, false, 0);
+    }
+    static ABIArgInfo getIndirect(unsigned Alignment, bool ByVal = true
+                                  , bool Realign = false) {
+      return ABIArgInfo(Indirect, 0, Alignment, ByVal, Realign, false, 0);
+    }
+    static ABIArgInfo getIndirectInReg(unsigned Alignment, bool ByVal = true
+                                  , bool Realign = false) {
+      return ABIArgInfo(Indirect, 0, Alignment, ByVal, Realign, true, 0);
+    }
+    static ABIArgInfo getExpand() {
+      return ABIArgInfo(Expand, 0, 0, false, false, false, 0);
+    }
+
+    Kind getKind() const { return TheKind; }
+    bool isDirect() const { return TheKind == Direct; }
+    bool isExtend() const { return TheKind == Extend; }
+    bool isIgnore() const { return TheKind == Ignore; }
+    bool isIndirect() const { return TheKind == Indirect; }
+    bool isExpand() const { return TheKind == Expand; }
+
+    bool canHaveCoerceToType() const {
+      return TheKind == Direct || TheKind == Extend;
+    }
+
+    // Direct/Extend accessors
+    unsigned getDirectOffset() const {
+      assert((isDirect() || isExtend()) && "Not a direct or extend kind");
+      return UIntData;
+    }
+
+    llvm::Type *getPaddingType() const {
+      return PaddingType;
+    }
+
+    llvm::Type *getCoerceToType() const {
+      assert(canHaveCoerceToType() && "Invalid kind!");
+      return TypeData;
+    }
+
+    void setCoerceToType(llvm::Type *T) {
+      assert(canHaveCoerceToType() && "Invalid kind!");
+      TypeData = T;
+    }
+
+    bool getInReg() const {
+      assert((isDirect() || isExtend() || isIndirect()) && "Invalid kind!");
+      return InReg;
+    }
+
+    // Indirect accessors
+    unsigned getIndirectAlign() const {
+      assert(TheKind == Indirect && "Invalid kind!");
+      return UIntData;
+    }
+
+    bool getIndirectByVal() const {
+      assert(TheKind == Indirect && "Invalid kind!");
+      return BoolData0;
+    }
+
+    bool getIndirectRealign() const {
+      assert(TheKind == Indirect && "Invalid kind!");
+      return BoolData1;
+    }
+
+    void dump() const;
+  };
+
+  /// ABIInfo - Target specific hooks for defining how a type should be
+  /// passed or returned from functions.
+  class ABIInfo {
+  public:
+    CodeGen::CodeGenTypes &CGT;
+
+    ABIInfo(CodeGen::CodeGenTypes &cgt) : CGT(cgt) {}
+    virtual ~ABIInfo();
+
+    ASTContext &getContext() const;
+    llvm::LLVMContext &getVMContext() const;
+    const llvm::TargetData &getTargetData() const;
+
+    virtual void computeInfo(CodeGen::CGFunctionInfo &FI) const = 0;
+
+    /// EmitVAArg - Emit the target dependent code to load a value of
+    /// \arg Ty from the va_list pointed to by \arg VAListAddr.
+
+    // FIXME: This is a gaping layering violation if we wanted to drop
+    // the ABI information any lower than CodeGen. Of course, for
+    // VAArg handling it has to be at this level; there is no way to
+    // abstract this out.
+    virtual llvm::Value *EmitVAArg(llvm::Value *VAListAddr, QualType Ty,
+                                   CodeGen::CodeGenFunction &CGF) const = 0;
+  };
+}  // end namespace clang
+
+#endif
Index: tools/clang/lib/CodeGen/CodeGenTypes.h
===================================================================
--- tools/clang/lib/CodeGen/CodeGenTypes.h	(revision 47284)
+++ tools/clang/lib/CodeGen/CodeGenTypes.h	(revision 47286)
@@ -1,260 +0,0 @@
-//===--- CodeGenTypes.h - Type translation for LLVM CodeGen -----*- C++ -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This is the code that handles AST -> LLVM type lowering.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef CLANG_CODEGEN_CODEGENTYPES_H
-#define CLANG_CODEGEN_CODEGENTYPES_H
-
-#include "CGCall.h"
-#include "clang/AST/GlobalDecl.h"
-#include "llvm/Module.h"
-#include "llvm/ADT/DenseMap.h"
-#include <vector>
-
-namespace llvm {
-  class FunctionType;
-  class Module;
-  class TargetData;
-  class Type;
-  class LLVMContext;
-  class StructType;
-}
-
-namespace clang {
-  class ABIInfo;
-  class ASTContext;
-  template <typename> class CanQual;
-  class CXXConstructorDecl;
-  class CXXDestructorDecl;
-  class CXXMethodDecl;
-  class CodeGenOptions;
-  class FieldDecl;
-  class FunctionProtoType;
-  class ObjCInterfaceDecl;
-  class ObjCIvarDecl;
-  class PointerType;
-  class QualType;
-  class RecordDecl;
-  class TagDecl;
-  class TargetInfo;
-  class Type;
-  typedef CanQual<Type> CanQualType;
-
-namespace CodeGen {
-  class CGCXXABI;
-  class CGRecordLayout;
-  class CodeGenModule;
-  class RequiredArgs;
-
-/// CodeGenTypes - This class organizes the cross-module state that is used
-/// while lowering AST types to LLVM types.
-class CodeGenTypes {
-  // Some of this stuff should probably be left on the CGM.
-  ASTContext &Context;
-  const TargetInfo &Target;
-  llvm::Module &TheModule;
-  const llvm::TargetData &TheTargetData;
-  const ABIInfo &TheABIInfo;
-  CGCXXABI &TheCXXABI;
-  const CodeGenOptions &CodeGenOpts;
-  CodeGenModule &CGM;
-
-  /// The opaque type map for Objective-C interfaces. All direct
-  /// manipulation is done by the runtime interfaces, which are
-  /// responsible for coercing to the appropriate type; these opaque
-  /// types are never refined.
-  llvm::DenseMap<const ObjCInterfaceType*, llvm::Type *> InterfaceTypes;
-
-  /// CGRecordLayouts - This maps llvm struct type with corresponding
-  /// record layout info.
-  llvm::DenseMap<const Type*, CGRecordLayout *> CGRecordLayouts;
-
-  /// RecordDeclTypes - This contains the LLVM IR type for any converted
-  /// RecordDecl.
-  llvm::DenseMap<const Type*, llvm::StructType *> RecordDeclTypes;
-  
-  /// FunctionInfos - Hold memoized CGFunctionInfo results.
-  llvm::FoldingSet<CGFunctionInfo> FunctionInfos;
-
-  /// RecordsBeingLaidOut - This set keeps track of records that we're currently
-  /// converting to an IR type.  For example, when converting:
-  /// struct A { struct B { int x; } } when processing 'x', the 'A' and 'B'
-  /// types will be in this set.
-  llvm::SmallPtrSet<const Type*, 4> RecordsBeingLaidOut;
-  
-  llvm::SmallPtrSet<const CGFunctionInfo*, 4> FunctionsBeingProcessed;
-  
-  /// SkippedLayout - True if we didn't layout a function due to a being inside
-  /// a recursive struct conversion, set this to true.
-  bool SkippedLayout;
-
-  SmallVector<const RecordDecl *, 8> DeferredRecords;
-  
-private:
-  /// TypeCache - This map keeps cache of llvm::Types
-  /// and maps llvm::Types to corresponding clang::Type.
-  llvm::DenseMap<const Type *, llvm::Type *> TypeCache;
-
-public:
-  CodeGenTypes(CodeGenModule &CGM);
-  ~CodeGenTypes();
-
-  const llvm::TargetData &getTargetData() const { return TheTargetData; }
-  const TargetInfo &getTarget() const { return Target; }
-  ASTContext &getContext() const { return Context; }
-  const ABIInfo &getABIInfo() const { return TheABIInfo; }
-  const CodeGenOptions &getCodeGenOpts() const { return CodeGenOpts; }
-  CGCXXABI &getCXXABI() const { return TheCXXABI; }
-  llvm::LLVMContext &getLLVMContext() { return TheModule.getContext(); }
-
-  /// ConvertType - Convert type T into a llvm::Type.
-  llvm::Type *ConvertType(QualType T);
-
-  /// ConvertTypeForMem - Convert type T into a llvm::Type.  This differs from
-  /// ConvertType in that it is used to convert to the memory representation for
-  /// a type.  For example, the scalar representation for _Bool is i1, but the
-  /// memory representation is usually i8 or i32, depending on the target.
-  llvm::Type *ConvertTypeForMem(QualType T);
-
-  /// GetFunctionType - Get the LLVM function type for \arg Info.
-  llvm::FunctionType *GetFunctionType(const CGFunctionInfo &Info);
-
-  llvm::FunctionType *GetFunctionType(GlobalDecl GD);
-
-  /// isFuncTypeConvertible - Utility to check whether a function type can
-  /// be converted to an LLVM type (i.e. doesn't depend on an incomplete tag
-  /// type).
-  bool isFuncTypeConvertible(const FunctionType *FT);
-  bool isFuncTypeArgumentConvertible(QualType Ty);
-  
-  /// GetFunctionTypeForVTable - Get the LLVM function type for use in a vtable,
-  /// given a CXXMethodDecl. If the method to has an incomplete return type,
-  /// and/or incomplete argument types, this will return the opaque type.
-  llvm::Type *GetFunctionTypeForVTable(GlobalDecl GD);
-
-  const CGRecordLayout &getCGRecordLayout(const RecordDecl*);
-
-  /// UpdateCompletedType - When we find the full definition for a TagDecl,
-  /// replace the 'opaque' type we previously made for it if applicable.
-  void UpdateCompletedType(const TagDecl *TD);
-
-  /// getNullaryFunctionInfo - Get the function info for a void()
-  /// function with standard CC.
-  const CGFunctionInfo &arrangeNullaryFunction();
-
-  // The arrangement methods are split into three families:
-  //   - those meant to drive the signature and prologue/epilogue
-  //     of a function declaration or definition,
-  //   - those meant for the computation of the LLVM type for an abstract
-  //     appearance of a function, and
-  //   - those meant for performing the IR-generation of a call.
-  // They differ mainly in how they deal with optional (i.e. variadic)
-  // arguments, as well as unprototyped functions.
-  //
-  // Key points:
-  // - The CGFunctionInfo for emitting a specific call site must include
-  //   entries for the optional arguments.
-  // - The function type used at the call site must reflect the formal
-  //   signature of the declaration being called, or else the call will
-  //   go awry.
-  // - For the most part, unprototyped functions are called by casting to
-  //   a formal signature inferred from the specific argument types used
-  //   at the call-site.  However, some targets (e.g. x86-64) screw with
-  //   this for compatibility reasons.
-
-  const CGFunctionInfo &arrangeGlobalDeclaration(GlobalDecl GD);
-  const CGFunctionInfo &arrangeFunctionDeclaration(const FunctionDecl *FD);
-  const CGFunctionInfo &arrangeFunctionDeclaration(QualType ResTy,
-                                                   const FunctionArgList &Args,
-                                             const FunctionType::ExtInfo &Info,
-                                                   bool isVariadic);
-
-  const CGFunctionInfo &arrangeObjCMethodDeclaration(const ObjCMethodDecl *MD);
-  const CGFunctionInfo &arrangeObjCMessageSendSignature(const ObjCMethodDecl *MD,
-                                                        QualType receiverType);
-
-  const CGFunctionInfo &arrangeCXXMethodDeclaration(const CXXMethodDecl *MD);
-  const CGFunctionInfo &arrangeCXXConstructorDeclaration(
-                                                    const CXXConstructorDecl *D,
-                                                    CXXCtorType Type);
-  const CGFunctionInfo &arrangeCXXDestructor(const CXXDestructorDecl *D,
-                                             CXXDtorType Type);
-
-  const CGFunctionInfo &arrangeFreeFunctionCall(const CallArgList &Args,
-                                                const FunctionType *Ty);
-  const CGFunctionInfo &arrangeFreeFunctionCall(QualType ResTy,
-                                                const CallArgList &args,
-                                                FunctionType::ExtInfo info,
-                                                RequiredArgs required);
-
-  const CGFunctionInfo &arrangeCXXMethodCall(const CallArgList &args,
-                                             const FunctionProtoType *type,
-                                             RequiredArgs required);
-
-  const CGFunctionInfo &arrangeFreeFunctionType(CanQual<FunctionProtoType> Ty);
-  const CGFunctionInfo &arrangeFreeFunctionType(CanQual<FunctionNoProtoType> Ty);
-  const CGFunctionInfo &arrangeCXXMethodType(const CXXRecordDecl *RD,
-                                             const FunctionProtoType *FTP);
-
-  /// "Arrange" the LLVM information for a call or type with the given
-  /// signature.  This is largely an internal method; other clients
-  /// should use one of the above routines, which ultimately defer to
-  /// this.
-  ///
-  /// \param argTypes - must all actually be canonical as params
-  const CGFunctionInfo &arrangeLLVMFunctionInfo(CanQualType returnType,
-                                                ArrayRef<CanQualType> argTypes,
-                                                FunctionType::ExtInfo info,
-                                                RequiredArgs args);
-
-  /// \brief Compute a new LLVM record layout object for the given record.
-  CGRecordLayout *ComputeRecordLayout(const RecordDecl *D,
-                                      llvm::StructType *Ty);
-
-  /// addRecordTypeName - Compute a name from the given record decl with an
-  /// optional suffix and name the given LLVM type using it.
-  void addRecordTypeName(const RecordDecl *RD, llvm::StructType *Ty,
-                         StringRef suffix);
-  
-
-public:  // These are internal details of CGT that shouldn't be used externally.
-  /// ConvertRecordDeclType - Lay out a tagged decl type like struct or union.
-  llvm::StructType *ConvertRecordDeclType(const RecordDecl *TD);
-
-  /// GetExpandedTypes - Expand the type \arg Ty into the LLVM
-  /// argument types it would be passed as on the provided vector \arg
-  /// ArgTys. See ABIArgInfo::Expand.
-  void GetExpandedTypes(QualType type,
-                        SmallVectorImpl<llvm::Type*> &expanded);
-
-  /// IsZeroInitializable - Return whether a type can be
-  /// zero-initialized (in the C++ sense) with an LLVM zeroinitializer.
-  bool isZeroInitializable(QualType T);
-
-  /// IsZeroInitializable - Return whether a record type can be
-  /// zero-initialized (in the C++ sense) with an LLVM zeroinitializer.
-  bool isZeroInitializable(const CXXRecordDecl *RD);
-  
-  bool isRecordLayoutComplete(const Type *Ty) const;
-  bool noRecordsBeingLaidOut() const {
-    return RecordsBeingLaidOut.empty();
-  }
-  bool isRecordBeingLaidOut(const Type *Ty) const {
-    return RecordsBeingLaidOut.count(Ty);
-  }
-                            
-};
-
-}  // end namespace CodeGen
-}  // end namespace clang
-
-#endif
Index: tools/clang/lib/CodeGen/ABIInfo.h
===================================================================
--- tools/clang/lib/CodeGen/ABIInfo.h	(revision 47284)
+++ tools/clang/lib/CodeGen/ABIInfo.h	(revision 47286)
@@ -1,197 +0,0 @@
-//===----- ABIInfo.h - ABI information access & encapsulation ---*- C++ -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef CLANG_CODEGEN_ABIINFO_H
-#define CLANG_CODEGEN_ABIINFO_H
-
-#include "clang/AST/Type.h"
-#include "llvm/Type.h"
-
-namespace llvm {
-  class Value;
-  class LLVMContext;
-  class TargetData;
-}
-
-namespace clang {
-  class ASTContext;
-
-  namespace CodeGen {
-    class CGFunctionInfo;
-    class CodeGenFunction;
-    class CodeGenTypes;
-  }
-
-  // FIXME: All of this stuff should be part of the target interface
-  // somehow. It is currently here because it is not clear how to factor
-  // the targets to support this, since the Targets currently live in a
-  // layer below types n'stuff.
-
-  /// ABIArgInfo - Helper class to encapsulate information about how a
-  /// specific C type should be passed to or returned from a function.
-  class ABIArgInfo {
-  public:
-    enum Kind {
-      /// Direct - Pass the argument directly using the normal converted LLVM
-      /// type, or by coercing to another specified type stored in
-      /// 'CoerceToType').  If an offset is specified (in UIntData), then the
-      /// argument passed is offset by some number of bytes in the memory
-      /// representation. A dummy argument is emitted before the real argument
-      /// if the specified type stored in "PaddingType" is not zero.
-      Direct,
-
-      /// Extend - Valid only for integer argument types. Same as 'direct'
-      /// but also emit a zero/sign extension attribute.
-      Extend,
-
-      /// Indirect - Pass the argument indirectly via a hidden pointer
-      /// with the specified alignment (0 indicates default alignment).
-      Indirect,
-
-      /// Ignore - Ignore the argument (treat as void). Useful for void and
-      /// empty structs.
-      Ignore,
-
-      /// Expand - Only valid for aggregate argument types. The structure should
-      /// be expanded into consecutive arguments for its constituent fields.
-      /// Currently expand is only allowed on structures whose fields
-      /// are all scalar types or are themselves expandable types.
-      Expand,
-
-      KindFirst=Direct, KindLast=Expand
-    };
-
-  private:
-    Kind TheKind;
-    llvm::Type *TypeData;
-    llvm::Type *PaddingType; // Currently allowed only for Direct.
-    unsigned UIntData;
-    bool BoolData0;
-    bool BoolData1;
-    bool InReg;
-
-    ABIArgInfo(Kind K, llvm::Type *TD, unsigned UI, bool B0, bool B1, bool IR,
-               llvm::Type* P)
-      : TheKind(K), TypeData(TD), PaddingType(P), UIntData(UI), BoolData0(B0),
-        BoolData1(B1), InReg(IR) {}
-
-  public:
-    ABIArgInfo() : TheKind(Direct), TypeData(0), UIntData(0) {}
-
-    static ABIArgInfo getDirect(llvm::Type *T = 0, unsigned Offset = 0,
-                                llvm::Type *Padding = 0) {
-      return ABIArgInfo(Direct, T, Offset, false, false, false, Padding);
-    }
-    static ABIArgInfo getDirectInReg(llvm::Type *T) {
-      return ABIArgInfo(Direct, T, 0, false, false, true, 0);
-    }
-    static ABIArgInfo getExtend(llvm::Type *T = 0) {
-      return ABIArgInfo(Extend, T, 0, false, false, false, 0);
-    }
-    static ABIArgInfo getExtendInReg(llvm::Type *T = 0) {
-      return ABIArgInfo(Extend, T, 0, false, false, true, 0);
-    }
-    static ABIArgInfo getIgnore() {
-      return ABIArgInfo(Ignore, 0, 0, false, false, false, 0);
-    }
-    static ABIArgInfo getIndirect(unsigned Alignment, bool ByVal = true
-                                  , bool Realign = false) {
-      return ABIArgInfo(Indirect, 0, Alignment, ByVal, Realign, false, 0);
-    }
-    static ABIArgInfo getIndirectInReg(unsigned Alignment, bool ByVal = true
-                                  , bool Realign = false) {
-      return ABIArgInfo(Indirect, 0, Alignment, ByVal, Realign, true, 0);
-    }
-    static ABIArgInfo getExpand() {
-      return ABIArgInfo(Expand, 0, 0, false, false, false, 0);
-    }
-
-    Kind getKind() const { return TheKind; }
-    bool isDirect() const { return TheKind == Direct; }
-    bool isExtend() const { return TheKind == Extend; }
-    bool isIgnore() const { return TheKind == Ignore; }
-    bool isIndirect() const { return TheKind == Indirect; }
-    bool isExpand() const { return TheKind == Expand; }
-
-    bool canHaveCoerceToType() const {
-      return TheKind == Direct || TheKind == Extend;
-    }
-
-    // Direct/Extend accessors
-    unsigned getDirectOffset() const {
-      assert((isDirect() || isExtend()) && "Not a direct or extend kind");
-      return UIntData;
-    }
-
-    llvm::Type *getPaddingType() const {
-      return PaddingType;
-    }
-
-    llvm::Type *getCoerceToType() const {
-      assert(canHaveCoerceToType() && "Invalid kind!");
-      return TypeData;
-    }
-
-    void setCoerceToType(llvm::Type *T) {
-      assert(canHaveCoerceToType() && "Invalid kind!");
-      TypeData = T;
-    }
-
-    bool getInReg() const {
-      assert((isDirect() || isExtend() || isIndirect()) && "Invalid kind!");
-      return InReg;
-    }
-
-    // Indirect accessors
-    unsigned getIndirectAlign() const {
-      assert(TheKind == Indirect && "Invalid kind!");
-      return UIntData;
-    }
-
-    bool getIndirectByVal() const {
-      assert(TheKind == Indirect && "Invalid kind!");
-      return BoolData0;
-    }
-
-    bool getIndirectRealign() const {
-      assert(TheKind == Indirect && "Invalid kind!");
-      return BoolData1;
-    }
-
-    void dump() const;
-  };
-
-  /// ABIInfo - Target specific hooks for defining how a type should be
-  /// passed or returned from functions.
-  class ABIInfo {
-  public:
-    CodeGen::CodeGenTypes &CGT;
-
-    ABIInfo(CodeGen::CodeGenTypes &cgt) : CGT(cgt) {}
-    virtual ~ABIInfo();
-
-    ASTContext &getContext() const;
-    llvm::LLVMContext &getVMContext() const;
-    const llvm::TargetData &getTargetData() const;
-
-    virtual void computeInfo(CodeGen::CGFunctionInfo &FI) const = 0;
-
-    /// EmitVAArg - Emit the target dependent code to load a value of
-    /// \arg Ty from the va_list pointed to by \arg VAListAddr.
-
-    // FIXME: This is a gaping layering violation if we wanted to drop
-    // the ABI information any lower than CodeGen. Of course, for
-    // VAArg handling it has to be at this level; there is no way to
-    // abstract this out.
-    virtual llvm::Value *EmitVAArg(llvm::Value *VAListAddr, QualType Ty,
-                                   CodeGen::CodeGenFunction &CGF) const = 0;
-  };
-}  // end namespace clang
-
-#endif
Index: tools/clang/lib/CodeGen/CodeGenModule.h
===================================================================
--- tools/clang/lib/CodeGen/CodeGenModule.h	(revision 47284)
+++ tools/clang/lib/CodeGen/CodeGenModule.h	(revision 47286)
@@ -1,1000 +0,0 @@
-//===--- CodeGenModule.h - Per-Module state for LLVM CodeGen ----*- C++ -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This is the internal per-translation-unit state used for llvm translation.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef CLANG_CODEGEN_CODEGENMODULE_H
-#define CLANG_CODEGEN_CODEGENMODULE_H
-
-#include "clang/Basic/ABI.h"
-#include "clang/Basic/LangOptions.h"
-#include "clang/AST/Attr.h"
-#include "clang/AST/DeclCXX.h"
-#include "clang/AST/DeclObjC.h"
-#include "clang/AST/GlobalDecl.h"
-#include "clang/AST/Mangle.h"
-#include "CGVTables.h"
-#include "CodeGenTypes.h"
-#include "llvm/Module.h"
-#include "llvm/ADT/DenseMap.h"
-#include "llvm/ADT/StringMap.h"
-#include "llvm/ADT/SmallPtrSet.h"
-#include "llvm/Support/ValueHandle.h"
-
-namespace llvm {
-  class Module;
-  class Constant;
-  class ConstantInt;
-  class Function;
-  class GlobalValue;
-  class TargetData;
-  class FunctionType;
-  class LLVMContext;
-}
-
-namespace clang {
-  class TargetCodeGenInfo;
-  class ASTContext;
-  class FunctionDecl;
-  class IdentifierInfo;
-  class ObjCMethodDecl;
-  class ObjCImplementationDecl;
-  class ObjCCategoryImplDecl;
-  class ObjCProtocolDecl;
-  class ObjCEncodeExpr;
-  class BlockExpr;
-  class CharUnits;
-  class Decl;
-  class Expr;
-  class Stmt;
-  class InitListExpr;
-  class StringLiteral;
-  class NamedDecl;
-  class ValueDecl;
-  class VarDecl;
-  class LangOptions;
-  class CodeGenOptions;
-  class DiagnosticsEngine;
-  class AnnotateAttr;
-  class CXXDestructorDecl;
-  class MangleBuffer;
-
-namespace CodeGen {
-
-  class CallArgList;
-  class CodeGenFunction;
-  class CodeGenTBAA;
-  class CGCXXABI;
-  class CGDebugInfo;
-  class CGObjCRuntime;
-  class CGOpenCLRuntime;
-  class CGCUDARuntime;
-  class BlockFieldFlags;
-  class FunctionArgList;
-  
-  struct OrderGlobalInits {
-    unsigned int priority;
-    unsigned int lex_order;
-    OrderGlobalInits(unsigned int p, unsigned int l) 
-      : priority(p), lex_order(l) {}
-    
-    bool operator==(const OrderGlobalInits &RHS) const {
-      return priority == RHS.priority &&
-             lex_order == RHS.lex_order;
-    }
-    
-    bool operator<(const OrderGlobalInits &RHS) const {
-      if (priority < RHS.priority)
-        return true;
-      
-      return priority == RHS.priority && lex_order < RHS.lex_order;
-    }
-  };
-
-  struct CodeGenTypeCache {
-    /// void
-    llvm::Type *VoidTy;
-
-    /// i8, i16, i32, and i64
-    llvm::IntegerType *Int8Ty, *Int16Ty, *Int32Ty, *Int64Ty;
-    /// float, double
-    llvm::Type *FloatTy, *DoubleTy;
-
-    /// int
-    llvm::IntegerType *IntTy;
-
-    /// intptr_t, size_t, and ptrdiff_t, which we assume are the same size.
-    union {
-      llvm::IntegerType *IntPtrTy;
-      llvm::IntegerType *SizeTy;
-      llvm::IntegerType *PtrDiffTy;
-    };
-
-    /// void* in address space 0
-    union {
-      llvm::PointerType *VoidPtrTy;
-      llvm::PointerType *Int8PtrTy;
-    };
-
-    /// void** in address space 0
-    union {
-      llvm::PointerType *VoidPtrPtrTy;
-      llvm::PointerType *Int8PtrPtrTy;
-    };
-
-    /// The width of a pointer into the generic address space.
-    unsigned char PointerWidthInBits;
-
-    /// The size and alignment of a pointer into the generic address
-    /// space.
-    union {
-      unsigned char PointerAlignInBytes;
-      unsigned char PointerSizeInBytes;
-      unsigned char SizeSizeInBytes;     // sizeof(size_t)
-    };
-  };
-
-struct RREntrypoints {
-  RREntrypoints() { memset(this, 0, sizeof(*this)); }
-  /// void objc_autoreleasePoolPop(void*);
-  llvm::Constant *objc_autoreleasePoolPop;
-
-  /// void *objc_autoreleasePoolPush(void);
-  llvm::Constant *objc_autoreleasePoolPush;
-};
-
-struct ARCEntrypoints {
-  ARCEntrypoints() { memset(this, 0, sizeof(*this)); }
-
-  /// id objc_autorelease(id);
-  llvm::Constant *objc_autorelease;
-
-  /// id objc_autoreleaseReturnValue(id);
-  llvm::Constant *objc_autoreleaseReturnValue;
-
-  /// void objc_copyWeak(id *dest, id *src);
-  llvm::Constant *objc_copyWeak;
-
-  /// void objc_destroyWeak(id*);
-  llvm::Constant *objc_destroyWeak;
-
-  /// id objc_initWeak(id*, id);
-  llvm::Constant *objc_initWeak;
-
-  /// id objc_loadWeak(id*);
-  llvm::Constant *objc_loadWeak;
-
-  /// id objc_loadWeakRetained(id*);
-  llvm::Constant *objc_loadWeakRetained;
-
-  /// void objc_moveWeak(id *dest, id *src);
-  llvm::Constant *objc_moveWeak;
-
-  /// id objc_retain(id);
-  llvm::Constant *objc_retain;
-
-  /// id objc_retainAutorelease(id);
-  llvm::Constant *objc_retainAutorelease;
-
-  /// id objc_retainAutoreleaseReturnValue(id);
-  llvm::Constant *objc_retainAutoreleaseReturnValue;
-
-  /// id objc_retainAutoreleasedReturnValue(id);
-  llvm::Constant *objc_retainAutoreleasedReturnValue;
-
-  /// id objc_retainBlock(id);
-  llvm::Constant *objc_retainBlock;
-
-  /// void objc_release(id);
-  llvm::Constant *objc_release;
-
-  /// id objc_storeStrong(id*, id);
-  llvm::Constant *objc_storeStrong;
-
-  /// id objc_storeWeak(id*, id);
-  llvm::Constant *objc_storeWeak;
-
-  /// A void(void) inline asm to use to mark that the return value of
-  /// a call will be immediately retain.
-  llvm::InlineAsm *retainAutoreleasedReturnValueMarker;
-};
-  
-/// CodeGenModule - This class organizes the cross-function state that is used
-/// while generating LLVM code.
-class CodeGenModule : public CodeGenTypeCache {
-  CodeGenModule(const CodeGenModule &) LLVM_DELETED_FUNCTION;
-  void operator=(const CodeGenModule &) LLVM_DELETED_FUNCTION;
-
-  typedef std::vector<std::pair<llvm::Constant*, int> > CtorList;
-
-  ASTContext &Context;
-  const LangOptions &LangOpts;
-  const CodeGenOptions &CodeGenOpts;
-  llvm::Module &TheModule;
-  const llvm::TargetData &TheTargetData;
-  mutable const TargetCodeGenInfo *TheTargetCodeGenInfo;
-  DiagnosticsEngine &Diags;
-  CGCXXABI &ABI;
-  CodeGenTypes Types;
-  CodeGenTBAA *TBAA;
-
-  /// VTables - Holds information about C++ vtables.
-  CodeGenVTables VTables;
-  friend class CodeGenVTables;
-
-  CGObjCRuntime* ObjCRuntime;
-  CGOpenCLRuntime* OpenCLRuntime;
-  CGCUDARuntime* CUDARuntime;
-  CGDebugInfo* DebugInfo;
-  ARCEntrypoints *ARCData;
-  llvm::MDNode *NoObjCARCExceptionsMetadata;
-  RREntrypoints *RRData;
-
-  // WeakRefReferences - A set of references that have only been seen via
-  // a weakref so far. This is used to remove the weak of the reference if we ever
-  // see a direct reference or a definition.
-  llvm::SmallPtrSet<llvm::GlobalValue*, 10> WeakRefReferences;
-
-  /// DeferredDecls - This contains all the decls which have definitions but
-  /// which are deferred for emission and therefore should only be output if
-  /// they are actually used.  If a decl is in this, then it is known to have
-  /// not been referenced yet.
-  llvm::StringMap<GlobalDecl> DeferredDecls;
-
-  /// DeferredDeclsToEmit - This is a list of deferred decls which we have seen
-  /// that *are* actually referenced.  These get code generated when the module
-  /// is done.
-  std::vector<GlobalDecl> DeferredDeclsToEmit;
-
-  /// LLVMUsed - List of global values which are required to be
-  /// present in the object file; bitcast to i8*. This is used for
-  /// forcing visibility of symbols which may otherwise be optimized
-  /// out.
-  std::vector<llvm::WeakVH> LLVMUsed;
-
-  /// GlobalCtors - Store the list of global constructors and their respective
-  /// priorities to be emitted when the translation unit is complete.
-  CtorList GlobalCtors;
-
-  /// GlobalDtors - Store the list of global destructors and their respective
-  /// priorities to be emitted when the translation unit is complete.
-  CtorList GlobalDtors;
-
-  /// MangledDeclNames - A map of canonical GlobalDecls to their mangled names.
-  llvm::DenseMap<GlobalDecl, StringRef> MangledDeclNames;
-  llvm::BumpPtrAllocator MangledNamesAllocator;
-  
-  /// Global annotations.
-  std::vector<llvm::Constant*> Annotations;
-
-  /// Map used to get unique annotation strings.
-  llvm::StringMap<llvm::Constant*> AnnotationStrings;
-
-  llvm::StringMap<llvm::Constant*> CFConstantStringMap;
-  llvm::StringMap<llvm::GlobalVariable*> ConstantStringMap;
-  llvm::DenseMap<const Decl*, llvm::Constant *> StaticLocalDeclMap;
-  llvm::DenseMap<const Decl*, llvm::GlobalVariable*> StaticLocalDeclGuardMap;
-  
-  llvm::DenseMap<QualType, llvm::Constant *> AtomicSetterHelperFnMap;
-  llvm::DenseMap<QualType, llvm::Constant *> AtomicGetterHelperFnMap;
-
-  /// CXXGlobalInits - Global variables with initializers that need to run
-  /// before main.
-  std::vector<llvm::Constant*> CXXGlobalInits;
-
-  /// When a C++ decl with an initializer is deferred, null is
-  /// appended to CXXGlobalInits, and the index of that null is placed
-  /// here so that the initializer will be performed in the correct
-  /// order.
-  llvm::DenseMap<const Decl*, unsigned> DelayedCXXInitPosition;
-  
-  /// - Global variables with initializers whose order of initialization
-  /// is set by init_priority attribute.
-  
-  SmallVector<std::pair<OrderGlobalInits, llvm::Function*>, 8> 
-    PrioritizedCXXGlobalInits;
-
-  /// CXXGlobalDtors - Global destructor functions and arguments that need to
-  /// run on termination.
-  std::vector<std::pair<llvm::WeakVH,llvm::Constant*> > CXXGlobalDtors;
-
-  /// @name Cache for Objective-C runtime types
-  /// @{
-
-  /// CFConstantStringClassRef - Cached reference to the class for constant
-  /// strings. This value has type int * but is actually an Obj-C class pointer.
-  llvm::Constant *CFConstantStringClassRef;
-
-  /// ConstantStringClassRef - Cached reference to the class for constant
-  /// strings. This value has type int * but is actually an Obj-C class pointer.
-  llvm::Constant *ConstantStringClassRef;
-
-  /// \brief The LLVM type corresponding to NSConstantString.
-  llvm::StructType *NSConstantStringType;
-  
-  /// \brief The type used to describe the state of a fast enumeration in
-  /// Objective-C's for..in loop.
-  QualType ObjCFastEnumerationStateType;
-  
-  /// @}
-
-  /// Lazily create the Objective-C runtime
-  void createObjCRuntime();
-
-  void createOpenCLRuntime();
-  void createCUDARuntime();
-
-  bool isTriviallyRecursive(const FunctionDecl *F);
-  bool shouldEmitFunction(const FunctionDecl *F);
-  llvm::LLVMContext &VMContext;
-
-  /// @name Cache for Blocks Runtime Globals
-  /// @{
-
-  llvm::Constant *NSConcreteGlobalBlock;
-  llvm::Constant *NSConcreteStackBlock;
-
-  llvm::Constant *BlockObjectAssign;
-  llvm::Constant *BlockObjectDispose;
-
-  llvm::Type *BlockDescriptorType;
-  llvm::Type *GenericBlockLiteralType;
-
-  struct {
-    int GlobalUniqueCount;
-  } Block;
-  
-  GlobalDecl initializedGlobalDecl;
-
-  /// @}
-public:
-  CodeGenModule(ASTContext &C, const CodeGenOptions &CodeGenOpts,
-                llvm::Module &M, const llvm::TargetData &TD,
-                DiagnosticsEngine &Diags);
-
-  ~CodeGenModule();
-
-  /// Release - Finalize LLVM code generation.
-  void Release();
-
-  /// getObjCRuntime() - Return a reference to the configured
-  /// Objective-C runtime.
-  CGObjCRuntime &getObjCRuntime() {
-    if (!ObjCRuntime) createObjCRuntime();
-    return *ObjCRuntime;
-  }
-
-  /// hasObjCRuntime() - Return true iff an Objective-C runtime has
-  /// been configured.
-  bool hasObjCRuntime() { return !!ObjCRuntime; }
-
-  /// getOpenCLRuntime() - Return a reference to the configured OpenCL runtime.
-  CGOpenCLRuntime &getOpenCLRuntime() {
-    assert(OpenCLRuntime != 0);
-    return *OpenCLRuntime;
-  }
-
-  /// getCUDARuntime() - Return a reference to the configured CUDA runtime.
-  CGCUDARuntime &getCUDARuntime() {
-    assert(CUDARuntime != 0);
-    return *CUDARuntime;
-  }
-
-  /// getCXXABI() - Return a reference to the configured C++ ABI.
-  CGCXXABI &getCXXABI() { return ABI; }
-
-  ARCEntrypoints &getARCEntrypoints() const {
-    assert(getLangOpts().ObjCAutoRefCount && ARCData != 0);
-    return *ARCData;
-  }
-
-  RREntrypoints &getRREntrypoints() const {
-    assert(RRData != 0);
-    return *RRData;
-  }
-
-  llvm::Constant *getStaticLocalDeclAddress(const VarDecl *D) {
-    return StaticLocalDeclMap[D];
-  }
-  void setStaticLocalDeclAddress(const VarDecl *D, 
-                                 llvm::Constant *C) {
-    StaticLocalDeclMap[D] = C;
-  }
-
-  llvm::GlobalVariable *getStaticLocalDeclGuardAddress(const VarDecl *D) {
-    return StaticLocalDeclGuardMap[D];
-  }
-  void setStaticLocalDeclGuardAddress(const VarDecl *D, 
-                                      llvm::GlobalVariable *C) {
-    StaticLocalDeclGuardMap[D] = C;
-  }
-
-  llvm::Constant *getAtomicSetterHelperFnMap(QualType Ty) {
-    return AtomicSetterHelperFnMap[Ty];
-  }
-  void setAtomicSetterHelperFnMap(QualType Ty,
-                            llvm::Constant *Fn) {
-    AtomicSetterHelperFnMap[Ty] = Fn;
-  }
-
-  llvm::Constant *getAtomicGetterHelperFnMap(QualType Ty) {
-    return AtomicGetterHelperFnMap[Ty];
-  }
-  void setAtomicGetterHelperFnMap(QualType Ty,
-                            llvm::Constant *Fn) {
-    AtomicGetterHelperFnMap[Ty] = Fn;
-  }
-
-  CGDebugInfo *getModuleDebugInfo() { return DebugInfo; }
-
-  llvm::MDNode *getNoObjCARCExceptionsMetadata() {
-    if (!NoObjCARCExceptionsMetadata)
-      NoObjCARCExceptionsMetadata =
-        llvm::MDNode::get(getLLVMContext(),
-                          SmallVector<llvm::Value*,1>());
-    return NoObjCARCExceptionsMetadata;
-  }
-
-  ASTContext &getContext() const { return Context; }
-  const CodeGenOptions &getCodeGenOpts() const { return CodeGenOpts; }
-  const LangOptions &getLangOpts() const { return LangOpts; }
-  llvm::Module &getModule() const { return TheModule; }
-  CodeGenTypes &getTypes() { return Types; }
-  CodeGenVTables &getVTables() { return VTables; }
-  VTableContext &getVTableContext() { return VTables.getVTableContext(); }
-  DiagnosticsEngine &getDiags() const { return Diags; }
-  const llvm::TargetData &getTargetData() const { return TheTargetData; }
-  const TargetInfo &getTarget() const { return Context.getTargetInfo(); }
-  llvm::LLVMContext &getLLVMContext() { return VMContext; }
-  const TargetCodeGenInfo &getTargetCodeGenInfo();
-  bool isTargetDarwin() const;
-
-  bool shouldUseTBAA() const { return TBAA != 0; }
-
-  llvm::MDNode *getTBAAInfo(QualType QTy);
-  llvm::MDNode *getTBAAInfoForVTablePtr();
-  llvm::MDNode *getTBAAStructInfo(QualType QTy);
-
-  bool isTypeConstant(QualType QTy, bool ExcludeCtorDtor);
-
-  static void DecorateInstruction(llvm::Instruction *Inst,
-                                  llvm::MDNode *TBAAInfo);
-
-  /// getSize - Emit the given number of characters as a value of type size_t.
-  llvm::ConstantInt *getSize(CharUnits numChars);
-
-  /// setGlobalVisibility - Set the visibility for the given LLVM
-  /// GlobalValue.
-  void setGlobalVisibility(llvm::GlobalValue *GV, const NamedDecl *D) const;
-
-  /// setTLSMode - Set the TLS mode for the given LLVM GlobalVariable
-  /// for the thread-local variable declaration D.
-  void setTLSMode(llvm::GlobalVariable *GV, const VarDecl &D) const;
-
-  /// TypeVisibilityKind - The kind of global variable that is passed to 
-  /// setTypeVisibility
-  enum TypeVisibilityKind {
-    TVK_ForVTT,
-    TVK_ForVTable,
-    TVK_ForConstructionVTable,
-    TVK_ForRTTI,
-    TVK_ForRTTIName
-  };
-
-  /// setTypeVisibility - Set the visibility for the given global
-  /// value which holds information about a type.
-  void setTypeVisibility(llvm::GlobalValue *GV, const CXXRecordDecl *D,
-                         TypeVisibilityKind TVK) const;
-
-  static llvm::GlobalValue::VisibilityTypes GetLLVMVisibility(Visibility V) {
-    switch (V) {
-    case DefaultVisibility:   return llvm::GlobalValue::DefaultVisibility;
-    case HiddenVisibility:    return llvm::GlobalValue::HiddenVisibility;
-    case ProtectedVisibility: return llvm::GlobalValue::ProtectedVisibility;
-    }
-    llvm_unreachable("unknown visibility!");
-  }
-
-  llvm::Constant *GetAddrOfGlobal(GlobalDecl GD) {
-    if (isa<CXXConstructorDecl>(GD.getDecl()))
-      return GetAddrOfCXXConstructor(cast<CXXConstructorDecl>(GD.getDecl()),
-                                     GD.getCtorType());
-    else if (isa<CXXDestructorDecl>(GD.getDecl()))
-      return GetAddrOfCXXDestructor(cast<CXXDestructorDecl>(GD.getDecl()),
-                                     GD.getDtorType());
-    else if (isa<FunctionDecl>(GD.getDecl()))
-      return GetAddrOfFunction(GD);
-    else
-      return GetAddrOfGlobalVar(cast<VarDecl>(GD.getDecl()));
-  }
-
-  /// CreateOrReplaceCXXRuntimeVariable - Will return a global variable of the given
-  /// type. If a variable with a different type already exists then a new 
-  /// variable with the right type will be created and all uses of the old
-  /// variable will be replaced with a bitcast to the new variable.
-  llvm::GlobalVariable *
-  CreateOrReplaceCXXRuntimeVariable(StringRef Name, llvm::Type *Ty,
-                                    llvm::GlobalValue::LinkageTypes Linkage);
-
-  /// GetGlobalVarAddressSpace - Return the address space of the underlying
-  /// global variable for D, as determined by its declaration.  Normally this
-  /// is the same as the address space of D's type, but in CUDA, address spaces
-  /// are associated with declarations, not types.
-  unsigned GetGlobalVarAddressSpace(const VarDecl *D, unsigned AddrSpace);
-
-  /// GetAddrOfGlobalVar - Return the llvm::Constant for the address of the
-  /// given global variable.  If Ty is non-null and if the global doesn't exist,
-  /// then it will be greated with the specified type instead of whatever the
-  /// normal requested type would be.
-  llvm::Constant *GetAddrOfGlobalVar(const VarDecl *D,
-                                     llvm::Type *Ty = 0);
-
-
-  /// GetAddrOfFunction - Return the address of the given function.  If Ty is
-  /// non-null, then this function will use the specified type if it has to
-  /// create it.
-  llvm::Constant *GetAddrOfFunction(GlobalDecl GD,
-                                    llvm::Type *Ty = 0,
-                                    bool ForVTable = false);
-
-  /// GetAddrOfRTTIDescriptor - Get the address of the RTTI descriptor 
-  /// for the given type.
-  llvm::Constant *GetAddrOfRTTIDescriptor(QualType Ty, bool ForEH = false);
-
-  /// GetAddrOfThunk - Get the address of the thunk for the given global decl.
-  llvm::Constant *GetAddrOfThunk(GlobalDecl GD, const ThunkInfo &Thunk);
-
-  /// GetWeakRefReference - Get a reference to the target of VD.
-  llvm::Constant *GetWeakRefReference(const ValueDecl *VD);
-
-  /// GetNonVirtualBaseClassOffset - Returns the offset from a derived class to 
-  /// a class. Returns null if the offset is 0. 
-  llvm::Constant *
-  GetNonVirtualBaseClassOffset(const CXXRecordDecl *ClassDecl,
-                               CastExpr::path_const_iterator PathBegin,
-                               CastExpr::path_const_iterator PathEnd);
-
-  /// A pair of helper functions for a __block variable.
-  class ByrefHelpers : public llvm::FoldingSetNode {
-  public:
-    llvm::Constant *CopyHelper;
-    llvm::Constant *DisposeHelper;
-
-    /// The alignment of the field.  This is important because
-    /// different offsets to the field within the byref struct need to
-    /// have different helper functions.
-    CharUnits Alignment;
-
-    ByrefHelpers(CharUnits alignment) : Alignment(alignment) {}
-    virtual ~ByrefHelpers();
-
-    void Profile(llvm::FoldingSetNodeID &id) const {
-      id.AddInteger(Alignment.getQuantity());
-      profileImpl(id);
-    }
-    virtual void profileImpl(llvm::FoldingSetNodeID &id) const = 0;
-
-    virtual bool needsCopy() const { return true; }
-    virtual void emitCopy(CodeGenFunction &CGF,
-                          llvm::Value *dest, llvm::Value *src) = 0;
-
-    virtual bool needsDispose() const { return true; }
-    virtual void emitDispose(CodeGenFunction &CGF, llvm::Value *field) = 0;
-  };
-
-  llvm::FoldingSet<ByrefHelpers> ByrefHelpersCache;
-
-  /// getUniqueBlockCount - Fetches the global unique block count.
-  int getUniqueBlockCount() { return ++Block.GlobalUniqueCount; }
-  
-  /// getBlockDescriptorType - Fetches the type of a generic block
-  /// descriptor.
-  llvm::Type *getBlockDescriptorType();
-
-  /// getGenericBlockLiteralType - The type of a generic block literal.
-  llvm::Type *getGenericBlockLiteralType();
-
-  /// GetAddrOfGlobalBlock - Gets the address of a block which
-  /// requires no captures.
-  llvm::Constant *GetAddrOfGlobalBlock(const BlockExpr *BE, const char *);
-  
-  /// GetAddrOfConstantCFString - Return a pointer to a constant CFString object
-  /// for the given string.
-  llvm::Constant *GetAddrOfConstantCFString(const StringLiteral *Literal);
-  
-  /// GetAddrOfConstantString - Return a pointer to a constant NSString object
-  /// for the given string. Or a user defined String object as defined via
-  /// -fconstant-string-class=class_name option.
-  llvm::Constant *GetAddrOfConstantString(const StringLiteral *Literal);
-
-  /// GetConstantArrayFromStringLiteral - Return a constant array for the given
-  /// string.
-  llvm::Constant *GetConstantArrayFromStringLiteral(const StringLiteral *E);
-
-  /// GetAddrOfConstantStringFromLiteral - Return a pointer to a constant array
-  /// for the given string literal.
-  llvm::Constant *GetAddrOfConstantStringFromLiteral(const StringLiteral *S);
-
-  /// GetAddrOfConstantStringFromObjCEncode - Return a pointer to a constant
-  /// array for the given ObjCEncodeExpr node.
-  llvm::Constant *GetAddrOfConstantStringFromObjCEncode(const ObjCEncodeExpr *);
-
-  /// GetAddrOfConstantString - Returns a pointer to a character array
-  /// containing the literal. This contents are exactly that of the given
-  /// string, i.e. it will not be null terminated automatically; see
-  /// GetAddrOfConstantCString. Note that whether the result is actually a
-  /// pointer to an LLVM constant depends on Feature.WriteableStrings.
-  ///
-  /// The result has pointer to array type.
-  ///
-  /// \param GlobalName If provided, the name to use for the global
-  /// (if one is created).
-  llvm::Constant *GetAddrOfConstantString(StringRef Str,
-                                          const char *GlobalName=0,
-                                          unsigned Alignment=1);
-
-  /// GetAddrOfConstantCString - Returns a pointer to a character array
-  /// containing the literal and a terminating '\0' character. The result has
-  /// pointer to array type.
-  ///
-  /// \param GlobalName If provided, the name to use for the global (if one is
-  /// created).
-  llvm::Constant *GetAddrOfConstantCString(const std::string &str,
-                                           const char *GlobalName=0,
-                                           unsigned Alignment=1);
-
-  /// GetAddrOfConstantCompoundLiteral - Returns a pointer to a constant global
-  /// variable for the given file-scope compound literal expression.
-  llvm::Constant *GetAddrOfConstantCompoundLiteral(const CompoundLiteralExpr*E);
-  
-  /// \brief Retrieve the record type that describes the state of an
-  /// Objective-C fast enumeration loop (for..in).
-  QualType getObjCFastEnumerationStateType();
-  
-  /// GetAddrOfCXXConstructor - Return the address of the constructor of the
-  /// given type.
-  llvm::GlobalValue *GetAddrOfCXXConstructor(const CXXConstructorDecl *ctor,
-                                             CXXCtorType ctorType,
-                                             const CGFunctionInfo *fnInfo = 0);
-
-  /// GetAddrOfCXXDestructor - Return the address of the constructor of the
-  /// given type.
-  llvm::GlobalValue *GetAddrOfCXXDestructor(const CXXDestructorDecl *dtor,
-                                            CXXDtorType dtorType,
-                                            const CGFunctionInfo *fnInfo = 0);
-
-  /// getBuiltinLibFunction - Given a builtin id for a function like
-  /// "__builtin_fabsf", return a Function* for "fabsf".
-  llvm::Value *getBuiltinLibFunction(const FunctionDecl *FD,
-                                     unsigned BuiltinID);
-
-  llvm::Function *getIntrinsic(unsigned IID, ArrayRef<llvm::Type*> Tys =
-                                                 ArrayRef<llvm::Type*>());
-
-  /// EmitTopLevelDecl - Emit code for a single top level declaration.
-  void EmitTopLevelDecl(Decl *D);
-
-  /// HandleCXXStaticMemberVarInstantiation - Tell the consumer that this
-  // variable has been instantiated.
-  void HandleCXXStaticMemberVarInstantiation(VarDecl *VD);
-
-  /// AddUsedGlobal - Add a global which should be forced to be
-  /// present in the object file; these are emitted to the llvm.used
-  /// metadata global.
-  void AddUsedGlobal(llvm::GlobalValue *GV);
-
-  /// AddCXXDtorEntry - Add a destructor and object to add to the C++ global
-  /// destructor function.
-  void AddCXXDtorEntry(llvm::Constant *DtorFn, llvm::Constant *Object) {
-    CXXGlobalDtors.push_back(std::make_pair(DtorFn, Object));
-  }
-
-  /// CreateRuntimeFunction - Create a new runtime function with the specified
-  /// type and name.
-  llvm::Constant *CreateRuntimeFunction(llvm::FunctionType *Ty,
-                                        StringRef Name,
-                                        llvm::Attributes ExtraAttrs =
-                                          llvm::Attribute::None);
-  /// CreateRuntimeVariable - Create a new runtime global variable with the
-  /// specified type and name.
-  llvm::Constant *CreateRuntimeVariable(llvm::Type *Ty,
-                                        StringRef Name);
-
-  ///@name Custom Blocks Runtime Interfaces
-  ///@{
-
-  llvm::Constant *getNSConcreteGlobalBlock();
-  llvm::Constant *getNSConcreteStackBlock();
-  llvm::Constant *getBlockObjectAssign();
-  llvm::Constant *getBlockObjectDispose();
-
-  ///@}
-
-  // UpdateCompleteType - Make sure that this type is translated.
-  void UpdateCompletedType(const TagDecl *TD);
-
-  llvm::Constant *getMemberPointerConstant(const UnaryOperator *e);
-
-  /// EmitConstantInit - Try to emit the initializer for the given declaration
-  /// as a constant; returns 0 if the expression cannot be emitted as a
-  /// constant.
-  llvm::Constant *EmitConstantInit(const VarDecl &D, CodeGenFunction *CGF = 0);
-
-  /// EmitConstantExpr - Try to emit the given expression as a
-  /// constant; returns 0 if the expression cannot be emitted as a
-  /// constant.
-  llvm::Constant *EmitConstantExpr(const Expr *E, QualType DestType,
-                                   CodeGenFunction *CGF = 0);
-
-  /// EmitConstantValue - Emit the given constant value as a constant, in the
-  /// type's scalar representation.
-  llvm::Constant *EmitConstantValue(const APValue &Value, QualType DestType,
-                                    CodeGenFunction *CGF = 0);
-
-  /// EmitConstantValueForMemory - Emit the given constant value as a constant,
-  /// in the type's memory representation.
-  llvm::Constant *EmitConstantValueForMemory(const APValue &Value,
-                                             QualType DestType,
-                                             CodeGenFunction *CGF = 0);
-
-  /// EmitNullConstant - Return the result of value-initializing the given
-  /// type, i.e. a null expression of the given type.  This is usually,
-  /// but not always, an LLVM null constant.
-  llvm::Constant *EmitNullConstant(QualType T);
-
-  /// EmitNullConstantForBase - Return a null constant appropriate for 
-  /// zero-initializing a base class with the given type.  This is usually,
-  /// but not always, an LLVM null constant.
-  llvm::Constant *EmitNullConstantForBase(const CXXRecordDecl *Record);
-
-  /// Error - Emit a general error that something can't be done.
-  void Error(SourceLocation loc, StringRef error);
-
-  /// ErrorUnsupported - Print out an error that codegen doesn't support the
-  /// specified stmt yet.
-  /// \param OmitOnError - If true, then this error should only be emitted if no
-  /// other errors have been reported.
-  void ErrorUnsupported(const Stmt *S, const char *Type,
-                        bool OmitOnError=false);
-
-  /// ErrorUnsupported - Print out an error that codegen doesn't support the
-  /// specified decl yet.
-  /// \param OmitOnError - If true, then this error should only be emitted if no
-  /// other errors have been reported.
-  void ErrorUnsupported(const Decl *D, const char *Type,
-                        bool OmitOnError=false);
-
-  /// SetInternalFunctionAttributes - Set the attributes on the LLVM
-  /// function for the given decl and function info. This applies
-  /// attributes necessary for handling the ABI as well as user
-  /// specified attributes like section.
-  void SetInternalFunctionAttributes(const Decl *D, llvm::Function *F,
-                                     const CGFunctionInfo &FI);
-
-  /// SetLLVMFunctionAttributes - Set the LLVM function attributes
-  /// (sext, zext, etc).
-  void SetLLVMFunctionAttributes(const Decl *D,
-                                 const CGFunctionInfo &Info,
-                                 llvm::Function *F);
-
-  /// SetLLVMFunctionAttributesForDefinition - Set the LLVM function attributes
-  /// which only apply to a function definintion.
-  void SetLLVMFunctionAttributesForDefinition(const Decl *D, llvm::Function *F);
-
-  /// ReturnTypeUsesSRet - Return true iff the given type uses 'sret' when used
-  /// as a return type.
-  bool ReturnTypeUsesSRet(const CGFunctionInfo &FI);
-
-  /// ReturnTypeUsesFPRet - Return true iff the given type uses 'fpret' when
-  /// used as a return type.
-  bool ReturnTypeUsesFPRet(QualType ResultType);
-
-  /// ReturnTypeUsesFP2Ret - Return true iff the given type uses 'fp2ret' when
-  /// used as a return type.
-  bool ReturnTypeUsesFP2Ret(QualType ResultType);
-
-  /// ConstructAttributeList - Get the LLVM attributes and calling convention to
-  /// use for a particular function type.
-  ///
-  /// \param Info - The function type information.
-  /// \param TargetDecl - The decl these attributes are being constructed
-  /// for. If supplied the attributes applied to this decl may contribute to the
-  /// function attributes and calling convention.
-  /// \param PAL [out] - On return, the attribute list to use.
-  /// \param CallingConv [out] - On return, the LLVM calling convention to use.
-  void ConstructAttributeList(const CGFunctionInfo &Info,
-                              const Decl *TargetDecl,
-                              AttributeListType &PAL,
-                              unsigned &CallingConv);
-
-  StringRef getMangledName(GlobalDecl GD);
-  void getBlockMangledName(GlobalDecl GD, MangleBuffer &Buffer,
-                           const BlockDecl *BD);
-
-  void EmitTentativeDefinition(const VarDecl *D);
-
-  void EmitVTable(CXXRecordDecl *Class, bool DefinitionRequired);
-
-  llvm::GlobalVariable::LinkageTypes
-  getFunctionLinkage(const FunctionDecl *FD);
-
-  void setFunctionLinkage(const FunctionDecl *FD, llvm::GlobalValue *V) {
-    V->setLinkage(getFunctionLinkage(FD));
-  }
-
-  /// getVTableLinkage - Return the appropriate linkage for the vtable, VTT,
-  /// and type information of the given class.
-  llvm::GlobalVariable::LinkageTypes getVTableLinkage(const CXXRecordDecl *RD);
-
-  /// GetTargetTypeStoreSize - Return the store size, in character units, of
-  /// the given LLVM type.
-  CharUnits GetTargetTypeStoreSize(llvm::Type *Ty) const;
-  
-  /// GetLLVMLinkageVarDefinition - Returns LLVM linkage for a global 
-  /// variable.
-  llvm::GlobalValue::LinkageTypes 
-  GetLLVMLinkageVarDefinition(const VarDecl *D,
-                              llvm::GlobalVariable *GV);
-  
-  std::vector<const CXXRecordDecl*> DeferredVTables;
-
-  /// Emit all the global annotations.
-  void EmitGlobalAnnotations();
-
-  /// Emit an annotation string.
-  llvm::Constant *EmitAnnotationString(llvm::StringRef Str);
-
-  /// Emit the annotation's translation unit.
-  llvm::Constant *EmitAnnotationUnit(SourceLocation Loc);
-
-  /// Emit the annotation line number.
-  llvm::Constant *EmitAnnotationLineNo(SourceLocation L);
-
-  /// EmitAnnotateAttr - Generate the llvm::ConstantStruct which contains the
-  /// annotation information for a given GlobalValue. The annotation struct is
-  /// {i8 *, i8 *, i8 *, i32}. The first field is a constant expression, the
-  /// GlobalValue being annotated. The second field is the constant string
-  /// created from the AnnotateAttr's annotation. The third field is a constant
-  /// string containing the name of the translation unit. The fourth field is
-  /// the line number in the file of the annotated value declaration.
-  llvm::Constant *EmitAnnotateAttr(llvm::GlobalValue *GV,
-                                   const AnnotateAttr *AA,
-                                   SourceLocation L);
-
-  /// Add global annotations that are set on D, for the global GV. Those
-  /// annotations are emitted during finalization of the LLVM code.
-  void AddGlobalAnnotations(const ValueDecl *D, llvm::GlobalValue *GV);
-
-private:
-  llvm::GlobalValue *GetGlobalValue(StringRef Ref);
-
-  llvm::Constant *GetOrCreateLLVMFunction(StringRef MangledName,
-                                          llvm::Type *Ty,
-                                          GlobalDecl D,
-                                          bool ForVTable,
-                                          llvm::Attributes ExtraAttrs =
-                                            llvm::Attribute::None);
-  llvm::Constant *GetOrCreateLLVMGlobal(StringRef MangledName,
-                                        llvm::PointerType *PTy,
-                                        const VarDecl *D,
-                                        bool UnnamedAddr = false);
-
-  /// SetCommonAttributes - Set attributes which are common to any
-  /// form of a global definition (alias, Objective-C method,
-  /// function, global variable).
-  ///
-  /// NOTE: This should only be called for definitions.
-  void SetCommonAttributes(const Decl *D, llvm::GlobalValue *GV);
-
-  /// SetFunctionDefinitionAttributes - Set attributes for a global definition.
-  void SetFunctionDefinitionAttributes(const FunctionDecl *D,
-                                       llvm::GlobalValue *GV);
-
-  /// SetFunctionAttributes - Set function attributes for a function
-  /// declaration.
-  void SetFunctionAttributes(GlobalDecl GD,
-                             llvm::Function *F,
-                             bool IsIncompleteFunction);
-
-  /// EmitGlobal - Emit code for a singal global function or var decl. Forward
-  /// declarations are emitted lazily.
-  void EmitGlobal(GlobalDecl D);
-
-  void EmitGlobalDefinition(GlobalDecl D);
-
-  void EmitGlobalFunctionDefinition(GlobalDecl GD);
-  void EmitGlobalVarDefinition(const VarDecl *D);
-  llvm::Constant *MaybeEmitGlobalStdInitializerListInitializer(const VarDecl *D,
-                                                              const Expr *init);
-  void EmitAliasDefinition(GlobalDecl GD);
-  void EmitObjCPropertyImplementations(const ObjCImplementationDecl *D);
-  void EmitObjCIvarInitializations(ObjCImplementationDecl *D);
-  
-  // C++ related functions.
-
-  bool TryEmitDefinitionAsAlias(GlobalDecl Alias, GlobalDecl Target);
-  bool TryEmitBaseDestructorAsAlias(const CXXDestructorDecl *D);
-
-  void EmitNamespace(const NamespaceDecl *D);
-  void EmitLinkageSpec(const LinkageSpecDecl *D);
-
-  /// EmitCXXConstructors - Emit constructors (base, complete) from a
-  /// C++ constructor Decl.
-  void EmitCXXConstructors(const CXXConstructorDecl *D);
-
-  /// EmitCXXConstructor - Emit a single constructor with the given type from
-  /// a C++ constructor Decl.
-  void EmitCXXConstructor(const CXXConstructorDecl *D, CXXCtorType Type);
-
-  /// EmitCXXDestructors - Emit destructors (base, complete) from a
-  /// C++ destructor Decl.
-  void EmitCXXDestructors(const CXXDestructorDecl *D);
-
-  /// EmitCXXDestructor - Emit a single destructor with the given type from
-  /// a C++ destructor Decl.
-  void EmitCXXDestructor(const CXXDestructorDecl *D, CXXDtorType Type);
-
-  /// EmitCXXGlobalInitFunc - Emit the function that initializes C++ globals.
-  void EmitCXXGlobalInitFunc();
-
-  /// EmitCXXGlobalDtorFunc - Emit the function that destroys C++ globals.
-  void EmitCXXGlobalDtorFunc();
-
-  /// EmitCXXGlobalVarDeclInitFunc - Emit the function that initializes the
-  /// specified global (if PerformInit is true) and registers its destructor.
-  void EmitCXXGlobalVarDeclInitFunc(const VarDecl *D,
-                                    llvm::GlobalVariable *Addr,
-                                    bool PerformInit);
-
-  // FIXME: Hardcoding priority here is gross.
-  void AddGlobalCtor(llvm::Function *Ctor, int Priority=65535);
-  void AddGlobalDtor(llvm::Function *Dtor, int Priority=65535);
-
-  /// EmitCtorList - Generates a global array of functions and priorities using
-  /// the given list and name. This array will have appending linkage and is
-  /// suitable for use as a LLVM constructor or destructor array.
-  void EmitCtorList(const CtorList &Fns, const char *GlobalName);
-
-  /// EmitFundamentalRTTIDescriptor - Emit the RTTI descriptors for the
-  /// given type.
-  void EmitFundamentalRTTIDescriptor(QualType Type);
-
-  /// EmitFundamentalRTTIDescriptors - Emit the RTTI descriptors for the
-  /// builtin types.
-  void EmitFundamentalRTTIDescriptors();
-
-  /// EmitDeferred - Emit any needed decls for which code generation
-  /// was deferred.
-  void EmitDeferred(void);
-
-  /// EmitLLVMUsed - Emit the llvm.used metadata used to force
-  /// references to global which may otherwise be optimized out.
-  void EmitLLVMUsed(void);
-
-  void EmitDeclMetadata();
-
-  /// EmitCoverageFile - Emit the llvm.gcov metadata used to tell LLVM where
-  /// to emit the .gcno and .gcda files in a way that persists in .bc files.
-  void EmitCoverageFile();
-
-  /// MayDeferGeneration - Determine if the given decl can be emitted
-  /// lazily; this is only relevant for definitions. The given decl
-  /// must be either a function or var decl.
-  bool MayDeferGeneration(const ValueDecl *D);
-
-  /// SimplifyPersonality - Check whether we can use a "simpler", more
-  /// core exceptions personality function.
-  void SimplifyPersonality();
-};
-}  // end namespace CodeGen
-}  // end namespace clang
-
-#endif
Index: tools/clang/lib/CodeGen/CGVTables.h
===================================================================
--- tools/clang/lib/CodeGen/CGVTables.h	(revision 47284)
+++ tools/clang/lib/CodeGen/CGVTables.h	(revision 47286)
@@ -1,141 +0,0 @@
-//===--- CGVTables.h - Emit LLVM Code for C++ vtables -----------*- C++ -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This contains code dealing with C++ code generation of virtual tables.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef CLANG_CODEGEN_CGVTABLE_H
-#define CLANG_CODEGEN_CGVTABLE_H
-
-#include "llvm/ADT/DenseMap.h"
-#include "llvm/GlobalVariable.h"
-#include "clang/Basic/ABI.h"
-#include "clang/AST/BaseSubobject.h"
-#include "clang/AST/CharUnits.h"
-#include "clang/AST/GlobalDecl.h"
-#include "clang/AST/VTableBuilder.h"
-
-namespace clang {
-  class CXXRecordDecl;
-
-namespace CodeGen {
-  class CodeGenModule;
-
-class CodeGenVTables {
-  CodeGenModule &CGM;
-
-  VTableContext VTContext;
-
-  /// VTables - All the vtables which have been defined.
-  llvm::DenseMap<const CXXRecordDecl *, llvm::GlobalVariable *> VTables;
-  
-  /// VTableAddressPointsMapTy - Address points for a single vtable.
-  typedef llvm::DenseMap<BaseSubobject, uint64_t> VTableAddressPointsMapTy;
-
-  typedef std::pair<const CXXRecordDecl *, BaseSubobject> BaseSubobjectPairTy;
-  typedef llvm::DenseMap<BaseSubobjectPairTy, uint64_t> SubVTTIndiciesMapTy;
-  
-  /// SubVTTIndicies - Contains indices into the various sub-VTTs.
-  SubVTTIndiciesMapTy SubVTTIndicies;
-
-  typedef llvm::DenseMap<BaseSubobjectPairTy, uint64_t>
-    SecondaryVirtualPointerIndicesMapTy;
-
-  /// SecondaryVirtualPointerIndices - Contains the secondary virtual pointer
-  /// indices.
-  SecondaryVirtualPointerIndicesMapTy SecondaryVirtualPointerIndices;
-
-  /// EmitThunk - Emit a single thunk.
-  void EmitThunk(GlobalDecl GD, const ThunkInfo &Thunk, 
-                 bool UseAvailableExternallyLinkage);
-
-  /// MaybeEmitThunkAvailableExternally - Try to emit the given thunk with
-  /// available_externally linkage to allow for inlining of thunks.
-  /// This will be done iff optimizations are enabled and the member function
-  /// doesn't contain any incomplete types.
-  void MaybeEmitThunkAvailableExternally(GlobalDecl GD, const ThunkInfo &Thunk);
-
-  /// CreateVTableInitializer - Create a vtable initializer for the given record
-  /// decl.
-  /// \param Components - The vtable components; this is really an array of
-  /// VTableComponents.
-  llvm::Constant *CreateVTableInitializer(const CXXRecordDecl *RD,
-                                          const VTableComponent *Components, 
-                                          unsigned NumComponents,
-                                const VTableLayout::VTableThunkTy *VTableThunks,
-                                          unsigned NumVTableThunks);
-
-public:
-  CodeGenVTables(CodeGenModule &CGM);
-
-  VTableContext &getVTableContext() { return VTContext; }
-
-  /// \brief True if the VTable of this record must be emitted in the
-  /// translation unit.
-  bool ShouldEmitVTableInThisTU(const CXXRecordDecl *RD);
-
-  /// needsVTTParameter - Return whether the given global decl needs a VTT
-  /// parameter, which it does if it's a base constructor or destructor with
-  /// virtual bases.
-  static bool needsVTTParameter(GlobalDecl GD);
-
-  /// getSubVTTIndex - Return the index of the sub-VTT for the base class of the
-  /// given record decl.
-  uint64_t getSubVTTIndex(const CXXRecordDecl *RD, BaseSubobject Base);
-  
-  /// getSecondaryVirtualPointerIndex - Return the index in the VTT where the
-  /// virtual pointer for the given subobject is located.
-  uint64_t getSecondaryVirtualPointerIndex(const CXXRecordDecl *RD,
-                                           BaseSubobject Base);
-
-  /// getAddressPoint - Get the address point of the given subobject in the
-  /// class decl.
-  uint64_t getAddressPoint(BaseSubobject Base, const CXXRecordDecl *RD);
-  
-  /// GetAddrOfVTable - Get the address of the vtable for the given record decl.
-  llvm::GlobalVariable *GetAddrOfVTable(const CXXRecordDecl *RD);
-
-  /// EmitVTableDefinition - Emit the definition of the given vtable.
-  void EmitVTableDefinition(llvm::GlobalVariable *VTable,
-                            llvm::GlobalVariable::LinkageTypes Linkage,
-                            const CXXRecordDecl *RD);
-  
-  /// GenerateConstructionVTable - Generate a construction vtable for the given 
-  /// base subobject.
-  llvm::GlobalVariable *
-  GenerateConstructionVTable(const CXXRecordDecl *RD, const BaseSubobject &Base, 
-                             bool BaseIsVirtual, 
-                             llvm::GlobalVariable::LinkageTypes Linkage,
-                             VTableAddressPointsMapTy& AddressPoints);
-
-    
-  /// GetAddrOfVTable - Get the address of the VTT for the given record decl.
-  llvm::GlobalVariable *GetAddrOfVTT(const CXXRecordDecl *RD);
-
-  /// EmitVTTDefinition - Emit the definition of the given vtable.
-  void EmitVTTDefinition(llvm::GlobalVariable *VTT,
-                         llvm::GlobalVariable::LinkageTypes Linkage,
-                         const CXXRecordDecl *RD);
-
-  /// EmitThunks - Emit the associated thunks for the given global decl.
-  void EmitThunks(GlobalDecl GD);
-    
-  /// GenerateClassData - Generate all the class data required to be generated
-  /// upon definition of a KeyFunction.  This includes the vtable, the
-  /// rtti data structure and the VTT.
-  ///
-  /// \param Linkage - The desired linkage of the vtable, the RTTI and the VTT.
-  void GenerateClassData(llvm::GlobalVariable::LinkageTypes Linkage,
-                         const CXXRecordDecl *RD);
-};
-
-} // end namespace CodeGen
-} // end namespace clang
-#endif
Index: tools/clang/lib/CodeGen/CGCall.h
===================================================================
--- tools/clang/lib/CodeGen/CGCall.h	(revision 47284)
+++ tools/clang/lib/CodeGen/CGCall.h	(revision 47286)
@@ -1,306 +0,0 @@
-//===----- CGCall.h - Encapsulate calling convention details ----*- C++ -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// These classes wrap the information about a call or function
-// definition used to handle ABI compliancy.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef CLANG_CODEGEN_CGCALL_H
-#define CLANG_CODEGEN_CGCALL_H
-
-#include "llvm/ADT/FoldingSet.h"
-#include "llvm/Value.h"
-#include "clang/AST/Type.h"
-#include "clang/AST/CanonicalType.h"
-
-#include "CGValue.h"
-
-// FIXME: Restructure so we don't have to expose so much stuff.
-#include "ABIInfo.h"
-
-namespace llvm {
-  struct AttributeWithIndex;
-  class Function;
-  class Type;
-  class Value;
-
-  template<typename T, unsigned> class SmallVector;
-}
-
-namespace clang {
-  class ASTContext;
-  class Decl;
-  class FunctionDecl;
-  class ObjCMethodDecl;
-  class VarDecl;
-
-namespace CodeGen {
-  typedef SmallVector<llvm::AttributeWithIndex, 8> AttributeListType;
-
-  struct CallArg {
-    RValue RV;
-    QualType Ty;
-    bool NeedsCopy;
-    CallArg(RValue rv, QualType ty, bool needscopy)
-    : RV(rv), Ty(ty), NeedsCopy(needscopy)
-    { }
-  };
-
-  /// CallArgList - Type for representing both the value and type of
-  /// arguments in a call.
-  class CallArgList :
-    public SmallVector<CallArg, 16> {
-  public:
-    struct Writeback {
-      /// The original argument.
-      llvm::Value *Address;
-
-      /// The pointee type of the original argument.
-      QualType AddressType;
-
-      /// The temporary alloca.
-      llvm::Value *Temporary;
-    };
-
-    void add(RValue rvalue, QualType type, bool needscopy = false) {
-      push_back(CallArg(rvalue, type, needscopy));
-    }
-
-    void addFrom(const CallArgList &other) {
-      insert(end(), other.begin(), other.end());
-      Writebacks.insert(Writebacks.end(),
-                        other.Writebacks.begin(), other.Writebacks.end());
-    }
-
-    void addWriteback(llvm::Value *address, QualType addressType,
-                      llvm::Value *temporary) {
-      Writeback writeback;
-      writeback.Address = address;
-      writeback.AddressType = addressType;
-      writeback.Temporary = temporary;
-      Writebacks.push_back(writeback);
-    }
-
-    bool hasWritebacks() const { return !Writebacks.empty(); }
-
-    typedef SmallVectorImpl<Writeback>::const_iterator writeback_iterator;
-    writeback_iterator writeback_begin() const { return Writebacks.begin(); }
-    writeback_iterator writeback_end() const { return Writebacks.end(); }
-
-  private:
-    SmallVector<Writeback, 1> Writebacks;
-  };
-
-  /// A class for recording the number of arguments that a function
-  /// signature requires.
-  class RequiredArgs {
-    /// The number of required arguments, or ~0 if the signature does
-    /// not permit optional arguments.
-    unsigned NumRequired;
-  public:
-    enum All_t { All };
-
-    RequiredArgs(All_t _) : NumRequired(~0U) {}
-    explicit RequiredArgs(unsigned n) : NumRequired(n) {
-      assert(n != ~0U);
-    }
-
-    /// Compute the arguments required by the given formal prototype,
-    /// given that there may be some additional, non-formal arguments
-    /// in play.
-    static RequiredArgs forPrototypePlus(const FunctionProtoType *prototype,
-                                         unsigned additional) {
-      if (!prototype->isVariadic()) return All;
-      return RequiredArgs(prototype->getNumArgs() + additional);
-    }
-
-    static RequiredArgs forPrototype(const FunctionProtoType *prototype) {
-      return forPrototypePlus(prototype, 0);
-    }
-
-    static RequiredArgs forPrototype(CanQual<FunctionProtoType> prototype) {
-      return forPrototype(prototype.getTypePtr());
-    }
-
-    static RequiredArgs forPrototypePlus(CanQual<FunctionProtoType> prototype,
-                                         unsigned additional) {
-      return forPrototypePlus(prototype.getTypePtr(), additional);
-    }
-
-    bool allowsOptionalArgs() const { return NumRequired != ~0U; }
-    bool getNumRequiredArgs() const {
-      assert(allowsOptionalArgs());
-      return NumRequired;
-    }
-
-    unsigned getOpaqueData() const { return NumRequired; }
-    static RequiredArgs getFromOpaqueData(unsigned value) {
-      if (value == ~0U) return All;
-      return RequiredArgs(value);
-    }
-  };
-
-  /// FunctionArgList - Type for representing both the decl and type
-  /// of parameters to a function. The decl must be either a
-  /// ParmVarDecl or ImplicitParamDecl.
-  class FunctionArgList : public SmallVector<const VarDecl*, 16> {
-  };
-
-  /// CGFunctionInfo - Class to encapsulate the information about a
-  /// function definition.
-  class CGFunctionInfo : public llvm::FoldingSetNode {
-    struct ArgInfo {
-      CanQualType type;
-      ABIArgInfo info;
-    };
-
-    /// The LLVM::CallingConv to use for this function (as specified by the
-    /// user).
-    unsigned CallingConvention : 8;
-
-    /// The LLVM::CallingConv to actually use for this function, which may
-    /// depend on the ABI.
-    unsigned EffectiveCallingConvention : 8;
-
-    /// The clang::CallingConv that this was originally created with.
-    unsigned ASTCallingConvention : 8;
-
-    /// Whether this function is noreturn.
-    unsigned NoReturn : 1;
-
-    /// Whether this function is returns-retained.
-    unsigned ReturnsRetained : 1;
-
-    /// How many arguments to pass inreg.
-    unsigned HasRegParm : 1;
-    unsigned RegParm : 4;
-
-    RequiredArgs Required;
-
-    unsigned NumArgs;
-    ArgInfo *getArgsBuffer() {
-      return reinterpret_cast<ArgInfo*>(this+1);
-    }
-    const ArgInfo *getArgsBuffer() const {
-      return reinterpret_cast<const ArgInfo*>(this + 1);
-    }
-
-    CGFunctionInfo() : Required(RequiredArgs::All) {}
-
-  public:
-    static CGFunctionInfo *create(unsigned llvmCC,
-                                  const FunctionType::ExtInfo &extInfo,
-                                  CanQualType resultType,
-                                  ArrayRef<CanQualType> argTypes,
-                                  RequiredArgs required);
-
-    typedef const ArgInfo *const_arg_iterator;
-    typedef ArgInfo *arg_iterator;
-
-    const_arg_iterator arg_begin() const { return getArgsBuffer() + 1; }
-    const_arg_iterator arg_end() const { return getArgsBuffer() + 1 + NumArgs; }
-    arg_iterator arg_begin() { return getArgsBuffer() + 1; }
-    arg_iterator arg_end() { return getArgsBuffer() + 1 + NumArgs; }
-
-    unsigned  arg_size() const { return NumArgs; }
-
-    bool isVariadic() const { return Required.allowsOptionalArgs(); }
-    RequiredArgs getRequiredArgs() const { return Required; }
-
-    bool isNoReturn() const { return NoReturn; }
-
-    /// In ARC, whether this function retains its return value.  This
-    /// is not always reliable for call sites.
-    bool isReturnsRetained() const { return ReturnsRetained; }
-
-    /// getASTCallingConvention() - Return the AST-specified calling
-    /// convention.
-    CallingConv getASTCallingConvention() const {
-      return CallingConv(ASTCallingConvention);
-    }
-
-    /// getCallingConvention - Return the user specified calling
-    /// convention, which has been translated into an LLVM CC.
-    unsigned getCallingConvention() const { return CallingConvention; }
-
-    /// getEffectiveCallingConvention - Return the actual calling convention to
-    /// use, which may depend on the ABI.
-    unsigned getEffectiveCallingConvention() const {
-      return EffectiveCallingConvention;
-    }
-    void setEffectiveCallingConvention(unsigned Value) {
-      EffectiveCallingConvention = Value;
-    }
-
-    bool getHasRegParm() const { return HasRegParm; }
-    unsigned getRegParm() const { return RegParm; }
-
-    FunctionType::ExtInfo getExtInfo() const {
-      return FunctionType::ExtInfo(isNoReturn(),
-                                   getHasRegParm(), getRegParm(),
-                                   getASTCallingConvention(),
-                                   isReturnsRetained());
-    }
-
-    CanQualType getReturnType() const { return getArgsBuffer()[0].type; }
-
-    ABIArgInfo &getReturnInfo() { return getArgsBuffer()[0].info; }
-    const ABIArgInfo &getReturnInfo() const { return getArgsBuffer()[0].info; }
-
-    void Profile(llvm::FoldingSetNodeID &ID) {
-      ID.AddInteger(getASTCallingConvention());
-      ID.AddBoolean(NoReturn);
-      ID.AddBoolean(ReturnsRetained);
-      ID.AddBoolean(HasRegParm);
-      ID.AddInteger(RegParm);
-      ID.AddInteger(Required.getOpaqueData());
-      getReturnType().Profile(ID);
-      for (arg_iterator it = arg_begin(), ie = arg_end(); it != ie; ++it)
-        it->type.Profile(ID);
-    }
-    static void Profile(llvm::FoldingSetNodeID &ID,
-                        const FunctionType::ExtInfo &info,
-                        RequiredArgs required,
-                        CanQualType resultType,
-                        ArrayRef<CanQualType> argTypes) {
-      ID.AddInteger(info.getCC());
-      ID.AddBoolean(info.getNoReturn());
-      ID.AddBoolean(info.getProducesResult());
-      ID.AddBoolean(info.getHasRegParm());
-      ID.AddInteger(info.getRegParm());
-      ID.AddInteger(required.getOpaqueData());
-      resultType.Profile(ID);
-      for (ArrayRef<CanQualType>::iterator
-             i = argTypes.begin(), e = argTypes.end(); i != e; ++i) {
-        i->Profile(ID);
-      }
-    }
-  };
-  
-  /// ReturnValueSlot - Contains the address where the return value of a 
-  /// function can be stored, and whether the address is volatile or not.
-  class ReturnValueSlot {
-    llvm::PointerIntPair<llvm::Value *, 1, bool> Value;
-
-  public:
-    ReturnValueSlot() {}
-    ReturnValueSlot(llvm::Value *Value, bool IsVolatile)
-      : Value(Value, IsVolatile) {}
-
-    bool isNull() const { return !getValue(); }
-    
-    bool isVolatile() const { return Value.getInt(); }
-    llvm::Value *getValue() const { return Value.getPointer(); }
-  };
-  
-}  // end namespace CodeGen
-}  // end namespace clang
-
-#endif
Index: tools/clang/lib/CodeGen/CGValue.h
===================================================================
--- tools/clang/lib/CodeGen/CGValue.h	(revision 47284)
+++ tools/clang/lib/CodeGen/CGValue.h	(revision 47286)
@@ -1,452 +0,0 @@
-//===-- CGValue.h - LLVM CodeGen wrappers for llvm::Value* ------*- C++ -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// These classes implement wrappers around llvm::Value in order to
-// fully represent the range of values for C L- and R- values.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef CLANG_CODEGEN_CGVALUE_H
-#define CLANG_CODEGEN_CGVALUE_H
-
-#include "clang/AST/ASTContext.h"
-#include "clang/AST/CharUnits.h"
-#include "clang/AST/Type.h"
-
-namespace llvm {
-  class Constant;
-  class Value;
-}
-
-namespace clang {
-namespace CodeGen {
-  class AggValueSlot;
-  class CGBitFieldInfo;
-
-/// RValue - This trivial value class is used to represent the result of an
-/// expression that is evaluated.  It can be one of three things: either a
-/// simple LLVM SSA value, a pair of SSA values for complex numbers, or the
-/// address of an aggregate value in memory.
-class RValue {
-  enum Flavor { Scalar, Complex, Aggregate };
-
-  // Stores first value and flavor.
-  llvm::PointerIntPair<llvm::Value *, 2, Flavor> V1;
-  // Stores second value and volatility.
-  llvm::PointerIntPair<llvm::Value *, 1, bool> V2;
-
-public:
-  bool isScalar() const { return V1.getInt() == Scalar; }
-  bool isComplex() const { return V1.getInt() == Complex; }
-  bool isAggregate() const { return V1.getInt() == Aggregate; }
-
-  bool isVolatileQualified() const { return V2.getInt(); }
-
-  /// getScalarVal() - Return the Value* of this scalar value.
-  llvm::Value *getScalarVal() const {
-    assert(isScalar() && "Not a scalar!");
-    return V1.getPointer();
-  }
-
-  /// getComplexVal - Return the real/imag components of this complex value.
-  ///
-  std::pair<llvm::Value *, llvm::Value *> getComplexVal() const {
-    return std::make_pair(V1.getPointer(), V2.getPointer());
-  }
-
-  /// getAggregateAddr() - Return the Value* of the address of the aggregate.
-  llvm::Value *getAggregateAddr() const {
-    assert(isAggregate() && "Not an aggregate!");
-    return V1.getPointer();
-  }
-
-  static RValue get(llvm::Value *V) {
-    RValue ER;
-    ER.V1.setPointer(V);
-    ER.V1.setInt(Scalar);
-    ER.V2.setInt(false);
-    return ER;
-  }
-  static RValue getComplex(llvm::Value *V1, llvm::Value *V2) {
-    RValue ER;
-    ER.V1.setPointer(V1);
-    ER.V2.setPointer(V2);
-    ER.V1.setInt(Complex);
-    ER.V2.setInt(false);
-    return ER;
-  }
-  static RValue getComplex(const std::pair<llvm::Value *, llvm::Value *> &C) {
-    return getComplex(C.first, C.second);
-  }
-  // FIXME: Aggregate rvalues need to retain information about whether they are
-  // volatile or not.  Remove default to find all places that probably get this
-  // wrong.
-  static RValue getAggregate(llvm::Value *V, bool Volatile = false) {
-    RValue ER;
-    ER.V1.setPointer(V);
-    ER.V1.setInt(Aggregate);
-    ER.V2.setInt(Volatile);
-    return ER;
-  }
-};
-
-
-/// LValue - This represents an lvalue references.  Because C/C++ allow
-/// bitfields, this is not a simple LLVM pointer, it may be a pointer plus a
-/// bitrange.
-class LValue {
-  enum {
-    Simple,       // This is a normal l-value, use getAddress().
-    VectorElt,    // This is a vector element l-value (V[i]), use getVector*
-    BitField,     // This is a bitfield l-value, use getBitfield*.
-    ExtVectorElt  // This is an extended vector subset, use getExtVectorComp
-  } LVType;
-
-  llvm::Value *V;
-
-  union {
-    // Index into a vector subscript: V[i]
-    llvm::Value *VectorIdx;
-
-    // ExtVector element subset: V.xyx
-    llvm::Constant *VectorElts;
-
-    // BitField start bit and size
-    const CGBitFieldInfo *BitFieldInfo;
-  };
-
-  QualType Type;
-
-  // 'const' is unused here
-  Qualifiers Quals;
-
-  // The alignment to use when accessing this lvalue.  (For vector elements,
-  // this is the alignment of the whole vector.)
-  int64_t Alignment;
-
-  // objective-c's ivar
-  bool Ivar:1;
-  
-  // objective-c's ivar is an array
-  bool ObjIsArray:1;
-
-  // LValue is non-gc'able for any reason, including being a parameter or local
-  // variable.
-  bool NonGC: 1;
-
-  // Lvalue is a global reference of an objective-c object
-  bool GlobalObjCRef : 1;
-  
-  // Lvalue is a thread local reference
-  bool ThreadLocalRef : 1;
-
-  Expr *BaseIvarExp;
-
-  /// TBAAInfo - TBAA information to attach to dereferences of this LValue.
-  llvm::MDNode *TBAAInfo;
-
-private:
-  void Initialize(QualType Type, Qualifiers Quals,
-                  CharUnits Alignment,
-                  llvm::MDNode *TBAAInfo = 0) {
-    this->Type = Type;
-    this->Quals = Quals;
-    this->Alignment = Alignment.getQuantity();
-    assert(this->Alignment == Alignment.getQuantity() &&
-           "Alignment exceeds allowed max!");
-
-    // Initialize Objective-C flags.
-    this->Ivar = this->ObjIsArray = this->NonGC = this->GlobalObjCRef = false;
-    this->ThreadLocalRef = false;
-    this->BaseIvarExp = 0;
-    this->TBAAInfo = TBAAInfo;
-  }
-
-public:
-  bool isSimple() const { return LVType == Simple; }
-  bool isVectorElt() const { return LVType == VectorElt; }
-  bool isBitField() const { return LVType == BitField; }
-  bool isExtVectorElt() const { return LVType == ExtVectorElt; }
-
-  bool isVolatileQualified() const { return Quals.hasVolatile(); }
-  bool isRestrictQualified() const { return Quals.hasRestrict(); }
-  unsigned getVRQualifiers() const {
-    return Quals.getCVRQualifiers() & ~Qualifiers::Const;
-  }
-
-  QualType getType() const { return Type; }
-
-  Qualifiers::ObjCLifetime getObjCLifetime() const {
-    return Quals.getObjCLifetime();
-  }
-
-  bool isObjCIvar() const { return Ivar; }
-  void setObjCIvar(bool Value) { Ivar = Value; }
-
-  bool isObjCArray() const { return ObjIsArray; }
-  void setObjCArray(bool Value) { ObjIsArray = Value; }
-
-  bool isNonGC () const { return NonGC; }
-  void setNonGC(bool Value) { NonGC = Value; }
-
-  bool isGlobalObjCRef() const { return GlobalObjCRef; }
-  void setGlobalObjCRef(bool Value) { GlobalObjCRef = Value; }
-
-  bool isThreadLocalRef() const { return ThreadLocalRef; }
-  void setThreadLocalRef(bool Value) { ThreadLocalRef = Value;}
-
-  bool isObjCWeak() const {
-    return Quals.getObjCGCAttr() == Qualifiers::Weak;
-  }
-  bool isObjCStrong() const {
-    return Quals.getObjCGCAttr() == Qualifiers::Strong;
-  }
-
-  bool isVolatile() const {
-    return Quals.hasVolatile();
-  }
-  
-  Expr *getBaseIvarExp() const { return BaseIvarExp; }
-  void setBaseIvarExp(Expr *V) { BaseIvarExp = V; }
-
-  llvm::MDNode *getTBAAInfo() const { return TBAAInfo; }
-  void setTBAAInfo(llvm::MDNode *N) { TBAAInfo = N; }
-
-  const Qualifiers &getQuals() const { return Quals; }
-  Qualifiers &getQuals() { return Quals; }
-
-  unsigned getAddressSpace() const { return Quals.getAddressSpace(); }
-
-  CharUnits getAlignment() const { return CharUnits::fromQuantity(Alignment); }
-  void setAlignment(CharUnits A) { Alignment = A.getQuantity(); }
-
-  // simple lvalue
-  llvm::Value *getAddress() const { assert(isSimple()); return V; }
-  void setAddress(llvm::Value *address) {
-    assert(isSimple());
-    V = address;
-  }
-
-  // vector elt lvalue
-  llvm::Value *getVectorAddr() const { assert(isVectorElt()); return V; }
-  llvm::Value *getVectorIdx() const { assert(isVectorElt()); return VectorIdx; }
-
-  // extended vector elements.
-  llvm::Value *getExtVectorAddr() const { assert(isExtVectorElt()); return V; }
-  llvm::Constant *getExtVectorElts() const {
-    assert(isExtVectorElt());
-    return VectorElts;
-  }
-
-  // bitfield lvalue
-  llvm::Value *getBitFieldBaseAddr() const {
-    assert(isBitField());
-    return V;
-  }
-  const CGBitFieldInfo &getBitFieldInfo() const {
-    assert(isBitField());
-    return *BitFieldInfo;
-  }
-
-  static LValue MakeAddr(llvm::Value *address, QualType type,
-                         CharUnits alignment, ASTContext &Context,
-                         llvm::MDNode *TBAAInfo = 0) {
-    Qualifiers qs = type.getQualifiers();
-    qs.setObjCGCAttr(Context.getObjCGCAttrKind(type));
-
-    LValue R;
-    R.LVType = Simple;
-    R.V = address;
-    R.Initialize(type, qs, alignment, TBAAInfo);
-    return R;
-  }
-
-  static LValue MakeVectorElt(llvm::Value *Vec, llvm::Value *Idx,
-                              QualType type, CharUnits Alignment) {
-    LValue R;
-    R.LVType = VectorElt;
-    R.V = Vec;
-    R.VectorIdx = Idx;
-    R.Initialize(type, type.getQualifiers(), Alignment);
-    return R;
-  }
-
-  static LValue MakeExtVectorElt(llvm::Value *Vec, llvm::Constant *Elts,
-                                 QualType type, CharUnits Alignment) {
-    LValue R;
-    R.LVType = ExtVectorElt;
-    R.V = Vec;
-    R.VectorElts = Elts;
-    R.Initialize(type, type.getQualifiers(), Alignment);
-    return R;
-  }
-
-  /// \brief Create a new object to represent a bit-field access.
-  ///
-  /// \param BaseValue - The base address of the structure containing the
-  /// bit-field.
-  /// \param Info - The information describing how to perform the bit-field
-  /// access.
-  static LValue MakeBitfield(llvm::Value *BaseValue,
-                             const CGBitFieldInfo &Info,
-                             QualType type, CharUnits Alignment) {
-    LValue R;
-    R.LVType = BitField;
-    R.V = BaseValue;
-    R.BitFieldInfo = &Info;
-    R.Initialize(type, type.getQualifiers(), Alignment);
-    return R;
-  }
-
-  RValue asAggregateRValue() const {
-    // FIMXE: Alignment
-    return RValue::getAggregate(getAddress(), isVolatileQualified());
-  }
-};
-
-/// An aggregate value slot.
-class AggValueSlot {
-  /// The address.
-  llvm::Value *Addr;
-
-  // Qualifiers
-  Qualifiers Quals;
-
-  unsigned short Alignment;
-
-  /// DestructedFlag - This is set to true if some external code is
-  /// responsible for setting up a destructor for the slot.  Otherwise
-  /// the code which constructs it should push the appropriate cleanup.
-  bool DestructedFlag : 1;
-
-  /// ObjCGCFlag - This is set to true if writing to the memory in the
-  /// slot might require calling an appropriate Objective-C GC
-  /// barrier.  The exact interaction here is unnecessarily mysterious.
-  bool ObjCGCFlag : 1;
-  
-  /// ZeroedFlag - This is set to true if the memory in the slot is
-  /// known to be zero before the assignment into it.  This means that
-  /// zero fields don't need to be set.
-  bool ZeroedFlag : 1;
-
-  /// AliasedFlag - This is set to true if the slot might be aliased
-  /// and it's not undefined behavior to access it through such an
-  /// alias.  Note that it's always undefined behavior to access a C++
-  /// object that's under construction through an alias derived from
-  /// outside the construction process.
-  ///
-  /// This flag controls whether calls that produce the aggregate
-  /// value may be evaluated directly into the slot, or whether they
-  /// must be evaluated into an unaliased temporary and then memcpy'ed
-  /// over.  Since it's invalid in general to memcpy a non-POD C++
-  /// object, it's important that this flag never be set when
-  /// evaluating an expression which constructs such an object.
-  bool AliasedFlag : 1;
-
-public:
-  enum IsAliased_t { IsNotAliased, IsAliased };
-  enum IsDestructed_t { IsNotDestructed, IsDestructed };
-  enum IsZeroed_t { IsNotZeroed, IsZeroed };
-  enum NeedsGCBarriers_t { DoesNotNeedGCBarriers, NeedsGCBarriers };
-
-  /// ignored - Returns an aggregate value slot indicating that the
-  /// aggregate value is being ignored.
-  static AggValueSlot ignored() {
-    return forAddr(0, CharUnits(), Qualifiers(), IsNotDestructed,
-                   DoesNotNeedGCBarriers, IsNotAliased);
-  }
-
-  /// forAddr - Make a slot for an aggregate value.
-  ///
-  /// \param quals - The qualifiers that dictate how the slot should
-  /// be initialied. Only 'volatile' and the Objective-C lifetime
-  /// qualifiers matter.
-  ///
-  /// \param isDestructed - true if something else is responsible
-  ///   for calling destructors on this object
-  /// \param needsGC - true if the slot is potentially located
-  ///   somewhere that ObjC GC calls should be emitted for
-  static AggValueSlot forAddr(llvm::Value *addr, CharUnits align,
-                              Qualifiers quals,
-                              IsDestructed_t isDestructed,
-                              NeedsGCBarriers_t needsGC,
-                              IsAliased_t isAliased,
-                              IsZeroed_t isZeroed = IsNotZeroed) {
-    AggValueSlot AV;
-    AV.Addr = addr;
-    AV.Alignment = align.getQuantity();
-    AV.Quals = quals;
-    AV.DestructedFlag = isDestructed;
-    AV.ObjCGCFlag = needsGC;
-    AV.ZeroedFlag = isZeroed;
-    AV.AliasedFlag = isAliased;
-    return AV;
-  }
-
-  static AggValueSlot forLValue(const LValue &LV,
-                                IsDestructed_t isDestructed,
-                                NeedsGCBarriers_t needsGC,
-                                IsAliased_t isAliased,
-                                IsZeroed_t isZeroed = IsNotZeroed) {
-    return forAddr(LV.getAddress(), LV.getAlignment(),
-                   LV.getQuals(), isDestructed, needsGC, isAliased, isZeroed);
-  }
-
-  IsDestructed_t isExternallyDestructed() const {
-    return IsDestructed_t(DestructedFlag);
-  }
-  void setExternallyDestructed(bool destructed = true) {
-    DestructedFlag = destructed;
-  }
-
-  Qualifiers getQualifiers() const { return Quals; }
-
-  bool isVolatile() const {
-    return Quals.hasVolatile();
-  }
-
-  Qualifiers::ObjCLifetime getObjCLifetime() const {
-    return Quals.getObjCLifetime();
-  }
-
-  NeedsGCBarriers_t requiresGCollection() const {
-    return NeedsGCBarriers_t(ObjCGCFlag);
-  }
-  
-  llvm::Value *getAddr() const {
-    return Addr;
-  }
-
-  bool isIgnored() const {
-    return Addr == 0;
-  }
-
-  CharUnits getAlignment() const {
-    return CharUnits::fromQuantity(Alignment);
-  }
-
-  IsAliased_t isPotentiallyAliased() const {
-    return IsAliased_t(AliasedFlag);
-  }
-
-  // FIXME: Alignment?
-  RValue asRValue() const {
-    return RValue::getAggregate(getAddr(), isVolatile());
-  }
-
-  void setZeroed(bool V = true) { ZeroedFlag = V; }
-  IsZeroed_t isZeroed() const {
-    return IsZeroed_t(ZeroedFlag);
-  }
-};
-
-}  // end namespace CodeGen
-}  // end namespace clang
-
-#endif
Index: tools/clang/lib/CodeGen/CGObjCGNU.cpp
===================================================================
--- tools/clang/lib/CodeGen/CGObjCGNU.cpp	(revision 47284)
+++ tools/clang/lib/CodeGen/CGObjCGNU.cpp	(revision 47286)
@@ -15,7 +15,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "CGObjCRuntime.h"
-#include "CodeGenModule.h"
+#include "clang/CodeGen/CodeGenModule.h"
 #include "CodeGenFunction.h"
 #include "CGCleanup.h"
 #include "clang/AST/ASTContext.h"
Index: tools/clang/lib/CodeGen/CGStmt.cpp
===================================================================
--- tools/clang/lib/CodeGen/CGStmt.cpp	(revision 47284)
+++ tools/clang/lib/CodeGen/CGStmt.cpp	(revision 47286)
@@ -12,7 +12,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "CGDebugInfo.h"
-#include "CodeGenModule.h"
+#include "clang/CodeGen/CodeGenModule.h"
 #include "CodeGenFunction.h"
 #include "TargetInfo.h"
 #include "clang/AST/StmtVisitor.h"
Index: tools/clang/lib/CodeGen/CGExprConstant.cpp
===================================================================
--- tools/clang/lib/CodeGen/CGExprConstant.cpp	(revision 47284)
+++ tools/clang/lib/CodeGen/CGExprConstant.cpp	(revision 47286)
@@ -12,7 +12,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "CodeGenFunction.h"
-#include "CodeGenModule.h"
+#include "clang/CodeGen/CodeGenModule.h"
 #include "CGCXXABI.h"
 #include "CGObjCRuntime.h"
 #include "CGRecordLayout.h"
Index: tools/clang/lib/CodeGen/MicrosoftCXXABI.cpp
===================================================================
--- tools/clang/lib/CodeGen/MicrosoftCXXABI.cpp	(revision 47284)
+++ tools/clang/lib/CodeGen/MicrosoftCXXABI.cpp	(revision 47286)
@@ -15,7 +15,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "CGCXXABI.h"
-#include "CodeGenModule.h"
+#include "clang/CodeGen/CodeGenModule.h"
 #include "clang/AST/Decl.h"
 #include "clang/AST/DeclCXX.h"
 
Index: tools/clang/lib/CodeGen/ItaniumCXXABI.cpp
===================================================================
--- tools/clang/lib/CodeGen/ItaniumCXXABI.cpp	(revision 47284)
+++ tools/clang/lib/CodeGen/ItaniumCXXABI.cpp	(revision 47286)
@@ -20,9 +20,9 @@
 
 #include "CGCXXABI.h"
 #include "CGRecordLayout.h"
-#include "CGVTables.h"
+#include "clang/CodeGen/CGVTables.h"
 #include "CodeGenFunction.h"
-#include "CodeGenModule.h"
+#include "clang/CodeGen/CodeGenModule.h"
 #include "clang/AST/Mangle.h"
 #include "clang/AST/Type.h"
 #include "llvm/Intrinsics.h"
Index: tools/clang/lib/CodeGen/CGObjCMac.cpp
===================================================================
--- tools/clang/lib/CodeGen/CGObjCMac.cpp	(revision 47284)
+++ tools/clang/lib/CodeGen/CGObjCMac.cpp	(revision 47286)
@@ -14,7 +14,7 @@
 #include "CGObjCRuntime.h"
 
 #include "CGRecordLayout.h"
-#include "CodeGenModule.h"
+#include "clang/CodeGen/CodeGenModule.h"
 #include "CodeGenFunction.h"
 #include "CGBlocks.h"
 #include "CGCleanup.h"
Index: tools/clang/lib/CodeGen/CodeGenFunction.cpp
===================================================================
--- tools/clang/lib/CodeGen/CodeGenFunction.cpp	(revision 47284)
+++ tools/clang/lib/CodeGen/CodeGenFunction.cpp	(revision 47286)
@@ -12,7 +12,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "CodeGenFunction.h"
-#include "CodeGenModule.h"
+#include "clang/CodeGen/CodeGenModule.h"
 #include "CGCUDARuntime.h"
 #include "CGCXXABI.h"
 #include "CGDebugInfo.h"
Index: tools/clang/lib/CodeGen/CGCXX.cpp
===================================================================
--- tools/clang/lib/CodeGen/CGCXX.cpp	(revision 47284)
+++ tools/clang/lib/CodeGen/CGCXX.cpp	(revision 47286)
@@ -15,7 +15,7 @@
 
 #include "CGCXXABI.h"
 #include "CodeGenFunction.h"
-#include "CodeGenModule.h"
+#include "clang/CodeGen/CodeGenModule.h"
 #include "clang/AST/ASTContext.h"
 #include "clang/AST/RecordLayout.h"
 #include "clang/AST/Decl.h"
Index: tools/clang/lib/CodeGen/CGExprScalar.cpp
===================================================================
--- tools/clang/lib/CodeGen/CGExprScalar.cpp	(revision 47284)
+++ tools/clang/lib/CodeGen/CGExprScalar.cpp	(revision 47286)
@@ -15,7 +15,7 @@
 #include "CodeGenFunction.h"
 #include "CGCXXABI.h"
 #include "CGObjCRuntime.h"
-#include "CodeGenModule.h"
+#include "clang/CodeGen/CodeGenModule.h"
 #include "CGDebugInfo.h"
 #include "clang/AST/ASTContext.h"
 #include "clang/AST/DeclObjC.h"
Index: tools/clang/lib/CodeGen/CGExprComplex.cpp
===================================================================
--- tools/clang/lib/CodeGen/CGExprComplex.cpp	(revision 47284)
+++ tools/clang/lib/CodeGen/CGExprComplex.cpp	(revision 47286)
@@ -12,7 +12,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "CodeGenFunction.h"
-#include "CodeGenModule.h"
+#include "clang/CodeGen/CodeGenModule.h"
 #include "clang/AST/ASTContext.h"
 #include "clang/AST/StmtVisitor.h"
 #include "llvm/Constants.h"
Index: tools/clang/lib/CodeGen/CGVTT.cpp
===================================================================
--- tools/clang/lib/CodeGen/CGVTT.cpp	(revision 47284)
+++ tools/clang/lib/CodeGen/CGVTT.cpp	(revision 47286)
@@ -11,7 +11,7 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "CodeGenModule.h"
+#include "clang/CodeGen/CodeGenModule.h"
 #include "CGCXXABI.h"
 #include "clang/AST/RecordLayout.h"
 #include "clang/AST/VTTBuilder.h"
Index: tools/clang/lib/CodeGen/CGObjC.cpp
===================================================================
--- tools/clang/lib/CodeGen/CGObjC.cpp	(revision 47284)
+++ tools/clang/lib/CodeGen/CGObjC.cpp	(revision 47286)
@@ -14,7 +14,7 @@
 #include "CGDebugInfo.h"
 #include "CGObjCRuntime.h"
 #include "CodeGenFunction.h"
-#include "CodeGenModule.h"
+#include "clang/CodeGen/CodeGenModule.h"
 #include "TargetInfo.h"
 #include "clang/AST/ASTContext.h"
 #include "clang/AST/DeclObjC.h"
Index: tools/clang/lib/CodeGen/CGExpr.cpp
===================================================================
--- tools/clang/lib/CodeGen/CGExpr.cpp	(revision 47284)
+++ tools/clang/lib/CodeGen/CGExpr.cpp	(revision 47286)
@@ -12,8 +12,8 @@
 //===----------------------------------------------------------------------===//
 
 #include "CodeGenFunction.h"
-#include "CodeGenModule.h"
-#include "CGCall.h"
+#include "clang/CodeGen/CodeGenModule.h"
+#include "clang/CodeGen/CGCall.h"
 #include "CGCXXABI.h"
 #include "CGDebugInfo.h"
 #include "CGRecordLayout.h"
Index: tools/clang/lib/CodeGen/CodeGenTypes.cpp
===================================================================
--- tools/clang/lib/CodeGen/CodeGenTypes.cpp	(revision 47284)
+++ tools/clang/lib/CodeGen/CodeGenTypes.cpp	(revision 47286)
@@ -11,8 +11,8 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "CodeGenTypes.h"
-#include "CGCall.h"
+#include "clang/CodeGen/CodeGenTypes.h"
+#include "clang/CodeGen/CGCall.h"
 #include "CGCXXABI.h"
 #include "CGRecordLayout.h"
 #include "TargetInfo.h"
Index: tools/clang/lib/CodeGen/CGCUDARuntime.cpp
===================================================================
--- tools/clang/lib/CodeGen/CGCUDARuntime.cpp	(revision 47284)
+++ tools/clang/lib/CodeGen/CGCUDARuntime.cpp	(revision 47286)
@@ -16,7 +16,7 @@
 #include "CGCUDARuntime.h"
 #include "clang/AST/Decl.h"
 #include "clang/AST/ExprCXX.h"
-#include "CGCall.h"
+#include "clang/CodeGen/CGCall.h"
 #include "CodeGenFunction.h"
 
 using namespace clang;
Index: tools/clang/lib/CodeGen/CGRTTI.cpp
===================================================================
--- tools/clang/lib/CodeGen/CGRTTI.cpp	(revision 47284)
+++ tools/clang/lib/CodeGen/CGRTTI.cpp	(revision 47286)
@@ -11,7 +11,7 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "CodeGenModule.h"
+#include "clang/CodeGen/CodeGenModule.h"
 #include "CGCXXABI.h"
 #include "clang/AST/RecordLayout.h"
 #include "clang/AST/Type.h"
Index: tools/clang/lib/CodeGen/CGBlocks.h
===================================================================
--- tools/clang/lib/CodeGen/CGBlocks.h	(revision 47284)
+++ tools/clang/lib/CodeGen/CGBlocks.h	(revision 47286)
@@ -14,7 +14,7 @@
 #ifndef CLANG_CODEGEN_CGBLOCKS_H
 #define CLANG_CODEGEN_CGBLOCKS_H
 
-#include "CodeGenTypes.h"
+#include "clang/CodeGen/CodeGenTypes.h"
 #include "clang/AST/Type.h"
 #include "llvm/Module.h"
 #include "clang/Basic/TargetInfo.h"
@@ -25,8 +25,8 @@
 
 #include "CodeGenFunction.h"
 #include "CGBuilder.h"
-#include "CGCall.h"
-#include "CGValue.h"
+#include "clang/CodeGen/CGCall.h"
+#include "clang/CodeGen/CGValue.h"
 
 namespace llvm {
   class Module;
Index: tools/clang/lib/CodeGen/CGObjCRuntime.h
===================================================================
--- tools/clang/lib/CodeGen/CGObjCRuntime.h	(revision 47284)
+++ tools/clang/lib/CodeGen/CGObjCRuntime.h	(revision 47286)
@@ -19,8 +19,8 @@
 #include "clang/AST/DeclObjC.h"
 
 #include "CGBuilder.h"
-#include "CGCall.h"
-#include "CGValue.h"
+#include "clang/CodeGen/CGCall.h"
+#include "clang/CodeGen/CGValue.h"
 
 namespace llvm {
   class Constant;
Index: tools/clang/lib/CodeGen/TargetInfo.cpp
===================================================================
--- tools/clang/lib/CodeGen/TargetInfo.cpp	(revision 47284)
+++ tools/clang/lib/CodeGen/TargetInfo.cpp	(revision 47286)
@@ -13,7 +13,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "TargetInfo.h"
-#include "ABIInfo.h"
+#include "clang/CodeGen/ABIInfo.h"
 #include "CodeGenFunction.h"
 #include "clang/AST/RecordLayout.h"
 #include "clang/Frontend/CodeGenOptions.h"
Index: tools/clang/lib/CodeGen/CGExprAgg.cpp
===================================================================
--- tools/clang/lib/CodeGen/CGExprAgg.cpp	(revision 47284)
+++ tools/clang/lib/CodeGen/CGExprAgg.cpp	(revision 47286)
@@ -12,7 +12,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "CodeGenFunction.h"
-#include "CodeGenModule.h"
+#include "clang/CodeGen/CodeGenModule.h"
 #include "CGObjCRuntime.h"
 #include "clang/AST/ASTContext.h"
 #include "clang/AST/DeclCXX.h"
Index: tools/clang/lib/CodeGen/CGVTables.cpp
===================================================================
--- tools/clang/lib/CodeGen/CGVTables.cpp	(revision 47284)
+++ tools/clang/lib/CodeGen/CGVTables.cpp	(revision 47286)
@@ -11,7 +11,7 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "CodeGenModule.h"
+#include "clang/CodeGen/CodeGenModule.h"
 #include "CodeGenFunction.h"
 #include "CGCXXABI.h"
 #include "clang/AST/CXXInheritance.h"
Index: tools/clang/lib/CodeGen/CodeGenModule.cpp
===================================================================
--- tools/clang/lib/CodeGen/CodeGenModule.cpp	(revision 47284)
+++ tools/clang/lib/CodeGen/CodeGenModule.cpp	(revision 47286)
@@ -11,11 +11,11 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "CodeGenModule.h"
+#include "clang/CodeGen/CodeGenModule.h"
 #include "CGDebugInfo.h"
 #include "CodeGenFunction.h"
 #include "CodeGenTBAA.h"
-#include "CGCall.h"
+#include "clang/CodeGen/CGCall.h"
 #include "CGCUDARuntime.h"
 #include "CGCXXABI.h"
 #include "CGObjCRuntime.h"
Index: tools/clang/lib/CodeGen/CGDebugInfo.cpp
===================================================================
--- tools/clang/lib/CodeGen/CGDebugInfo.cpp	(revision 47284)
+++ tools/clang/lib/CodeGen/CGDebugInfo.cpp	(revision 47286)
@@ -13,7 +13,7 @@
 
 #include "CGDebugInfo.h"
 #include "CodeGenFunction.h"
-#include "CodeGenModule.h"
+#include "clang/CodeGen/CodeGenModule.h"
 #include "CGBlocks.h"
 #include "clang/AST/ASTContext.h"
 #include "clang/AST/DeclFriend.h"
Index: tools/clang/lib/CodeGen/CodeGenFunction.h
===================================================================
--- tools/clang/lib/CodeGen/CodeGenFunction.h	(revision 47284)
+++ tools/clang/lib/CodeGen/CodeGenFunction.h	(revision 47286)
@@ -26,10 +26,10 @@
 #include "llvm/ADT/SmallVector.h"
 #include "llvm/Support/ValueHandle.h"
 #include "llvm/Support/Debug.h"
-#include "CodeGenModule.h"
+#include "clang/CodeGen/CodeGenModule.h"
 #include "CGBuilder.h"
 #include "CGDebugInfo.h"
-#include "CGValue.h"
+#include "clang/CodeGen/CGValue.h"
 
 namespace llvm {
   class BasicBlock;
Index: tools/clang/lib/CodeGen/CGBuiltin.cpp
===================================================================
--- tools/clang/lib/CodeGen/CGBuiltin.cpp	(revision 47284)
+++ tools/clang/lib/CodeGen/CGBuiltin.cpp	(revision 47286)
@@ -13,7 +13,7 @@
 
 #include "TargetInfo.h"
 #include "CodeGenFunction.h"
-#include "CodeGenModule.h"
+#include "clang/CodeGen/CodeGenModule.h"
 #include "CGObjCRuntime.h"
 #include "clang/Basic/TargetInfo.h"
 #include "clang/AST/ASTContext.h"
Index: tools/clang/lib/CodeGen/CGDecl.cpp
===================================================================
--- tools/clang/lib/CodeGen/CGDecl.cpp	(revision 47284)
+++ tools/clang/lib/CodeGen/CGDecl.cpp	(revision 47286)
@@ -13,7 +13,7 @@
 
 #include "CGDebugInfo.h"
 #include "CodeGenFunction.h"
-#include "CodeGenModule.h"
+#include "clang/CodeGen/CodeGenModule.h"
 #include "CGOpenCLRuntime.h"
 #include "clang/AST/ASTContext.h"
 #include "clang/AST/CharUnits.h"
Index: tools/clang/lib/CodeGen/CGCall.cpp
===================================================================
--- tools/clang/lib/CodeGen/CGCall.cpp	(revision 47284)
+++ tools/clang/lib/CodeGen/CGCall.cpp	(revision 47286)
@@ -12,11 +12,11 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "CGCall.h"
+#include "clang/CodeGen/CGCall.h"
 #include "CGCXXABI.h"
-#include "ABIInfo.h"
+#include "clang/CodeGen/ABIInfo.h"
 #include "CodeGenFunction.h"
-#include "CodeGenModule.h"
+#include "clang/CodeGen/CodeGenModule.h"
 #include "TargetInfo.h"
 #include "clang/Basic/TargetInfo.h"
 #include "clang/AST/Decl.h"
Index: tools/clang/lib/CodeGen/CGBlocks.cpp
===================================================================
--- tools/clang/lib/CodeGen/CGBlocks.cpp	(revision 47284)
+++ tools/clang/lib/CodeGen/CGBlocks.cpp	(revision 47286)
@@ -14,7 +14,7 @@
 #include "CGDebugInfo.h"
 #include "CodeGenFunction.h"
 #include "CGObjCRuntime.h"
-#include "CodeGenModule.h"
+#include "clang/CodeGen/CodeGenModule.h"
 #include "CGBlocks.h"
 #include "clang/AST/DeclObjC.h"
 #include "llvm/Module.h"
Index: tools/clang/lib/CodeGen/CGCUDANV.cpp
===================================================================
--- tools/clang/lib/CodeGen/CGCUDANV.cpp	(revision 47284)
+++ tools/clang/lib/CodeGen/CGCUDANV.cpp	(revision 47286)
@@ -14,7 +14,7 @@
 
 #include "CGCUDARuntime.h"
 #include "CodeGenFunction.h"
-#include "CodeGenModule.h"
+#include "clang/CodeGen/CodeGenModule.h"
 #include "clang/AST/Decl.h"
 #include "llvm/BasicBlock.h"
 #include "llvm/Constants.h"
Index: tools/clang/lib/CodeGen/CGObjCRuntime.cpp
===================================================================
--- tools/clang/lib/CodeGen/CGObjCRuntime.cpp	(revision 47284)
+++ tools/clang/lib/CodeGen/CGObjCRuntime.cpp	(revision 47286)
@@ -16,7 +16,7 @@
 #include "CGObjCRuntime.h"
 
 #include "CGRecordLayout.h"
-#include "CodeGenModule.h"
+#include "clang/CodeGen/CodeGenModule.h"
 #include "CodeGenFunction.h"
 #include "CGCleanup.h"
 
Index: tools/clang/lib/CodeGen/ModuleBuilder.cpp
===================================================================
--- tools/clang/lib/CodeGen/ModuleBuilder.cpp	(revision 47284)
+++ tools/clang/lib/CodeGen/ModuleBuilder.cpp	(revision 47286)
@@ -12,7 +12,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "clang/CodeGen/ModuleBuilder.h"
-#include "CodeGenModule.h"
+#include "clang/CodeGen/CodeGenModule.h"
 #include "clang/Frontend/CodeGenOptions.h"
 #include "clang/AST/ASTContext.h"
 #include "clang/AST/DeclObjC.h"
@@ -49,6 +49,10 @@
       return M.take();
     }
 
+    virtual CodeGen::CodeGenModule* GetBuilder() {
+      return Builder.get();
+    }
+
     virtual void Initialize(ASTContext &Context) {
       Ctx = &Context;
 
Index: tools/clang/lib/CodeGen/CGRecordLayoutBuilder.cpp
===================================================================
--- tools/clang/lib/CodeGen/CGRecordLayoutBuilder.cpp	(revision 47284)
+++ tools/clang/lib/CodeGen/CGRecordLayoutBuilder.cpp	(revision 47286)
@@ -19,7 +19,7 @@
 #include "clang/AST/Expr.h"
 #include "clang/AST/RecordLayout.h"
 #include "clang/Frontend/CodeGenOptions.h"
-#include "CodeGenTypes.h"
+#include "clang/CodeGen/CodeGenTypes.h"
 #include "CGCXXABI.h"
 #include "llvm/DerivedTypes.h"
 #include "llvm/Type.h"
