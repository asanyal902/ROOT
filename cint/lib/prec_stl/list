// lib/prec_stl/list

#pragma ifndef PREC_STL_LIST
#pragma define PREC_STL_LIST
#pragma link off global PREC_STL_LIST;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

// Imported from ANSI/ISO C++ 1997/Nov draft 
// Got some ideas from Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab

#include <iterator>
#include <memory>

#if defined(G__GNUC)
template<class T,class Allocator=alloc>
#elif defined(G__HPUX)
template<class T,class Allocator=allocator>
#else
template<class T,class Allocator=allocator<T> >
#endif
class list {
 public:
  typedef T value_type;
  typedef Allocator allocator_type;
#if defined(G__GNUC) || defined(G__HPUX)
  typedef void* void_pointer;
  //typedef __list_node<T> list_node;
  //typedef simple_alloc<list_node, Alloc> list_node_allocator;
  //typedef list_node* link_type;
  typedef value_type* pointer;
  typedef const value_type* const_pointer;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
#else
  typedef typename Allocator::pointer               pointer;
  typedef typename Allocator::const_pointer         const_pointer;
  typedef typename Allocator::reference             reference;
  typedef typename Allocator::const_reference       const_reference;
  typedef typename Allocator::size_type             size_type;
  typedef typename Allocator::difference_type       difference_type;
#endif

  class iterator 
#if defined(G__VISUAL)
    	: public _Bidit<T,difference_type> 
#elif !defined(G__SUNPRO_C)
  	: public bidirectional_iterator<T,difference_type> 
#endif
	{
   public:
    iterator() ;
    iterator(const iterator& x) ;
#if !defined(G__BORLAND) && !defined(G__KCC)
    iterator& operator=(const iterator& x) ;
#endif
    T& operator*() const ;
    iterator& operator++();
    iterator operator++(int a);
    iterator& operator--();
    iterator operator--(int a);
    bool operator==(const iterator& x) ;
#ifndef G__HPUX
    bool operator!=(const iterator& x) ;
#endif
  };
#ifdef G__HPUX
  friend bool operator!=(const list::iterator& x,const list::iterator& y)const;
#endif

#if 0
  typedef reverse_iterator<iterator> reverse_iterator;
#else
  class reverse_iterator 
#if defined(G__VISUAL)
	: public _Bidit<T,difference_type> 
#elif !defined(G__SUNPRO_C)
  	: public bidirectional_iterator<T,difference_type> 
#endif
	{
   public:
    reverse_iterator(const reverse_iterator& x) ;
#if !defined(G__BORLAND) && !defined(G__KCC)
    reverse_iterator& operator=(const reverse_iterator& x) ;
#endif
    T& operator*() const ;
    reverse_iterator& operator++();
    reverse_iterator operator++(int a);
    reverse_iterator& operator--();
    reverse_iterator operator--(int a);
   private:
  };
#endif
  friend bool operator==(const list::reverse_iterator& x
                        ,const list::reverse_iterator& y) const;
  friend bool operator!=(const list::reverse_iterator& x
                        ,const list::reverse_iterator& y) const;

  typedef const iterator const_iterator;
  typedef const reverse_iterator const_reverse_iterator;

#if 0
  friend bidirectional_iterator_tag 
    iterator_category(bidirectional_iterator<T,distance_type>& x);
  //friend bidirectional_iterator_tag 
  //  iterator_category(list::iterator& x);
  //friend bidirectional_iterator_tag 
  //  iterator_category(list::reverse_iterator& x);
#endif

  list() ;
  iterator begin() ;
  iterator end() ;
  reverse_iterator rbegin() ;
  reverse_iterator rend() ;
#ifdef G__CONSTNESSFLAG
  const_iterator begin(void) const;
  const_iterator end(void) const;
  const_reverse_iterator rbegin(void) const;
  const_reverse_iterator rend(void) const;
#endif
  bool empty() const ;
  size_type size() const ;
  size_type max_size() const ;
  T& front() const ;
  T& back() const ;
  void swap(list& x) ;
  iterator insert(iterator position,const T& x);
  void insert(iterator position,T* first,T* last);
  void insert(iterator position,iterator first,iterator last);
  void insert(iterator position,size_type n,const T& x);
  void push_front(const T& x);
  void push_back(const T& x);
  void erase(iterator position);
  void erase(iterator first,iterator last);
  void pop_front();
  void pop_back();
  list(size_type n,const T& value=T()) ;
#if 0
  template <class InputIterator>
    deque(InputIterator first, InputIterator last,
         const Allocator& = Allocator());
#else
#if defined(G__GNUC)
  list(const T* first,const T* last) ;
#endif
  list(const_iterator first, const_iterator last) ;
#endif
  list(const list& x) ;
  ~list() ;
  list& operator=(const list& x) ;
  void splice(iterator position,list& x);
  void splice(iterator position,list& x,iterator i);
  void splice(iterator position,list& x,iterator first,iterator last);
  void remove(const T& value);
  void unique();
  void merge(list& x);
  void reverse();
  void sort();

  friend bool operator==(const list& x, const list& y);
  friend bool operator< (const list& x, const list& y);
  friend bool operator!=(const list& x, const list& y);
  friend bool operator> (const list& x, const list& y);
  friend bool operator>=(const list& x, const list& y);
  friend bool operator<=(const list& x, const list& y);

  // specialized algorithms:
#ifndef G__GNUC
  // doesn't work on egcs nor VC++5.0
  //friend void swap(list& x, list& y);
#endif


  // Generic algorithm
  friend void reverse(list::iterator first,list::iterator last);
  //friend void reverse(list::reverse_iterator first,list::reverse_itetator last);


  // iterator_category resolution
  //friend bidirectional_iterator_tag iterator_category(list::iterator x);
};

#pragma endif

