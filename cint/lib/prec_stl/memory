// lib/prec_stl/memory

#pragma ifndef PREC_STL_MEMORY
#pragma define PREC_STL_MEMORY
#pragma link off global PREC_STL_MEMORY;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

// Implemented by Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab

#include <stddef.h>

#if defined(G__ANSIISOLIB)
#undef G__GNUC
#undef G__HPUX
#endif

//////////////////////////////////////////////////////////////////////
#if defined(G__GNUC)

template <int inst>
class __malloc_alloc_template {
 public:
  static void * allocate(size_t n);
  static void deallocate(void *p, size_t /* n */);
  static void * reallocate(void *p, size_t /* old_sz */, size_t new_sz);
#if (G__GNUC >= 3) || ((G__GNUC == 2) && (G__GNUC_MINOR >= 95))
  static void (* __set_malloc_handler(void (*f)()))();
#else
  static void (* set_malloc_handler(void (*f)()))();
#endif
};

typedef __malloc_alloc_template<0> malloc_alloc;
typedef malloc_alloc alloc;

//////////////////////////////////////////////////////////////////////
#elif defined(G__HPUX)

class allocator {
};

//////////////////////////////////////////////////////////////////////
#else // non gcc, non HPUX compiler

template <class T>
class allocator
{
public:
  typedef size_t      size_type;
  typedef ptrdiff_t   difference_type;
  typedef T*          pointer;
  typedef const T*    const_pointer;
  typedef T&          reference;
  typedef const T&    const_reference;
  typedef T           value_type;
  // template members don't really work with cint yet...
#if 0
  template <class U> struct rebind { typedef allocator<U> other; };
#endif
#if 0
  pointer address(reference _X) const ;
  const_pointer address(const_reference _X) const;
#else
#if !defined(G__BORLAND) && !defined(G__SUNPRO_C)
  pointer address(T& _X) const ;
  const_pointer address(const T& _X) const;
#endif
#endif
#if !defined(G__BORLAND) && !defined(G__SUNPRO_C)
  pointer allocate(size_type _N, const void *);
#else
  pointer allocate(size_type _N, void *);
#endif
  //char  *_Charalloc(size_type _N);
#ifndef G__KCC
  void deallocate(void *_P, size_type);
#else
  void deallocate(T *_P, size_type); //???
#endif
#if !defined(G__BORLAND) && !defined(G__SUNPRO_C)
  void construct(pointer _P, const T& _V);
  void destroy(pointer _P);
  size_type max_size() const;
#endif

  friend bool operator==(const allocator<T>& x, const allocator<T>& y);
  friend bool operator!=(const allocator<T>& x, const allocator<T>& y);
};

#if 0
template<class _Ty, class _U> inline
 bool operator==(const allocator<_Ty>&, const allocator<_U>&)
  {return (true); }
template<class _Ty, class _U> inline
 bool operator!=(const allocator<_Ty>&, const allocator<_U>&)
  {return (false); }
#endif

// specialized tempatel class allocator<void>
class allocator<void> {
 public:
	typedef void _Ty;
	typedef _Ty *pointer;
	typedef const _Ty *const_pointer;
	typedef _Ty value_type;
};

#endif // G__GNUC
//////////////////////////////////////////////////////////////////////

/**********************************************************************
* auto_ptr
**********************************************************************/
template <class X> class auto_ptr {
private:
  X* ptr;
  mutable bool owns;
  //template<class Y> struct auto_ptr_ref { };
public:
  typedef X element_type;
  explicit auto_ptr(X* p = 0) : ptr(p), owns(p?true:false) {}
  auto_ptr(auto_ptr& a) {owns=a.owns; ptr=a.ptr; a.owns=0;}
  
  // this implementation may not be correct
  template <class T> auto_ptr(auto_ptr<T>& a) {owns=a.owns; ptr=a.release();}
  
#if 0
  // this does not exist in standard.
  template <class T> auto_ptr(T* a) {
    ptr=a;
    owns=true;
  }
#endif
  
  auto_ptr& operator=(auto_ptr& a) {
    if (a.ptr != ptr) {
      if (owns) delete ptr;
      owns = a.owns;
      ptr = a.ptr;
      a.owns = 0;
    }
    return(*this);
  }
  
  // this implementation may not be correct
  template <class T> auto_ptr& operator=(auto_ptr<T>& a) {
    if (a.ptr != ptr) {
      if (owns) delete ptr;
      owns = a.owns;
      ptr = a.release();
    }
    return(*this);
  }
  
  ~auto_ptr() { if(owns) delete ptr; }
  
  X& operator*() const { return *ptr; }
  X* operator->() const { return ptr; }
  X* get() const { return ptr; }
  X* release() { owns=false; return ptr; }
#if 0
  // My g++, VC++, BC++ does not support this so far.
  void reset(X* p=0) {
    if(p!=ptr || !owns) { 
      if(owns) delete ptr;  
      ptr = p; 
      owns = p?true:false;
    }
  }
#endif

  // auto_ptr conversions
  //auto_ptr(auto_ptr_ref<X>& x) { }
  //template<class Y> operator auto_ptr_ref<Y>() { return auto_ptr_ref<Y>(); }
  //template<class Y> operator auto_ptr<Y>() { return auto_ptr<T>(); }
};

#pragma endif
