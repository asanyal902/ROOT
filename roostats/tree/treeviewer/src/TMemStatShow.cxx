// @(#)root/treeviewer:$Id$
// Author: Rene Brun   21/09/2010

/*************************************************************************
 * Copyright (C) 1995-2010, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/

//___________________________________________________________________________
// Utility class post-processing the file generated by TMemStat (default memstat.root)
//
// TMemStat records all the calls to malloc and free and write a TTree
// with the position where the memory is allocated/freed , as well as
// the number of bytes.
//
// To use the class TMemStat, add the following statement at the beginning
// of your script or program
//     TMemStat mm("gnubuiltin");
// or in an interactive session do something like:
//    root > TMemStat mm("gnubuiltin");
//    root > .x somescript.C
//    root > .q
//
// another (may be more practical way) is to modify $ROOTSYS/etc/system.rootrc
// and activate the variable
//    Root.TMemStat:           1
//
// The file collected by TMemStat is named memstat_ProcessID and can be analyzed and results shown
// by executing the static function Show.
// When TMemStat is active it recors every call to malloc/free in a ROOT Tree.
// You must be careful when running jobs with many millions (or more) of calls
// to malloc/free because the generated Tree may become very large.
// The TMemStat constructor TMemStat(const char* system, Int_t buffersize, Int_t maxcalls)
// has its 3 arguments optional:
//   -system refers to the internal algorithm to compute the back traces.
//    the recommended value is "gnubuiltin"
//   -buffersize is the number of calls to malloc or free that can be stored in one memory buffer.
//    when the buffer is full, the calls to malloc/free pointing to the same location
//    are eliminated and not written to the final Tree. The default value 100000
//    is such that between 50 and 90% of the calls are eliminated depending on the application.
//    You can set buffersize <=1 to keep every single call to malloc/free.
//   -maxcalls can set a limit for the maximum number of calls to be registered in the Tree.
//    The default value is 5000000.
// The 3 arguments can be set  in $ROOTSYS/etc/system.rootrc
//    Root.TMemStat.system      gnubuiltin
//    Root.TMemStat.buffersize  100000
//    Root.TMemStat.maxcalls    5000000
//
// TMemStat::Show creates 3 canvases.
// -In canvas1 it displays a dynamic histogram showing for pages (10 kbytes by default)
//  the percentage of the page used.
//  A summary pave shows the total memory still in use when the TMemStat object
//  goes out of scope and the average occupancy of the pages.
//  The average occupancy gives a good indication of the memory fragmentation.
//
// -In canvas2 it displays the histogram of memory leaks in decreasing order.
//  when moving the mouse on this canvas, a tooltip shows the backtrace for the leak
//  in the bin below the mouse.
//
// -In canvas3 it displays the histogram of the nbigleaks largest leaks (default is 20)
//    for each leak, the number of allocs and average alloc size is shown.
//
//
// Simply do:
//   root > TMemStat::Show()
// or specifying arguments
//   root > TMemStat::Show(0.1,20,"mydir/mymemstat.root");
//
// The first argument to Show is the percentage of the time of the original job
// that produced the file after which the display is updated. By default update=0.1,
// ie 10 time intervals will be shown.
// The second argument is nbigleaks.
// The third argument is the imput file name (result of TMemStat).
// If this argument is omitted, Show will take the most recent file
// generated by TMemStat.
//
//Author: Rene Brun 7 July 2010
//___________________________________________________________________________
      
#include "TMemStatShow.h"
#include "TMath.h"
#include "TFile.h"
#include "TTree.h"
#include "TCanvas.h"
#include "TStyle.h"
#include "TH1.h"
#include "TPaveText.h"
#include "TPaveLabel.h"
#include "TSystem.h"
#include "TGClient.h"
#include "TGToolTip.h"
#include "TRootCanvas.h"

   TTree     *gT;        //TMemStat Tree
   TH1D      *gHalloc;   //histogram with allocations
   TH1D      *gHfree;    //histogram with frees
   TH1I      *gHleaks;   //histogram with leaks
   TH1I      *gHentry;   //histogram with entry numbers in the TObjArray
   TH1I      *gHdiff;    //histogram with diff of entry number between alloc/free
   
   TGToolTip *gTip;      //pointer to tool tip
   TObjArray *gBtidlist; //list of back trace ids
   Double_t  *gV1;       //pointer to V1 array of TTree::Draw
   Double_t  *gV2;       //pointer to V1 array of TTree::Draw
   Double_t  *gV3;       //pointer to V1 array of TTree::Draw
   Double_t  *gV4;       //pointer to V1 array of TTree::Draw
   TCanvas   *gC1;       //pointer to anvas shoing allocs/deallocs vs time
   TCanvas   *gC2;       //pointer to canvas with leaks in decreasing order
   TCanvas   *gC3;       //pointer to canvas showing the main leaks

//___________________________________________________________________________
void TMemStatShow::Show(double update, int nbigleaks, const char* fname) 
{
   // function called by TMemStat::Show
   // Open the memstat data file, then call TTree::Draw to precompute
   // the arrays of positions and nbytes per entry.
   // update is the time interval in the data file  in seconds after which
   // the display is updated. For example is the job producing the memstat.root file
   // took 100s to execute, an update of 0.1s will generate 1000 time views of
   // the memory use.
   // the histogram hbigleaks will contain the nbigleaks largest leaks
   // if fname=="*" (default), the most recent file memstat*.root will be taken.
   
   TString s;
   if (!fname || strlen(fname) <5 || strstr(fname,"*")) {
      //take the most recent file memstat*.root
      s = gSystem->GetFromPipe("ls -lrt memstat*.root");
      Int_t ns = s.Length();
      fname = strstr(s.Data()+ns-25,"memstat");
   }
   printf("Analyzing file: %s\n",fname);
   TFile *f = TFile::Open(fname);
   if (!f) {
      printf("Cannot open file %s\n",fname);
      return;
   }
   gT = (TTree*)f->Get("T");
   if (!gT) {
      printf("cannot find the TMemStat TTree named T in file %s\n",fname);
      return;
   }
   if (update <= 0) {
      printf("Illegal update value %g, changed to 0.01\n",update);
      update = 0.01;
   }
   if (update < 0.001) printf("Warning update parameter is very small, processing may be slow\n");
   
   //initialize statics
   gTip = 0;
   gBtidlist = 0;
      
   Long64_t nentries = gT->GetEntries();
   gT->SetEstimate(nentries+10);
   Long64_t nsel = gT->Draw("pos:nbytes:time:btid","","goff");
   
   //now we compute the best binning for the histogram
   Int_t nbytes;
   Double_t pos;
   gV1 = gT->GetV1();
   gV2 = gT->GetV2();
   gV3 = gT->GetV3();
   gV4 = gT->GetV4();
   Long64_t imean = (Long64_t)TMath::Mean(nsel,gV1);
   Long64_t irms  = (Long64_t)TMath::RMS(nsel,gV1);
   //Long64_t bw = 10000;
   Long64_t bw = 1000;
   imean = imean - imean%bw;
   irms = irms -irms%bw;
   Int_t nbins = Int_t(4*irms/bw);
   Long64_t ivmin = imean -bw*nbins/2;
   Long64_t ivmax = ivmin+bw*nbins;
   if (ivmax > 2000000000 && ivmin <2000000000) {
      //the data set has been likely generated on a 32 bits machine
      //we are mostly interested by the small allocations, so we select
      //only values below 2 GBytes
      printf("memory locations above 2GBytes will be ignored\n");
      nsel = gT->Draw("pos:nbytes:time:btid","pos <2e9","goff");
      gV1 = gT->GetV1();
      gV2 = gT->GetV2();
      gV3 = gT->GetV3();
      gV4 = gT->GetV4();
      imean = (Long64_t)TMath::Mean(nsel,gV1);
      irms = (Long64_t)TMath::RMS(nsel,gV1);
      bw = 10000;
      imean = imean - imean%bw;
      irms = irms -irms%bw;
      nbins = Int_t(4*irms/bw);
      ivmin = imean -bw*nbins/2;
      ivmax = ivmin+bw*nbins;
   } 
   update *= 0.0001*gV3[nsel-1]; //convert time per cent in seconds
   Long64_t nvm = Long64_t(ivmax-ivmin+1);
   Long64_t *nbold = new Long64_t[nvm];
   Int_t *ientry  = new Int_t[nvm];
   memset(nbold,0,nvm*8);
   memset(ientry,0,nvm*4);
   Double_t dv = (ivmax-ivmin)/nbins;
   TH1D *h = new TH1D("h",Form("%s;pos;per cent of pages used",fname),nbins,ivmin,ivmax);
   TAxis *axis = h->GetXaxis();
   gStyle->SetOptStat("ie");
   h->SetFillColor(kRed);
   h->SetMinimum(0);
   h->SetMaximum(100);
   gHalloc = new TH1D("gHalloc",Form("%s;pos;number of mallocs",fname),nbins,ivmin,ivmax);
   gHfree  = new TH1D("gHfree", Form("%s;pos;number of frees",fname),nbins,ivmin,ivmax);
   gHdiff = new TH1I("gHdiff","",1000,0,1e5);
    //open a canvas and draw the empty histogram
   gC1 = new TCanvas("gC1","c1",1200,600);
   gC1->SetFrameFillColor(kYellow-3);
   gC1->SetGridx();
   gC1->SetGridy();
   h->Draw();
   //create a TPaveText to show the summary results
   TPaveText *pvt = new TPaveText(.5,.9,.75,.99,"brNDC");
   pvt->Draw();
   //create a TPaveLabel to show the time
   TPaveLabel *ptime = new TPaveLabel(.905,.7,.995,.76,"time","brNDC");
   ptime->SetFillColor(kYellow-3);
   ptime->Draw();
   //draw producer identifier
   TNamed *named = (TNamed*)gT->GetUserInfo()->FindObject("SysInfo");
   TText tmachine;
   tmachine.SetTextSize(0.02);
   tmachine.SetNDC();
   if (named) tmachine.DrawText(0.01,0.01,named->GetTitle());

   //start loop on selected rows
   Int_t bin,nb=0,j;
   Long64_t ipos;
   Double_t dbin,rest,time;
   Double_t updateLast = 0;
   Int_t nleaks = 0;
   Int_t i;
   for (i=0;i<nsel;i++) {
      pos    = gV1[i];
      ipos = (Long64_t)(pos-ivmin);
      nbytes = (Int_t)gV2[i];
      time = 0.0001*gV3[i];
      bin = axis->FindBin(pos);
      if (bin<1 || bin>nbins) continue;
      dbin = axis->GetBinUpEdge(bin)-pos;
      if (nbytes > 0) {
         ientry[ipos] = i;
         gHalloc->Fill(pos);
         if (dbin > nbytes) dbin = nbytes;
         //fill bytes in the first page
         h->AddBinContent(bin,100*dbin/dv);
	 //fill bytes in full following pages
         nb = Int_t((nbytes-dbin)/dv);
	 if (bin+nb >nbins) nb = nbins-bin;
         for (j=1;j<=nb;j++) h->AddBinContent(bin+j,100);
	 //fill the bytes remaining in last page
         rest = nbytes-nb*dv-dbin;
	 if (rest > 0) h->AddBinContent(bin+nb+1,100*rest/dv);
	 //we save nbytes at pos. This info will be used when we free this slot
         if (nbold[ipos] > 0) printf("reallocating %d bytes (was %lld) at %lld, entry=%d\n",nbytes,nbold[ipos],ipos,i);
         if (nbold[ipos] == 0) {
            nleaks++;            
            //save the Tree entry number where we made this allocation
            ientry[ipos] = i;
         }
         nbold[ipos] = nbytes;
      } else {
         gHfree->Fill(pos);
         nbytes = nbold[ipos];
	 if (bin+nb >nbins) nb = nbins-bin;
	 nbold[ipos] = 0; nleaks--;
         gHdiff->Fill(i-ientry[ipos]);
	 if (nbytes <= 0) continue;
         //fill bytes free in the first page
         if (dbin > nbytes) dbin = nbytes;
	 h->AddBinContent(bin,-100*dbin/dv);
	 //fill bytes free in full following pages
	 nb = Int_t((nbytes-dbin)/dv);
	 if (bin+nb >nbins) nb = nbins-bin;
         for (j=1;j<=nb;j++) h->AddBinContent(bin+j,-100);
	 //fill the bytes free in  in last page
	 rest = nbytes-nb*dv-dbin;
	 if (rest > 0) h->AddBinContent(bin+nb+1,-100*rest/dv);

      }
      if (time -updateLast > update) {
         //update canvas at regular intervals
	 updateLast = time;
         h->SetEntries(i);
	 gC1->Modified();
         pvt->GetListOfLines()->Delete();
         Double_t mbytes = 0;
         Int_t nonEmpty = 0;
         Double_t w;
         for (Int_t k=1;k<nbins;k++) {
            w = h->GetBinContent(k);
            if (w > 0) {
               nonEmpty++;
               mbytes += 0.01*w*dv;
            }
         }
         Double_t occupancy = mbytes/(nonEmpty*0.01*dv);
         pvt->AddText(Form("memory used = %g Mbytes",mbytes*1e-6));
         pvt->AddText(Form("page occupancy = %f per cent",occupancy));
         pvt->AddText("(for non empty pages only)");
         ptime->SetLabel(Form("%g sec",time));
         
	 gC1->Update();
         gSystem->ProcessEvents();
      }
   }
   h->SetEntries(nsel);
   Int_t nlmax = nleaks;
   nleaks += 1000;
   Int_t *lindex  = new Int_t[nleaks];
   Int_t *entry   = new Int_t[nleaks];
   Int_t *ileaks  = new Int_t[nleaks];

   nleaks =0;
   for (Int_t ii=0;ii<nvm;ii++) {
      if (nbold[ii] > 0) {
         ileaks[nleaks] = (Int_t)nbold[ii];
         entry[nleaks]  = ientry[ii];
         nleaks++;
         if (nleaks > nlmax) break;
      }
   }

   TMath::Sort(nleaks,ileaks,lindex);
   gHentry = new TH1I("fHentry","leak entry index",nleaks,0,nleaks);
   gHleaks = new TH1I("fHleaks","leaks;leak number;nbytes in leak",nleaks,0,nleaks);
   for (Int_t k=0;k<nleaks;k++) {
      Int_t kk = lindex[k];
      i = entry[kk];
      gHentry->SetBinContent(k+1,i);
      gHleaks->SetBinContent(k+1,ileaks[kk]);
   }
   delete [] ileaks;
   delete [] entry;
   delete [] lindex;
   delete [] nbold;
   delete [] ientry;
   gHentry->SetEntries(nleaks);
   gHleaks->SetEntries(nleaks);
   
   //open a second canvas and draw the histogram with leaks in decreasing order
   gC2 = new TCanvas("gC2","c2",1200,600);
   gC2->SetFrameFillColor(kCyan-6);
   gC2->SetGridx();
   gC2->SetGridy();
   gC2->SetLogy();
   gHleaks->SetFillColor(kRed-3);
   if (nleaks > 1000) gHleaks->GetXaxis()->SetRange(1,1000);
   gHleaks->Draw();
   //draw producer identifier
   if (named) tmachine.DrawText(0.01,0.01,named->GetTitle());
   
   //construct the tooltip
   TRootCanvas *rc = (TRootCanvas *)gC2->GetCanvasImp();
   TGMainFrame *frm = dynamic_cast<TGMainFrame *>(rc);
   // create the tooltip with a timeout of 250 ms
   if (!gTip) gTip = new TGToolTip(gClient->GetDefaultRoot(), frm, "", 250);
   gC2->Connect("ProcessedEvent(Int_t, Int_t, Int_t, TObject*)",
               "TMemStatShow", 0, "EventInfo(Int_t, Int_t, Int_t, TObject*)");
   
   //open a third canvas and draw the histogram with the nbigleaks largest leaks
   gC3 = new TCanvas("gC3","c3",1200,600);
   gC3->SetFrameFillColor(kCyan-6);
   gC3->SetGridx();
   gC3->SetGridy();
   gC3->SetLogx();
   gC3->SetLeftMargin(0.05);
   gC3->SetRightMargin(0.7);
   
   //fill histogram htotleaks accumulating in the same bin all leaks
   //from btids having identical nchar first characters   
   TH1I *htotleaks = new TH1I("htotleaks","main leaks sorted by btids",100,0,0);
   Int_t l;
   for (l=1;l<=nleaks;l++) {
      TString btstring = "";
      TMemStatShow::FillBTString(l,1,btstring);
      htotleaks->Fill(btstring.Data()+2,gHleaks->GetBinContent(l));
   }
   Double_t tsize = 0.03;
   if (nbigleaks > 30) tsize = 0.02;
   htotleaks->LabelsOption(">");
   htotleaks->GetXaxis()->SetRange(1,nbigleaks); 
   htotleaks->GetXaxis()->SetLabelSize(tsize);
   htotleaks->GetYaxis()->SetLabelSize(tsize);
   htotleaks->SetFillColor(kBlue-3);
   htotleaks->Draw("hbar2 y+");
   
   //now loop on all the sorted bins and count the number of leaks
   Double_t xr = 0.96*gC3->GetLeftMargin();
   Double_t xr2 = 1.04*gC3->GetLeftMargin();
   Double_t ytop = 1-gC3->GetTopMargin();
   Double_t ylow = gC3->GetBottomMargin();
   Double_t dy = (ytop-ylow)/nbigleaks;
   TString btstring;
   TText tnl;
   tnl.SetNDC();
   tnl.SetTextSize(tsize);
   tnl.SetTextAlign(32);
   TText tnl2;
   tnl2.SetNDC();
   tnl2.SetTextSize(tsize);
   tnl2.SetTextAlign(12);
   tnl2.SetTextColor(kYellow);
   for (Int_t lb=1;lb<=nbigleaks;lb++) {
      if (htotleaks->GetBinContent(lb) <= 0) continue;
      const char *label = htotleaks->GetXaxis()->GetBinLabel(lb);
      Int_t nchlabel = strlen(label);
      if (nchlabel == 0) htotleaks->GetXaxis()->SetBinLabel(lb,"???");
      Int_t nl =0;
      for (l=1;l<=nleaks;l++) {
         btstring = "";
         TMemStatShow::FillBTString(l,1,btstring);
	 if (nchlabel > 0) {	 
            if (!strncmp(btstring.Data()+2,label,nchlabel)) nl++;
	 } else {
	    if (btstring.Length() == 0) nl++;
	 }
      }
      Double_t yr = ylow +(lb-0.5)*dy;
      tnl.DrawText(xr,yr,Form("%d",nl));
      Int_t nbmean = Int_t(htotleaks->GetBinContent(lb)/nl);
      if (lb == 1) tnl2.DrawText(xr2,yr,Form("%d bytes/alloc",nbmean));
      else         tnl2.DrawText(xr2,yr,Form("%d",nbmean));
   }
   tnl.DrawText(xr,ytop+0.015,"nallocs");
   tnl.DrawText(1-gC3->GetRightMargin(),0.5*ylow,"nbytes");
   //draw producer identifier
   if (named) tmachine.DrawText(0.01,0.01,named->GetTitle());
   
}

//______________________________________________________________________
void TMemStatShow::EventInfo(Int_t event, Int_t px, Int_t , TObject *selected)
{
   // static: draw the tooltip showing the backtrace for the bin at px
   if (!gTip) return;
   gTip->Hide();
   if (event == kMouseLeave)
      return;
   Double_t xpx  = gC2->AbsPixeltoX(px);
   Int_t bin = gHleaks->GetXaxis()->FindBin(xpx);
   if (bin <=0 || bin > gHleaks->GetXaxis()->GetNbins()) return;
   Int_t nbytes  = (Int_t)gHleaks->GetBinContent(bin);
   Int_t entry   = (Int_t)gHentry->GetBinContent(bin);
   Double_t time = 0.0001*gV3[entry];
   TString ttip;
   TMemStatShow::FillBTString(bin,0,ttip);
      
   if (selected) {
      TString form1 = TString::Format("  Leak number=%d, leaking %d bytes at entry=%d    time=%gseconds\n\n",bin,nbytes,entry,time);
      gTip->SetText(TString::Format("%s%s",form1.Data(),ttip.Data() ));
      gTip->SetPosition(px+15, 100);
      gTip->Reset();
   }
}

//______________________________________________________________________
void TMemStatShow::FillBTString(Int_t bin,Int_t mode,TString &btstring)
{
   // static: fill btstring with the traceback corresponding to bin in gHleaks
   //          btstring must be initialized in calling function
   
   Int_t entry  = (Int_t)gHentry->GetBinContent(bin);
   Int_t btid   = (Int_t)gV4[entry];
   TH1I *hbtids = (TH1I*)gT->GetUserInfo()->FindObject("btids");
   if (!hbtids) return;
   if (!gBtidlist) gBtidlist = (TObjArray*)gT->GetUserInfo()->FindObject("FAddrsList");
   if (!gBtidlist) gBtidlist = (TObjArray*)gFile->Get("FAddrsList"); //old memstat files
   if (!gBtidlist) return;
   Int_t nbt = (Int_t)hbtids->GetBinContent(btid-1);
   for (Int_t i=0;i<nbt;i++) {
      Int_t j = (Int_t)hbtids->GetBinContent(btid+i);
      TNamed *nm = (TNamed*)gBtidlist->At(j);
      if (nm==0) break;
      char *title = (char*)nm->GetTitle();
      Int_t nch = strlen(title);
      if (nch < 10) continue;
      if (strstr(title,"memstat")) continue;
      if (strstr(title,"TMemStatHook")) continue;
      char *bar = strchr(title+5,'|');
      if (!bar) bar = title;
      
      if (strstr(bar,"operator new")) continue;
      if (strstr(bar,"libMemStat")) continue;
      if (strstr(bar,"G__Exception")) continue;
      if (mode) {
         btstring += TString::Format("%s ",bar);
         if (btstring.Length() > 80) return;
      } else {
         btstring += TString::Format("%2d %s\n",i,bar+1);
      }
   }
}
