<br/>
<hr/>
<a name="io"></a> 
<h3>I/O</h3>
<h4>File Format</h4>
<ul><li><b>The default for streaming the content of STL containers was changed from object-wise
to member-wise.</b><p/>

We evaluated the impact of moving to MemberWise streaming using 5 different CMS data files:
<br/>
<ul><li>cms1.root an older split using level 99 Reco file 
</li><li>cms2.root a more recent non split raw data file 
</li><li>cms3.root a more recent non split Reco file 
</li><li>cms4.root is an example of the lepton plus jet analysis format known as a user PAT-tuple (split)
</li><li>cms5.root is an example AOD (analysis object dataset) format file.  It is not split because the objects here are a strict subset of the RECO objects. 
</li></ul>
We rewrote all the files using the v5.26/00 new basket clustering algorithm using both memberwise streaming and objectwise streaming. 
<p/>
In the table below the read time is the CPU time to completion including loading the libraries. 
When reading the file where always in the os cache (since we are focusing evaluating cpu time). 
<p/>
The number of event actually read varies from file set to file set but was calibrated to result 
in about 10s of cpu time.  The files are read using a library generated with TFile::MakeProject. 
<p/>
The object-wise files are between 2% and 10% larger compared to their member-wise coutnerpart.
<p/>
The CPU time for reading object-wise files is 12% higher for split files 
and 30% higher for non-split files. 
<p/>
So the improvement is significant enough to warrant switch the default from objectwise to memberwise.
<p/>

<table border="1" CELLPADDING=4>
<CAPTION><EM>Split files</EM></CAPTION>
<tr>
<th>Filename</th><th>Memberwise</th><th>Size</th><th>Cpu Time To read</th>
</tr>
<tr><td align=center>  cms1.root </td><td align=center>   N   </td><td align=center>  17.5 Gb  </td><td align=center>  10.55s +/- 0.15 (2200 entries) </td></tr>
<tr><td align=center>  cms1.root </td><td align=center>   Y   </td><td align=center>  16.8 Gb  </td><td align=center>  9.12s +/- 0.08 (2200 entries)   </td></tr>

<tr><td align=center>  cms4.root </td><td align=center>   N   </td><td align=center>  1.47 Gb  </td><td align=center>  10.18s +/- 0.19 (2500 entries)  </td></tr>
<tr><td align=center>  cms4.root </td><td align=center>   Y   </td><td align=center>  1.43 Gb  </td><td align=center>  9.24s +/- 0.06 (2500 entries)  </td></tr>
</table>
<p>

<table border="1" CELLPADDING=4>
<CAPTION><EM>Non Split files</EM></CAPTION>
<tr>
<th>Filename</th><th>Memberwise</th><th>Size</th><th>Cpu Time To read</th>
</tr>
<tr><td align=center>cms2.root</td><td align=center>    N   </td><td align=center>  1.65 Gb  </td><td align=center>  10.95s +/- 0.05 (1000 entries)  </td></tr>
<tr><td align=center>cms2.root</td><td align=center>    Y   </td><td align=center>  1.53 Gb  </td><td align=center>   8.20s +/- 0.05 (1000 entries)  </td></tr>

<tr><td align=center>cms3.root</td><td align=center>    N   </td><td align=center>  0.780 Gb </td><td align=center> 10.59s +/- 0.05 (700 entries)  </td></tr>
<tr><td align=center>cms3.root</td><td align=center>    Y   </td><td align=center>  0.717 Gb </td><td align=center>   8.29s +/- 0.08 (700 entries)  </td></tr>

<tr><td align=center>cms5.root</td><td align=center>    N   </td><td align=center>  1.55 Gb  </td><td align=center>  10.20s +/- 0.17 (700 entries)  </td></tr>
<tr><td align=center>cms5.root</td><td align=center>    Y   </td><td align=center>  1.40 Gb  </td><td align=center>   8.09s +/- 0.08 (700 entries) </td></tr>
</table>

</li><li>In the case of a data member which is a pointer to a STL container, eg:
<pre style="border:gray 1px solid;padding:0.5em 2em;background:#ffe">   std::container<Data> *fDataObjects;</pre>
and which is stored member-wise, add support for the schema evolution of the class 'Data'.
</p>
This requires a change in the on file format used to store this type
of data members (i.e. by adding inline the version number of the class
'Data').
</p>
To read file containing this construct and written with this revision
using an older version of ROOT you will need the following patches:
   <ul><li>For v5.22/00, you will need the <a href="http://root.cern.ch/viewvc?view=rev&revision=33174">patch r33174</a>
     or v5.22/00k</li>
   <li>For v5.26/00, you will need <a href="http://root.cern.ch/viewvc?view=rev&revision=33176">patch r33176</a>
     or v5.26/00c</li>
   </ul>
Additionally, we no longer allow the member wise streaming of a class which
has a custom streamer nor of any data members marked with //||
</li>
</ul>

<h4>TFile::MakeProject</h4>
Extend TFile::MakeProject to support genreflex, cases of user's data model where
the 2 distincts pointers point to a single object and more cases where we are 
missing the StreamerInfo and need to guess whether the symbol represent an enum,
a class or a namespace.

To use genreflex, call MakeProject with the "genreflex" option, for example:
<pre style="border:gray 1px solid;padding:0.5em 2em;background:#ffe">
   file->MakeProject(libdir,"*","NEW+genreflex");
</pre>
To make sure the library created by MakeProject does not double delete an object,
tell the StreamerElement representing one of the pointers pointing to the object
to never delete the object.  For example:

<pre style="border:gray 1px solid;padding:0.5em 2em;background:#ffe">
   TClass::AddRule("HepMC::GenVertex m_event attributes=NotOwner");
</pre>

MakeProject now implements a move constructor for each classes.   For the implementation, we 'use' the 'copy constructor' until the C++ compilers properly support the official move constructor notation.   Implementing a move constructor avoid having to delete and reconstruct resource during a std::vector resize and avoid the double delete induced by using the default copy constructor.

<h4>Misc.</h4>
<ul><li>To make sure that the class emulation layer of ROOT does not double delete an object,
tell the StreamerElement representing one of the pointers pointing to the object
to never delete the object.  For example:

<pre style="border:gray 1px solid;padding:0.5em 2em;background:#ffe">
   TClass::AddRule("HepMC::GenVertex m_event attributes=NotOwner");
</pre>
</li>
<li>The handling of memory by the collection proxy has been improved in the case of a 
collection of pointers which can now become owner of its content.<p/>

The default, for backward compatibility reasons and to avoid double delete (at the expense
of memory leaks), the container of pointers are <em>still</em> not owning their content
<em>unless</em> they are a free standing container (i.e. itself not contained in another
object).<p/>
To make a container of pointers become owner of its content do something like:
<pre style="border:gray 1px solid;padding:0.5em 2em;background:#ffe">
      TClass::AddRule("ObjectVector<LHCb::MCRichDigitSummary> m_vector options=Owner");
</pre>
For MakeProject, use file->GetStreamerInfoCache() instead of the TClass GetStreamerInfo.
</li>
<li>TH1::Streamer and TGraph2D::Streamer no longer reset the kCanDelete bit directly so that the user can give
ownership of the object to the canvas they are stored with.  However, if they are saved on their own, the mechanism
that associates them to the current directory (DirectoryAutoAdd) will now reset the bit to avoid any possible
ownsership confusion.</li>
</ul>


